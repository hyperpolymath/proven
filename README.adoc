// SPDX-License-Identifier: Palimpsest-MPL-1.0
= proven
:toc: macro
:toclevels: 3
:icons: font
:source-highlighter: rouge

*Code that cannot crash.*

image:https://img.shields.io/badge/Python-Works-blue?logo=python[Python]
image:https://img.shields.io/badge/Rust-Works-orange?logo=rust[Rust]
image:https://img.shields.io/badge/JavaScript-Works-yellow?logo=javascript[JavaScript]
image:https://img.shields.io/badge/Go-Works-00ADD8?logo=go[Go]
image:https://img.shields.io/badge/Verified-Mathematically_Proven-blueviolet[Verified]
image:https://img.shields.io/badge/License-Palimpsest-MPL-1.0-blue[License]

toc::[]

== The Problem

[source,python]
----
# Your code at 3am
result = 10 / user_input  # ZeroDivisionError
data = json.loads(response)["key"]  # KeyError
url = urllib.parse.urlparse(user_url)  # Malformed URL? Who knows
password = hashlib.md5(pwd).hexdigest()  # You just got hacked
----

**Every one of these will crash your app or create a security hole.**

== The Solution

[source,python]
----
from proven import SafeMath, SafeJson, SafeUrl, SafePassword

# Cannot crash. Ever. Mathematically proven.
result = SafeMath.div(10, user_input)  # Returns None if zero, not an exception
data = SafeJson.get(response, "key")  # Returns None if missing, typed if present
url = SafeUrl.parse(user_url)  # Returns structured error or valid URL
hashed = SafePassword.hash(pwd)  # Argon2id, timing-safe, correct parameters
----

== What "Mathematically Proven" Means

This isn't marketing fluff. Here's what makes proven different from regular libraries.

Every function in `proven` is written in https://idris-lang.org/[Idris 2], a language with *dependent types*. The compiler literally proves your code is correct before it runs.

=== Understanding Dependent Types (In 2 Minutes)

In most languages, types are separate from values:

[source,python]
----
def get_first(items: list) -> int:
    return items[0]  # Crashes if empty!
----

The type system has no idea if the list is empty. It just trusts you.

In Idris 2, types can depend on values:

[source,idris]
----
-- This type signature REQUIRES a non-empty list
getFirst : (items : List Int) -> {auto prf : NonEmpty items} -> Int
----

The `{auto prf : NonEmpty items}` part means: "The caller must provide proof that `items` is non-empty." If you try to call this with an empty list, **the code won't compile**.

This is the core insight: instead of runtime crashes, we get compile-time errors.

=== How This Translates to Your Code

|===
| Regular Code | Proven Code

| "I think this won't crash"
| "The compiler proved this cannot crash"

| "I tested it and it worked"
| "Every possible input was checked at compile time"

| "It passed code review"
| "A theorem prover verified it"
|===

=== Want to Learn More?

The proofs are available in `src/Proven/` and we encourage you to explore them! Understanding dependent types is a valuable skill. Here are some resources:

- https://idris2.readthedocs.io/en/latest/tutorial/index.html[Idris 2 Tutorial] — Official introduction to dependent types
- https://www.youtube.com/watch?v=mOtKD7ml0NU[Type-Driven Development with Idris] — Edwin Brady's talk
- link:docs/PROOFS.md[Our proof documentation] — Explains each proof in this library

That said, you can absolutely use the library without understanding the proofs—the whole point of formal verification is that the compiler has already checked correctness for you.

== Modules

=== SafeMath — Arithmetic That Can't Overflow

[cols="1,2,2"]
|===
| Function | What It Does | What It Prevents

| `div(a, b)`
| Safe division, returns `None` on zero
| `ZeroDivisionError`

| `add_checked(a, b)`
| Addition with overflow detection
| Silent integer overflow

| `mul_checked(a, b)`
| Multiplication with overflow detection
| Integer overflow exploits

| `mod(a, b)`
| Safe modulo
| Division by zero

| `abs_safe(n)`
| Absolute value (handles MIN_INT)
| Overflow on `abs(MIN_INT)`
|===

[source,python]
----
from proven import SafeMath

SafeMath.div(10, 2)   # 5
SafeMath.div(10, 0)   # None (not an exception!)

SafeMath.add_checked(2**63 - 1, 1)  # None (overflow detected)
SafeMath.add_checked(5, 3)          # 8
----

=== SafeString — Text That Can't Corrupt

[cols="1,2,2"]
|===
| Function | What It Does | What It Prevents

| `decode_utf8(bytes)`
| Safe UTF-8 decoding
| `UnicodeDecodeError`

| `escape_sql(s)`
| SQL injection prevention
| SQL injection attacks

| `escape_html(s)`
| XSS prevention
| Cross-site scripting

| `truncate(s, n)`
| Safe truncation (respects graphemes)
| Slicing mid-emoji
|===

[source,python]
----
from proven import SafeString

SafeString.decode_utf8(b"\xff\xfe")  # None (invalid UTF-8)
SafeString.decode_utf8(b"hello")     # "hello"

SafeString.escape_sql("'; DROP TABLE users;--")
# "'' ; DROP TABLE users;--" (neutralized)
----

=== SafeJson — Parsing That Can't Fail Unexpectedly

[cols="1,2,2"]
|===
| Function | What It Does | What It Prevents

| `parse(s)`
| Safe JSON parsing
| `JSONDecodeError`

| `get(obj, key)`
| Safe key access
| `KeyError`

| `get_path(obj, path)`
| Safe nested access
| Chained `KeyError`

| `get_int(obj, key)`
| Typed extraction
| Type confusion
|===

[source,python]
----
from proven import SafeJson

data = SafeJson.parse('{"name": "Alice", "age": 30}')
SafeJson.get(data, "name")      # "Alice"
SafeJson.get(data, "missing")   # None
SafeJson.get_int(data, "age")   # 30
SafeJson.get_int(data, "name")  # None (wrong type)

SafeJson.parse("not json")  # Error object with details, not exception
----

=== SafeUrl — URLs That Can't Be Exploited

[cols="1,2,2"]
|===
| Function | What It Does | What It Prevents

| `parse(s)`
| RFC 3986 compliant parsing
| Malformed URL crashes

| `is_safe_redirect(url, allowed)`
| Open redirect prevention
| Open redirect attacks

| `normalize(url)`
| URL normalisation
| URL bypass attacks

| `get_path_safe(url)`
| Path without traversal
| `../../../etc/passwd`
|===

[source,python]
----
from proven import SafeUrl

url = SafeUrl.parse("https://example.com/path?query=1#hash")
url.scheme  # "https"
url.host    # "example.com"
url.path    # "/path"

SafeUrl.parse("not a url")  # Error object, not exception

SafeUrl.is_safe_redirect(
    "https://evil.com",
    allowed=["example.com"]
)  # False
----

=== SafeEmail — Validation That Actually Works

[cols="1,2,2"]
|===
| Function | What It Does | What It Prevents

| `is_valid(s)`
| RFC 5321 compliant check
| Bad regex accepting invalid emails

| `parse(s)`
| Extract local/domain parts
| Injection via email fields

| `normalize(s)`
| Lowercase, trim, normalise
| Case sensitivity bugs
|===

[source,python]
----
from proven import SafeEmail

SafeEmail.is_valid("user@example.com")  # True
SafeEmail.is_valid("not an email")      # False
SafeEmail.is_valid("user@localhost")    # True (valid per RFC)

email = SafeEmail.parse("User@Example.COM")
email.local   # "User"
email.domain  # "example.com" (normalised)
----

=== SafePath — Filesystem Access That Can't Escape

[cols="1,2,2"]
|===
| Function | What It Does | What It Prevents

| `join_safe(base, user_path)`
| Safe path joining
| Path traversal attacks

| `is_within(path, base)`
| Check containment
| Directory escape

| `sanitize(filename)`
| Remove dangerous chars
| Null byte injection, special chars
|===

[source,python]
----
from proven import SafePath

SafePath.join_safe("/var/uploads", "file.txt")
# "/var/uploads/file.txt"

SafePath.join_safe("/var/uploads", "../../../etc/passwd")
# Error: path traversal detected

SafePath.sanitize("file\x00.txt")  # "file.txt" (null byte removed)
----

=== SafeCrypto — Cryptography You Can't Mess Up

[cols="1,2,2"]
|===
| Function | What It Does | What It Prevents

| `hash_sha3(data)`
| SHA-3 hashing
| Using broken algorithms

| `hash_blake3(data)`
| BLAKE3 hashing
| Slow hashing

| `random_bytes(n)`
| Cryptographic randomness
| Using `random.random()` for security

| `constant_time_eq(a, b)`
| Timing-safe comparison
| Timing attacks
|===

[source,python]
----
from proven import SafeCrypto

# Cryptographic randomness (not random.random()!)
token = SafeCrypto.random_bytes(32)

# Secure hashing
digest = SafeCrypto.hash_sha3(b"data")
digest = SafeCrypto.hash_blake3(b"data")  # Faster

# Timing-safe comparison (prevents timing attacks)
SafeCrypto.constant_time_eq(user_token, stored_token)
----

=== SafePassword — Authentication Done Right

[cols="1,2,2"]
|===
| Function | What It Does | What It Prevents

| `hash(password)`
| Argon2id hashing
| MD5, SHA1, bcrypt weaknesses

| `verify(password, hash)`
| Timing-safe verification
| Timing attacks

| `is_strong(password)`
| Strength checking
| Weak passwords
|===

[source,python]
----
from proven import SafePassword

# Hash with Argon2id (current best practice)
hashed = SafePassword.hash("user_password")

# Verify (timing-safe)
if SafePassword.verify("user_password", hashed):
    print("Login successful")

# Strength check
SafePassword.is_strong("password123")  # False
SafePassword.is_strong("c0rr3ct-h0rs3-b4tt3ry-st4pl3")  # True
----

== Installation

=== Rust

[source,bash]
----
cargo add proven
----

=== Deno / JavaScript

**Deno (recommended):**
[source,typescript]
----
import { SafeMath, SafeJson } from "jsr:@proven/core";
----

**Node.js:**
[source,bash]
----
npx jsr add @proven/core
----

=== Python

**Using pipx (recommended for isolated environments):**
[source,bash]
----
pipx install proven
----

**Using pip:**
[source,bash]
----
pip install proven
----

TIP: `pipx` installs packages in isolated virtual environments, preventing dependency conflicts and improving security. Install it with `pip install pipx` if you don't have it.

=== Go

[source,bash]
----
go get github.com/hyperpolymath/proven
----

== How It Works (For the Curious)

[source]
----
┌─────────────────────────────────────────────────────────────────┐
│                     Your Python/Rust/JS App                     │
└──────────────────────────┬──────────────────────────────────────┘
                           │ import proven
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│              Language Bindings (auto-generated)                 │
│         Python: ctypes | Rust: bindgen | JS: WebAssembly       │
└──────────────────────────┬──────────────────────────────────────┘
                           │ C ABI
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Zig FFI Bridge Layer                         │
│     Cross-platform • Memory safe • Stable ABI guaranteed        │
│         (see: github.com/hyperpolymath/idris2-zig-ffi)         │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                 Idris 2 Verified Core                           │
│                                                                 │
│  • Dependent types: compiler PROVES code is correct             │
│  • Total functions: every input produces valid output           │
│  • No runtime exceptions: impossible by construction            │
│                                                                 │
│  Used by: aerospace, automotive, financial, blockchain          │
│  Inspiration: HACL* (Firefox, Linux kernel, WireGuard)         │
└─────────────────────────────────────────────────────────────────┘
----

== FAQ

**Q: Is this slow?**

No. Idris 2 compiles to C, then Zig optimises it. Benchmarks show performance within 5-15% of hand-written C for most operations. Crypto functions are often faster because they use constant-time implementations that avoid branch misprediction.

**Q: Do I need to learn Idris 2?**

Not required, but encouraged! The library bindings work like any standard library in your language. However, if you're interested in formal verification, understanding the Idris 2 source code will help you appreciate why the guarantees are so strong. See the "Want to Learn More?" section above for resources.

**Q: What if I find a bug?**

If you find a bug in proven, you've likely found a bug in either:
1. The language bindings (our bug, please report)
2. The Idris 2 compiler (extremely rare)
3. Your understanding of the function (check the docs)

The core logic is mathematically proven. But the bindings are written by humans.

**Q: Why not just use existing libraries?**

|===
| Library | Problem

| `json` (Python)
| Throws exceptions on invalid input

| `hashlib` (Python)
| Lets you use MD5, SHA1, and other broken algorithms

| `urllib` (Python)
| Complex API, easy to misuse, path traversal possible

| `bcrypt` (various)
| Truncates passwords at 72 bytes silently

| `random` (Python)
| Not cryptographically secure (people use it for tokens anyway)
|===

**Q: Is this production ready?**

Not yet. We're targeting 1.0 in Q4 2025. Star the repo to follow progress.

== Roadmap

=== Now (Q1 2025)
- [x] Repository setup
- [ ] SafeMath module (Idris 2)
- [ ] Zig FFI bridge
- [ ] Python bindings

=== Next (Q2 2025)
- [ ] SafeString, SafeJson, SafeUrl, SafeEmail, SafePath
- [ ] Rust, JavaScript, Deno bindings
- [ ] Test suite

=== Later (Q3-Q4 2025)
- [ ] SafeCrypto, SafePassword
- [ ] Post-quantum crypto (Dilithium, Kyber)
- [ ] Go, Gleam, OCaml bindings
- [ ] Package registry publishing
- [ ] Security audit
- [ ] 1.0 release

== Contributing

We welcome contributions! See link:CONTRIBUTING.adoc[CONTRIBUTING.adoc].

Especially needed:
- Language binding maintainers (Go, Java, C#, Swift)
- Security reviewers
- Documentation writers
- Test case contributors

== Related Projects

|===
| Project | What It Is

| https://github.com/hyperpolymath/idris2-zig-ffi[idris2-zig-ffi]
| The FFI bridge that makes this library callable

| https://github.com/hyperpolymath/ddraig-ssg[ddraig-ssg]
| Idris 2 static site generator (first consumer)

| https://hacl-star.github.io/[HACL*/EverCrypt]
| Verified crypto in Firefox, WireGuard, Linux (our inspiration)
|===

== License

Palimpsest-MPL-1.0. See link:LICENSE[LICENSE].

Commercial licensing available for proprietary use.

== Security

See link:SECURITY.md[SECURITY.md] for reporting vulnerabilities.

---

*Stop hoping your code won't crash. Know it won't.*
