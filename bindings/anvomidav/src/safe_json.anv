# SPDX-License-Identifier: PMPL-1.0-or-later
# Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

#= | SafeJson - JSON validation and type detection via libproven FFI.
 =
 = Anvomidav's result type makes JSON validation expressive: the return type
 = precisely captures whether JSON is valid and what root type the document
 = has. Parse failures are typed errors, not exceptions.
 =
 = All computation is performed in Idris 2 via the Zig FFI layer.
 = NO JSON logic is reimplemented in Anvomidav.
=#

module Proven.SafeJson

import Proven.FFI
import Proven (ProvenError, result, ok, err, bool_result_to_proven, float_result_to_proven)

# ============================================================================
# JSON types matching the C ABI enum
# ============================================================================

# | JSON value types as returned by the Idris 2 JSON parser.
define type JsonType =
  | JsonNull
  | JsonBool
  | JsonNumber
  | JsonString
  | JsonArray
  | JsonObject
  | JsonInvalid

# | Convert a raw C ABI type code to a JsonType.
proc int_to_json_type(code : Int32) -> JsonType =
  match code
  | 0  => JsonNull
  | 1  => JsonBool
  | 2  => JsonNumber
  | 3  => JsonString
  | 4  => JsonArray
  | 5  => JsonObject
  | _  => JsonInvalid
  end

# ============================================================================
# JSON validation
# ============================================================================

# | Check if a string is valid JSON.
# Returns ok(true) if valid, ok(false) if not.
# Delegates to proven_json_is_valid in libproven.
proc is_valid_json(input : String) -> result<Bool, ProvenError> =
  let bytes = string_to_utf8(input)
  bool_result_to_proven(
    FFI.proven_json_is_valid(bytes.ptr, bytes.len)
  )

# | Get the JSON value type at the root level.
# Returns JsonInvalid if the string is not valid JSON.
# Delegates to proven_json_get_type in libproven.
proc json_type(input : String) -> JsonType =
  let bytes = string_to_utf8(input)
  int_to_json_type(FFI.proven_json_get_type(bytes.ptr, bytes.len))

# | Validate JSON and return the type in one step.
# Returns err(ParseFailure) if the input is not valid JSON.
# Combines proven_json_is_valid and proven_json_get_type from libproven.
proc validate_json(input : String) -> result<JsonType, ProvenError> =
  match is_valid_json(input)
  | ok(true)  => ok(json_type(input))
  | ok(false) => err(ParseFailure)
  | err(e)    => err(e)
  end

# ============================================================================
# Safe expression evaluation
# ============================================================================

# | Safely evaluate an arithmetic expression string.
# Supports +, -, *, /, parentheses, negative and decimal numbers.
# Returns err(ParseFailure) for invalid expressions.
# Returns err(DivByZero) for division by zero.
# Delegates to proven_calculator_eval in libproven.
proc eval_expression(expr : String) -> result<Float64, ProvenError> =
  let bytes = string_to_utf8(expr)
  float_result_to_proven(
    FFI.proven_calculator_eval(bytes.ptr, bytes.len)
  )

# ============================================================================
# Anvomidav specific: validated JSON type
# ============================================================================

# | A validated JSON string type. Can only be constructed through the
# validate proc, ensuring the JSON has been parsed by the Idris 2
# verified JSON validator.
define type ValidatedJson = private {
  raw      : String,
  json_typ : JsonType,
}

# | Get the original JSON string.
proc validated_json_string(json : ValidatedJson) -> String =
  json.raw

# | Get the root type of the validated JSON.
proc validated_json_type(json : ValidatedJson) -> JsonType =
  json.json_typ

# | Create a ValidatedJson value, returning an error if validation fails.
proc make_validated_json(input : String) -> result<ValidatedJson, ProvenError> =
  match validate_json(input)
  | ok(t)  => ok(ValidatedJson { raw: input, json_typ: t })
  | err(e) => err(e)
  end
