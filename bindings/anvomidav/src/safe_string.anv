# SPDX-License-Identifier: PMPL-1.0-or-later
# Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

#= | SafeString - Text operations that handle encoding safely via libproven FFI.
 =
 = Anvomidav's result type ensures that encoding errors, null pointer errors,
 = and allocation failures are all captured in the return type and must
 = be handled by the caller.
 =
 = All computation is performed in Idris 2 via the Zig FFI layer.
 = NO string logic is reimplemented in Anvomidav.
=#

module Proven.SafeString

import Proven.FFI
import Proven (ProvenError, result, bool_result_to_proven, string_result_to_proven)

# ============================================================================
# UTF-8 validation
# ============================================================================

# | Check if bytes are valid UTF-8 encoding.
# Returns result<Bool, ProvenError> where ok(true) means valid UTF-8.
# Delegates to proven_string_is_valid_utf8 in libproven.
proc is_valid_utf8(input : Bytes) -> result<Bool, ProvenError> =
  bool_result_to_proven(
    FFI.proven_string_is_valid_utf8(input.ptr, input.len)
  )

# ============================================================================
# String escaping for injection prevention
# ============================================================================

# | Escape a string for safe SQL interpolation (single quotes).
# Returns the escaped string or an error if allocation fails.
# NOTE: Prefer parameterized queries over string escaping.
# Delegates to proven_string_escape_sql in libproven.
proc escape_sql(input : String) -> result<String, ProvenError> =
  let bytes = string_to_utf8(input)
  string_result_to_proven(
    FFI.proven_string_escape_sql(bytes.ptr, bytes.len)
  )

# | Escape a string for safe HTML output (prevents XSS).
# Escapes &, <, >, ", and ' characters.
# Delegates to proven_string_escape_html in libproven.
proc escape_html(input : String) -> result<String, ProvenError> =
  let bytes = string_to_utf8(input)
  string_result_to_proven(
    FFI.proven_string_escape_html(bytes.ptr, bytes.len)
  )

# | Escape a string for safe JavaScript string literals.
# Prevents injection when embedding data in JS contexts.
# Delegates to proven_string_escape_js in libproven.
proc escape_js(input : String) -> result<String, ProvenError> =
  let bytes = string_to_utf8(input)
  string_result_to_proven(
    FFI.proven_string_escape_js(bytes.ptr, bytes.len)
  )

# ============================================================================
# Path safety
# ============================================================================

# | Check if a path contains directory traversal sequences ("..").
# Returns ok(true) if traversal detected, ok(false) if safe.
# Delegates to proven_path_has_traversal in libproven.
proc path_has_traversal(path : String) -> result<Bool, ProvenError> =
  let bytes = string_to_utf8(path)
  bool_result_to_proven(
    FFI.proven_path_has_traversal(bytes.ptr, bytes.len)
  )

# | Sanitize a filename by removing dangerous characters.
# Returns the sanitized filename.
# Delegates to proven_path_sanitize_filename in libproven.
proc sanitize_filename(name : String) -> result<String, ProvenError> =
  let bytes = string_to_utf8(name)
  string_result_to_proven(
    FFI.proven_path_sanitize_filename(bytes.ptr, bytes.len)
  )
