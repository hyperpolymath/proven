# SPDX-License-Identifier: PMPL-1.0-or-later
# Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

#= | Proven - FFI bindings to libproven (Idris 2 verified safety library)
 = for Anvomidav.
 =
 = Anvomidav is a language from the nextgen-languages project. This module
 = provides the core error types and result wrappers that all Proven
 = modules build upon, using Anvomidav's maybe<T> and result<T, E> types.
 =
 = All computation is performed in Idris 2 via the Zig FFI layer.
 = NO safety logic is reimplemented in Anvomidav.
 =
 = Architecture:
 =   Anvomidav (.anv)
 =     |  @link("C", ...)
 =     v
 =   libproven.so (Zig FFI layer)
 =     |  Zig -> Idris2 RefC calls
 =     v
 =   Idris 2 (dependent types, totality checking)
=#

module Proven

import Proven.FFI
import Proven.SafeMath
import Proven.SafeString
import Proven.SafeEmail
import Proven.SafeUrl
import Proven.SafeCrypto
import Proven.SafeJson

# ============================================================================
# Core error type for Proven operations
# ============================================================================

#= | ProvenError enumerates all possible failure modes from the libproven C ABI.
 = Each variant carries the semantic meaning of the failure, enabling exhaustive
 = pattern matching in error handlers.
=#
define type ProvenError =
  | Overflow            # Arithmetic overflow (status -3)
  | Underflow           # Arithmetic underflow (status -4)
  | DivByZero           # Division by zero (status -5)
  | NullPointer         # Null pointer passed (status -1)
  | InvalidArgument     # Invalid argument (status -2)
  | ParseFailure        # Parse failure (status -6)
  | ValidationFailed    # Validation failed (status -7)
  | OutOfBounds         # Index out of bounds (status -8)
  | EncodingError       # Encoding error (status -9)
  | AllocationFailed    # Memory allocation failed (status -10)
  | NotImplemented      # Feature not implemented (status -99)
  | UnknownError(Int32) # Unrecognized status code

# | Convert a raw C ABI status code to a ProvenError.
# This proc is total: every possible Int32 maps to exactly one error.
proc status_to_error(code : Int32) -> ProvenError =
  match code
  | -1  => NullPointer
  | -2  => InvalidArgument
  | -3  => Overflow
  | -4  => Underflow
  | -5  => DivByZero
  | -6  => ParseFailure
  | -7  => ValidationFailed
  | -8  => OutOfBounds
  | -9  => EncodingError
  | -10 => AllocationFailed
  | -99 => NotImplemented
  | n   => UnknownError(n)
  end

# ============================================================================
# result<T, E> type
# ============================================================================

# | The core result type for all Proven operations.
# result<T, ProvenError> is the canonical return type.
define type result<T, E> =
  | ok(T)
  | err(E)

# | Convert an FFI IntResult into a result<Int64, ProvenError>.
proc int_result_to_proven(ir : FFI.IntResult) -> result<Int64, ProvenError> =
  match ir.status
  | 0 => ok(ir.value)
  | s => err(status_to_error(s))
  end

# | Convert an FFI BoolResult into a result<Bool, ProvenError>.
proc bool_result_to_proven(br : FFI.BoolResult) -> result<Bool, ProvenError> =
  match br.status
  | 0 => ok(br.value != 0)
  | s => err(status_to_error(s))
  end

# | Convert an FFI FloatResult into a result<Float64, ProvenError>.
proc float_result_to_proven(fr : FFI.FloatResult) -> result<Float64, ProvenError> =
  match fr.status
  | 0 => ok(fr.value)
  | s => err(status_to_error(s))
  end

# | Convert an FFI StringResult into a result<String, ProvenError>,
# freeing the C-allocated string after copying.
proc string_result_to_proven(sr : FFI.StringResult) -> result<String, ProvenError> =
  match sr.status
  | 0 =>
    let copied = string_from_ptr(sr.ptr, sr.len)
    FFI.proven_free_string(sr.ptr)
    ok(copied)
  | s => err(status_to_error(s))
  end

# ============================================================================
# Lifecycle management
# ============================================================================

# | Initialize the Proven runtime. Must be called before any other function.
# Returns ok(()) on success.
proc init() -> result<Unit, ProvenError> =
  let status = FFI.proven_init()
  match status
  | 0 => ok(())
  | s => err(status_to_error(s))
  end

# | Deinitialize the Proven runtime. Call when done.
proc deinit() -> Unit =
  FFI.proven_deinit()

# | Check if the Proven runtime is initialized.
proc is_initialized() -> Bool =
  FFI.proven_is_initialized()

# | Get the library version as a tuple (major, minor, patch).
proc version() -> (UInt32, UInt32, UInt32) =
  (FFI.proven_version_major(), FFI.proven_version_minor(), FFI.proven_version_patch())

# | Get the FFI ABI version for compatibility checking.
proc abi_version() -> UInt32 =
  FFI.proven_ffi_abi_version()

# | Get the total module count in libproven.
proc module_count() -> UInt32 =
  FFI.proven_module_count()

# ============================================================================
# Re-exports
# ============================================================================

export Proven.SafeMath.*
export Proven.SafeString.*
export Proven.SafeEmail.*
export Proven.SafeUrl.*
export Proven.SafeCrypto.*
export Proven.SafeJson.*
