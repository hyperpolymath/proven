// SPDX-License-Identifier: PMPL-1.0
// SPDX-FileCopyrightText: 2025 Hyperpolymath
//
// Proven Safety Primitives for CEL (Common Expression Language)
// Version: 0.4.0
// Module Count: 38
//
// CEL is used in Kubernetes admission control, Firebase security rules,
// Google Cloud IAM policies, and Envoy proxy configurations.
// These are CEL extension functions and macros for safe validation.

// ============================================================================
// LIBRARY METADATA
// ============================================================================

// proven.version = "0.4.0"
// proven.module_count = 38
// proven.categories = [
//   "Core (11)",
//   "Data (7)",
//   "Data Structures (5)",
//   "Resilience (4)",
//   "State (2)",
//   "Algorithm (4)",
//   "Security (2)",
//   "HTTP (3)"
// ]

// ============================================================================
// CORE MODULES (11)
// ============================================================================

// ----------------------------------------------------------------------------
// safe_math - Safe mathematical operations with overflow detection
// ----------------------------------------------------------------------------

// Safe addition that detects overflow
// Usage: proven.safeAdd(a, b)
// CEL: (a >= 0 && b <= 9223372036854775807 - a) || (a < 0 && b >= -9223372036854775808 - a)

// Safe subtraction that detects underflow
// Usage: proven.safeSub(a, b)
// CEL: (b >= 0 && a >= -9223372036854775808 + b) || (b < 0 && a <= 9223372036854775807 + b)

// Safe multiplication with overflow detection
// Usage: proven.safeMul(a, b)
// CEL: b == 0 || (a <= 9223372036854775807 / b && a >= -9223372036854775808 / b)

// Safe division with zero check
// Usage: proven.safeDiv(a, b)
// CEL: b != 0 && !(a == -9223372036854775808 && b == -1)

// Check if value is in range (inclusive)
// Usage: proven.inRange(value, min, max)
// CEL: value >= min && value <= max

// Clamp value to range
// Usage: proven.clamp(value, min, max)
// CEL: value < min ? min : (value > max ? max : value)

// Check if positive
// Usage: proven.isPositive(value)
// CEL: value > 0

// Check if non-negative
// Usage: proven.isNonNegative(value)
// CEL: value >= 0

// ----------------------------------------------------------------------------
// safe_string - Safe string operations with injection prevention
// ----------------------------------------------------------------------------

// Non-empty string check
// Usage: proven.isNonEmpty(s)
// CEL: size(s) > 0

// Max length check
// Usage: proven.maxLength(s, max)
// CEL: size(s) <= max

// Min length check
// Usage: proven.minLength(s, min)
// CEL: size(s) >= min

// Length in range
// Usage: proven.lengthInRange(s, min, max)
// CEL: size(s) >= min && size(s) <= max

// Check for HTML injection patterns
// Usage: proven.hasHtmlInjection(s)
// CEL: s.matches('(?i)(<script|javascript:|onerror=|onclick=|onload=)')

// Check for SQL injection patterns
// Usage: proven.hasSqlInjection(s)
// CEL: s.matches("(?i)(SELECT\\s|INSERT\\s|UPDATE\\s|DELETE\\s|DROP\\s|UNION\\s|--|/\\*)")

// Check for potential injection (HTML or SQL)
// Usage: proven.detectInjection(s)
// CEL: s.matches('(?i)(<script|javascript:|SELECT\\s|DROP\\s|--|/\\*)')

// Safe identifier check (alphanumeric + underscore)
// Usage: proven.isSafeIdentifier(s)
// CEL: s.matches('^[a-zA-Z_][a-zA-Z0-9_]*$')

// ----------------------------------------------------------------------------
// safe_path - Safe path operations with traversal prevention
// ----------------------------------------------------------------------------

// Check for path traversal sequences
// Usage: proven.hasPathTraversal(path)
// CEL: path.matches('\\.\\./|\\.\\.\\\\')

// Check if path is relative (no leading slash)
// Usage: proven.isRelativePath(path)
// CEL: !path.startsWith('/') && !path.matches('^[A-Za-z]:')

// Check if path is absolute
// Usage: proven.isAbsolutePath(path)
// CEL: path.startsWith('/') || path.matches('^[A-Za-z]:')

// Safe filename check (no special characters)
// Usage: proven.isSafeFilename(name)
// CEL: name.matches('^[a-zA-Z0-9._-]+$') && !name.matches('^\\.') && size(name) <= 255

// Get file extension (last segment after dot)
// Usage: proven.hasExtension(path, ext)
// CEL: path.endsWith('.' + ext)

// ----------------------------------------------------------------------------
// safe_email - Safe email validation
// ----------------------------------------------------------------------------

// Basic email validation (RFC 5321)
// Usage: proven.isEmail(email)
// CEL: email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')

// Email local part length check (max 64)
// Usage: proven.isValidEmailLocalPart(email)
// CEL: size(email.split('@')[0]) <= 64

// Email domain length check (max 255)
// Usage: proven.isValidEmailDomain(email)
// CEL: email.contains('@') && size(email.split('@')[1]) <= 255

// Check for common disposable email domains
// Usage: proven.isDisposableEmail(email)
// CEL: email.matches('(?i)@(tempmail|throwaway|guerrillamail|mailinator)\\..*$')

// ----------------------------------------------------------------------------
// safe_url - Safe URL parsing and validation
// ----------------------------------------------------------------------------

// Basic URL validation
// Usage: proven.isUrl(url)
// CEL: url.matches('^https?://[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9](:[0-9]+)?(/.*)?$')

// Check for HTTPS only
// Usage: proven.isHttpsUrl(url)
// CEL: url.startsWith('https://')

// Check for HTTP (not HTTPS)
// Usage: proven.isHttpUrl(url)
// CEL: url.startsWith('http://') && !url.startsWith('https://')

// Check for localhost/loopback URLs
// Usage: proven.isLocalUrl(url)
// CEL: url.matches('(?i)^https?://(localhost|127\\.0\\.0\\.1|\\[::1\\])(:[0-9]+)?(/.*)?$')

// Check for private network URLs
// Usage: proven.isPrivateNetworkUrl(url)
// CEL: url.matches('(?i)^https?://(10\\.|172\\.(1[6-9]|2[0-9]|3[01])\\.|192\\.168\\.)')

// ----------------------------------------------------------------------------
// safe_network - Safe network address operations
// ----------------------------------------------------------------------------

// IPv4 address validation
// Usage: proven.isIPv4(ip)
// CEL: ip.matches('^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$')

// IPv6 address validation (simplified)
// Usage: proven.isIPv6(ip)
// CEL: ip.matches('^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$') || ip.matches('^([0-9a-fA-F]{1,4}:)*::([0-9a-fA-F]{1,4}:)*[0-9a-fA-F]{1,4}$')

// Valid port number (1-65535)
// Usage: proven.isValidPort(port)
// CEL: port >= 1 && port <= 65535

// Well-known port (0-1023)
// Usage: proven.isWellKnownPort(port)
// CEL: port >= 0 && port <= 1023

// Registered port (1024-49151)
// Usage: proven.isRegisteredPort(port)
// CEL: port >= 1024 && port <= 49151

// Dynamic/ephemeral port (49152-65535)
// Usage: proven.isDynamicPort(port)
// CEL: port >= 49152 && port <= 65535

// Check for loopback IPv4
// Usage: proven.isLoopbackIPv4(ip)
// CEL: ip.startsWith('127.')

// Check for private IPv4
// Usage: proven.isPrivateIPv4(ip)
// CEL: ip.startsWith('10.') || ip.matches('^172\\.(1[6-9]|2[0-9]|3[01])\\.') || ip.startsWith('192.168.')

// CIDR notation validation
// Usage: proven.isValidCIDR(cidr)
// CEL: cidr.matches('^[0-9a-fA-F.:]+/[0-9]{1,3}$')

// ----------------------------------------------------------------------------
// safe_crypto - Safe cryptographic operations
// ----------------------------------------------------------------------------

// Check if string is valid hex (for hashes)
// Usage: proven.isHexString(s)
// CEL: s.matches('^[0-9a-fA-F]*$') && size(s) % 2 == 0

// SHA-256 hash length (64 hex chars)
// Usage: proven.isSHA256Hash(s)
// CEL: size(s) == 64 && s.matches('^[0-9a-fA-F]+$')

// SHA-512 hash length (128 hex chars)
// Usage: proven.isSHA512Hash(s)
// CEL: size(s) == 128 && s.matches('^[0-9a-fA-F]+$')

// BLAKE3 hash length (64 hex chars)
// Usage: proven.isBLAKE3Hash(s)
// CEL: size(s) == 64 && s.matches('^[0-9a-fA-F]+$')

// MD5 hash length (32 hex chars) - for checksums only, not security
// Usage: proven.isMD5Hash(s)
// CEL: size(s) == 32 && s.matches('^[0-9a-fA-F]+$')

// Base64 validation
// Usage: proven.isBase64(s)
// CEL: s.matches('^[A-Za-z0-9+/]*={0,2}$') && size(s) % 4 == 0

// ----------------------------------------------------------------------------
// safe_uuid - Safe UUID generation and validation
// ----------------------------------------------------------------------------

// UUID v4 format validation
// Usage: proven.isUUID(s)
// CEL: s.matches('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')

// UUID v4 version check
// Usage: proven.isUUIDv4(s)
// CEL: s.matches('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$')

// Nil UUID check
// Usage: proven.isNilUUID(s)
// CEL: s == '00000000-0000-0000-0000-000000000000'

// UUID URN format
// Usage: proven.isUUIDUrn(s)
// CEL: s.startsWith('urn:uuid:') && s.substring(9).matches('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')

// ----------------------------------------------------------------------------
// safe_currency - Safe currency operations
// ----------------------------------------------------------------------------

// ISO 4217 currency code validation (3 uppercase letters)
// Usage: proven.isCurrencyCode(code)
// CEL: code.matches('^[A-Z]{3}$')

// Common currency codes
// Usage: proven.isCommonCurrency(code)
// CEL: code in ['USD', 'EUR', 'GBP', 'JPY', 'CHF', 'CAD', 'AUD', 'NZD', 'CNY', 'INR', 'BRL', 'MXN']

// Cryptocurrency codes
// Usage: proven.isCryptoCurrency(code)
// CEL: code in ['BTC', 'ETH', 'LTC', 'XRP', 'USDT', 'USDC', 'DAI', 'SOL', 'ADA']

// Positive amount check
// Usage: proven.isPositiveAmount(amount)
// CEL: amount > 0

// Non-negative amount check
// Usage: proven.isNonNegativeAmount(amount)
// CEL: amount >= 0

// ----------------------------------------------------------------------------
// safe_phone - Safe phone number validation (E.164)
// ----------------------------------------------------------------------------

// E.164 phone number format
// Usage: proven.isE164Phone(phone)
// CEL: phone.matches('^\\+[1-9][0-9]{6,14}$')

// Phone with country code (loose)
// Usage: proven.hasCountryCode(phone)
// CEL: phone.startsWith('+')

// North American phone (NANP)
// Usage: proven.isNANPPhone(phone)
// CEL: phone.matches('^\\+1[2-9][0-9]{9}$')

// Valid phone digit count (7-15)
// Usage: proven.isValidPhoneLength(phone)
// CEL: size(phone.replaceAll('[^0-9]', '')) >= 7 && size(phone.replaceAll('[^0-9]', '')) <= 15

// ----------------------------------------------------------------------------
// safe_hex - Safe hexadecimal encoding and decoding
// ----------------------------------------------------------------------------

// Valid hex string
// Usage: proven.isHex(s)
// CEL: s.matches('^[0-9a-fA-F]*$')

// Valid hex bytes (even length)
// Usage: proven.isHexBytes(s)
// CEL: s.matches('^[0-9a-fA-F]*$') && size(s) % 2 == 0

// Lowercase hex
// Usage: proven.isLowerHex(s)
// CEL: s.matches('^[0-9a-f]*$')

// Uppercase hex
// Usage: proven.isUpperHex(s)
// CEL: s.matches('^[0-9A-F]*$')

// Hex with 0x prefix
// Usage: proven.isHexPrefixed(s)
// CEL: s.startsWith('0x') && s.substring(2).matches('^[0-9a-fA-F]*$')

// ============================================================================
// DATA MODULES (7)
// ============================================================================

// ----------------------------------------------------------------------------
// safe_json - Safe JSON parsing and validation
// ----------------------------------------------------------------------------

// Check if string looks like JSON object
// Usage: proven.looksLikeJsonObject(s)
// CEL: s.startsWith('{') && s.endsWith('}')

// Check if string looks like JSON array
// Usage: proven.looksLikeJsonArray(s)
// CEL: s.startsWith('[') && s.endsWith(']')

// Check if string looks like valid JSON
// Usage: proven.looksLikeJson(s)
// CEL: (s.startsWith('{') && s.endsWith('}')) || (s.startsWith('[') && s.endsWith(']'))

// JSON string max size
// Usage: proven.isJsonSizeValid(s, maxBytes)
// CEL: size(s) <= maxBytes

// ----------------------------------------------------------------------------
// safe_datetime - Safe datetime parsing and validation
// ----------------------------------------------------------------------------

// ISO 8601 date format (YYYY-MM-DD)
// Usage: proven.isISODate(s)
// CEL: s.matches('^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$')

// ISO 8601 datetime format
// Usage: proven.isISODateTime(s)
// CEL: s.matches('^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]')

// RFC 3339 format (with timezone)
// Usage: proven.isRFC3339(s)
// CEL: s.matches('^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?(Z|[+-][0-9]{2}:[0-9]{2})$')

// Valid month (1-12)
// Usage: proven.isValidMonth(month)
// CEL: month >= 1 && month <= 12

// Valid day (1-31)
// Usage: proven.isValidDay(day)
// CEL: day >= 1 && day <= 31

// Valid hour (0-23)
// Usage: proven.isValidHour(hour)
// CEL: hour >= 0 && hour <= 23

// Valid minute/second (0-59)
// Usage: proven.isValidMinuteSecond(value)
// CEL: value >= 0 && value <= 59

// Leap year check
// Usage: proven.isLeapYear(year)
// CEL: (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)

// ----------------------------------------------------------------------------
// safe_float - Safe floating-point operations
// ----------------------------------------------------------------------------

// Check if value is finite (not NaN or Infinity)
// Usage: proven.isFinite(value)
// Note: CEL numbers are finite by default, this is for validation context

// Safe division check (non-zero divisor)
// Usage: proven.canDivide(divisor)
// CEL: divisor != 0.0

// Value in range (for floats)
// Usage: proven.floatInRange(value, min, max)
// CEL: value >= min && value <= max

// Percentage range (0-100)
// Usage: proven.isPercentage(value)
// CEL: value >= 0.0 && value <= 100.0

// Normalized value (0-1)
// Usage: proven.isNormalized(value)
// CEL: value >= 0.0 && value <= 1.0

// Probability value (0-1)
// Usage: proven.isProbability(value)
// CEL: value >= 0.0 && value <= 1.0

// ----------------------------------------------------------------------------
// safe_version - Safe semantic versioning
// ----------------------------------------------------------------------------

// SemVer format (X.Y.Z)
// Usage: proven.isSemVer(version)
// CEL: version.matches('^(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)(-[a-zA-Z0-9.-]+)?(\\+[a-zA-Z0-9.-]+)?$')

// Major version >= 1 (stable)
// Usage: proven.isStableVersion(version)
// CEL: !version.startsWith('0.')

// Prerelease version check
// Usage: proven.isPrerelease(version)
// CEL: version.contains('-')

// Has build metadata
// Usage: proven.hasBuildMetadata(version)
// CEL: version.contains('+')

// ----------------------------------------------------------------------------
// safe_color - Safe color handling
// ----------------------------------------------------------------------------

// Hex color format (#RRGGBB)
// Usage: proven.isHexColor(color)
// CEL: color.matches('^#[0-9a-fA-F]{6}$')

// Short hex color (#RGB)
// Usage: proven.isShortHexColor(color)
// CEL: color.matches('^#[0-9a-fA-F]{3}$')

// Hex color with alpha (#RRGGBBAA)
// Usage: proven.isHexColorAlpha(color)
// CEL: color.matches('^#[0-9a-fA-F]{8}$')

// RGB value in range
// Usage: proven.isValidRGBValue(value)
// CEL: value >= 0 && value <= 255

// Alpha value in range (0-1)
// Usage: proven.isValidAlpha(alpha)
// CEL: alpha >= 0.0 && alpha <= 1.0

// ----------------------------------------------------------------------------
// safe_angle - Safe angle operations
// ----------------------------------------------------------------------------

// Degrees in range [0, 360)
// Usage: proven.isNormalizedDegrees(deg)
// CEL: deg >= 0.0 && deg < 360.0

// Degrees in range [-180, 180)
// Usage: proven.isSignedDegrees(deg)
// CEL: deg >= -180.0 && deg < 180.0

// Radians in range [0, 2*PI)
// Usage: proven.isNormalizedRadians(rad)
// CEL: rad >= 0.0 && rad < 6.283185307179586

// Valid latitude (-90 to 90)
// Usage: proven.isLatitude(lat)
// CEL: lat >= -90.0 && lat <= 90.0

// Valid longitude (-180 to 180)
// Usage: proven.isLongitude(lon)
// CEL: lon >= -180.0 && lon <= 180.0

// ----------------------------------------------------------------------------
// safe_unit - Safe physical unit conversions
// ----------------------------------------------------------------------------

// Positive measurement
// Usage: proven.isPositiveMeasurement(value)
// CEL: value > 0.0

// Non-negative measurement
// Usage: proven.isNonNegativeMeasurement(value)
// CEL: value >= 0.0

// Temperature above absolute zero (Kelvin)
// Usage: proven.isValidKelvin(temp)
// CEL: temp >= 0.0

// Temperature above absolute zero (Celsius)
// Usage: proven.isValidCelsius(temp)
// CEL: temp >= -273.15

// Temperature above absolute zero (Fahrenheit)
// Usage: proven.isValidFahrenheit(temp)
// CEL: temp >= -459.67

// ============================================================================
// DATA STRUCTURES MODULES (5)
// ============================================================================

// ----------------------------------------------------------------------------
// safe_buffer - Safe buffer operations with bounds checking
// ----------------------------------------------------------------------------

// Index within bounds
// Usage: proven.isValidIndex(index, length)
// CEL: index >= 0 && index < length

// Range within bounds
// Usage: proven.isValidRange(start, end, length)
// CEL: start >= 0 && end >= start && end <= length

// Capacity check
// Usage: proven.hasCapacity(current, max, toAdd)
// CEL: current + toAdd <= max

// Buffer not empty
// Usage: proven.isNotEmpty(length)
// CEL: length > 0

// Buffer not full
// Usage: proven.isNotFull(current, capacity)
// CEL: current < capacity

// ----------------------------------------------------------------------------
// safe_queue - Safe queue operations
// ----------------------------------------------------------------------------

// Queue can enqueue
// Usage: proven.canEnqueue(current, capacity)
// CEL: current < capacity

// Queue can dequeue
// Usage: proven.canDequeue(length)
// CEL: length > 0

// ----------------------------------------------------------------------------
// safe_bloom - Safe Bloom filter operations
// ----------------------------------------------------------------------------

// Bloom filter size recommendation
// Usage: proven.bloomFilterSize(n, p) - returns approximate size
// Note: Implementation requires numeric calculation

// False positive rate in valid range
// Usage: proven.isValidFalsePositiveRate(p)
// CEL: p > 0.0 && p < 1.0

// ----------------------------------------------------------------------------
// safe_lru - Safe LRU cache operations
// ----------------------------------------------------------------------------

// LRU capacity valid
// Usage: proven.isValidLRUCapacity(capacity)
// CEL: capacity > 0

// LRU can accept new entry
// Usage: proven.lruCanAccept(current, capacity)
// CEL: current < capacity

// ----------------------------------------------------------------------------
// safe_graph - Safe graph operations
// ----------------------------------------------------------------------------

// Valid vertex count
// Usage: proven.isValidVertexCount(count)
// CEL: count >= 0

// Valid edge count (for simple graph)
// Usage: proven.isValidEdgeCount(vertices, edges)
// CEL: edges <= (vertices * (vertices - 1)) / 2

// Valid directed edge count
// Usage: proven.isValidDirectedEdgeCount(vertices, edges)
// CEL: edges <= vertices * (vertices - 1)

// ============================================================================
// RESILIENCE MODULES (4)
// ============================================================================

// ----------------------------------------------------------------------------
// safe_rate_limiter - Safe rate limiting algorithms
// ----------------------------------------------------------------------------

// Token bucket: check if tokens available
// Usage: proven.hasTokens(current, required)
// CEL: current >= required

// Rate limit: requests within limit
// Usage: proven.withinRateLimit(current, max)
// CEL: current < max

// Sliding window: time in window
// Usage: proven.inTimeWindow(timestamp, windowStart, windowSize)
// CEL: timestamp >= windowStart && timestamp < windowStart + windowSize

// ----------------------------------------------------------------------------
// safe_circuit_breaker - Safe circuit breaker pattern
// ----------------------------------------------------------------------------

// Circuit breaker: is closed (healthy)
// Usage: proven.circuitIsClosed(state)
// CEL: state == 'closed'

// Circuit breaker: is open (failing)
// Usage: proven.circuitIsOpen(state)
// CEL: state == 'open'

// Circuit breaker: is half-open (testing)
// Usage: proven.circuitIsHalfOpen(state)
// CEL: state == 'half_open'

// Failure threshold reached
// Usage: proven.failureThresholdReached(failures, threshold)
// CEL: failures >= threshold

// Success threshold reached (for recovery)
// Usage: proven.successThresholdReached(successes, threshold)
// CEL: successes >= threshold

// ----------------------------------------------------------------------------
// safe_retry - Safe retry logic
// ----------------------------------------------------------------------------

// Can retry
// Usage: proven.canRetry(attempts, maxAttempts)
// CEL: attempts < maxAttempts

// Should retry based on error type
// Usage: proven.isRetryableError(errorCode)
// CEL: errorCode in [408, 429, 500, 502, 503, 504]

// Backoff delay calculation
// Usage: proven.exponentialBackoff(attempt, baseMs, maxMs)
// Note: min(baseMs * (2 ** attempt), maxMs)

// Jitter in valid range
// Usage: proven.isValidJitter(jitter)
// CEL: jitter >= 0.0 && jitter <= 1.0

// ----------------------------------------------------------------------------
// safe_monotonic - Safe monotonic counter operations
// ----------------------------------------------------------------------------

// Counter is monotonically increasing
// Usage: proven.isMonotonicallyIncreasing(prev, current)
// CEL: current >= prev

// Strictly increasing
// Usage: proven.isStrictlyIncreasing(prev, current)
// CEL: current > prev

// Sequence gap detection
// Usage: proven.hasSequenceGap(prev, current, step)
// CEL: current - prev != step

// ============================================================================
// STATE MODULES (2)
// ============================================================================

// ----------------------------------------------------------------------------
// safe_state_machine - Safe state machine transitions
// ----------------------------------------------------------------------------

// State transition validation pattern
// Usage: Define allowed transitions as a map and check
// CEL: transitions[currentState].exists(s, s == targetState)

// State is terminal
// Usage: proven.isTerminalState(state, terminalStates)
// CEL: state in terminalStates

// State is initial
// Usage: proven.isInitialState(state, initialState)
// CEL: state == initialState

// Valid state
// Usage: proven.isValidState(state, validStates)
// CEL: state in validStates

// ----------------------------------------------------------------------------
// safe_calculator - Safe calculator operations
// ----------------------------------------------------------------------------

// All safe_math operations apply, plus:

// Factorial safe check (prevent overflow)
// Usage: proven.canComputeFactorial(n)
// CEL: n >= 0 && n <= 20

// Fibonacci safe check
// Usage: proven.canComputeFibonacci(n)
// CEL: n >= 0 && n <= 92

// Power operation safe check
// Usage: proven.canComputePower(base, exp)
// CEL: exp >= 0 && (base != 0 || exp != 0)

// ============================================================================
// ALGORITHM MODULES (4)
// ============================================================================

// ----------------------------------------------------------------------------
// safe_geo - Safe geographic coordinate operations
// ----------------------------------------------------------------------------

// Valid coordinate
// Usage: proven.isValidCoordinate(lat, lon)
// CEL: lat >= -90.0 && lat <= 90.0 && lon >= -180.0 && lon <= 180.0

// Northern hemisphere
// Usage: proven.isNorthernHemisphere(lat)
// CEL: lat >= 0.0

// Southern hemisphere
// Usage: proven.isSouthernHemisphere(lat)
// CEL: lat < 0.0

// Eastern hemisphere
// Usage: proven.isEasternHemisphere(lon)
// CEL: lon >= 0.0

// Western hemisphere
// Usage: proven.isWesternHemisphere(lon)
// CEL: lon < 0.0

// Coordinate within bounding box
// Usage: proven.inBoundingBox(lat, lon, minLat, minLon, maxLat, maxLon)
// CEL: lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon

// ----------------------------------------------------------------------------
// safe_probability - Safe probability operations
// ----------------------------------------------------------------------------

// Valid probability (0-1)
// Usage: proven.isValidProbability(p)
// CEL: p >= 0.0 && p <= 1.0

// Probabilities sum to 1 (within epsilon)
// Usage: proven.probabilitiesSumToOne(sum, epsilon)
// CEL: sum >= (1.0 - epsilon) && sum <= (1.0 + epsilon)

// Odds in valid range
// Usage: proven.isValidOdds(odds)
// CEL: odds > 0.0

// Log probability in valid range
// Usage: proven.isValidLogProbability(logP)
// CEL: logP <= 0.0

// ----------------------------------------------------------------------------
// safe_checksum - Safe checksum operations
// ----------------------------------------------------------------------------

// Luhn checksum digit valid (0-9)
// Usage: proven.isValidLuhnDigit(digit)
// CEL: digit >= 0 && digit <= 9

// CRC-32 in valid range
// Usage: proven.isValidCRC32(crc)
// CEL: crc >= 0 && crc <= 4294967295

// Checksum string length valid
// Usage: proven.isValidChecksumLength(checksum, expectedLength)
// CEL: size(checksum) == expectedLength

// Credit card number length (13-19 digits)
// Usage: proven.isValidCreditCardLength(number)
// CEL: size(number) >= 13 && size(number) <= 19 && number.matches('^[0-9]+$')

// ----------------------------------------------------------------------------
// safe_tensor - Safe tensor operations
// ----------------------------------------------------------------------------

// Valid tensor dimensions
// Usage: proven.isValidTensorDimensions(dims)
// CEL: dims.all(d, d > 0)

// Tensor shapes compatible for matmul
// Usage: proven.canMatmul(m1Cols, m2Rows)
// CEL: m1Cols == m2Rows

// Tensor shapes compatible for element-wise ops
// Usage: proven.shapesMatch(shape1, shape2)
// CEL: size(shape1) == size(shape2)

// Valid axis for operation
// Usage: proven.isValidAxis(axis, numDims)
// CEL: axis >= 0 && axis < numDims

// ============================================================================
// SECURITY MODULES (2)
// ============================================================================

// ----------------------------------------------------------------------------
// safe_password - Safe password validation
// ----------------------------------------------------------------------------

// Minimum password length
// Usage: proven.meetsMinPasswordLength(password, minLength)
// CEL: size(password) >= minLength

// Password has uppercase
// Usage: proven.hasUppercase(password)
// CEL: password.matches('.*[A-Z].*')

// Password has lowercase
// Usage: proven.hasLowercase(password)
// CEL: password.matches('.*[a-z].*')

// Password has digit
// Usage: proven.hasDigit(password)
// CEL: password.matches('.*[0-9].*')

// Password has special character
// Usage: proven.hasSpecialChar(password)
// CEL: password.matches('.*[!@#$%^&*(),.?":{}|<>].*')

// Strong password (all requirements)
// Usage: proven.isStrongPassword(password, minLength)
// CEL: size(password) >= minLength && password.matches('.*[A-Z].*') && password.matches('.*[a-z].*') && password.matches('.*[0-9].*') && password.matches('.*[!@#$%^&*(),.?":{}|<>].*')

// Password entropy estimate (basic)
// Note: Actual entropy calculation requires more complex logic

// ----------------------------------------------------------------------------
// safe_ml - Safe machine learning operations
// ----------------------------------------------------------------------------

// Feature value in expected range
// Usage: proven.isValidFeatureValue(value, min, max)
// CEL: value >= min && value <= max

// Normalized feature (0-1)
// Usage: proven.isNormalizedFeature(value)
// CEL: value >= 0.0 && value <= 1.0

// Standardized feature (z-score typically -3 to 3)
// Usage: proven.isReasonableZScore(value)
// CEL: value >= -10.0 && value <= 10.0

// Valid learning rate
// Usage: proven.isValidLearningRate(lr)
// CEL: lr > 0.0 && lr < 1.0

// Valid batch size
// Usage: proven.isValidBatchSize(size)
// CEL: size > 0 && size <= 65536

// Valid epoch count
// Usage: proven.isValidEpochCount(epochs)
// CEL: epochs > 0 && epochs <= 10000

// Softmax output sum (should be ~1)
// Usage: proven.isValidSoftmaxSum(sum, epsilon)
// CEL: sum >= (1.0 - epsilon) && sum <= (1.0 + epsilon)

// ============================================================================
// HTTP MODULES (3)
// ============================================================================

// ----------------------------------------------------------------------------
// safe_header - Safe HTTP header operations
// ----------------------------------------------------------------------------

// Valid HTTP header name (RFC 7230 token)
// Usage: proven.isValidHeaderName(name)
// CEL: name.matches('^[!#$%&\'*+.^_`|~a-zA-Z0-9-]+$') && size(name) <= 256

// No CRLF injection
// Usage: proven.hasNoCRLF(value)
// CEL: !value.contains('\r') && !value.contains('\n')

// Header value not too long
// Usage: proven.isValidHeaderValueLength(value)
// CEL: size(value) <= 8192

// Not a dangerous header
// Usage: proven.isNotDangerousHeader(name)
// CEL: !(name.lower() in ['host', 'transfer-encoding', 'content-length', 'connection', 'keep-alive', 'upgrade', 'proxy-authorization', 'proxy-authenticate', 'proxy-connection', 'te', 'trailer'])

// Valid Content-Type
// Usage: proven.isValidContentType(ct)
// CEL: ct.matches('^[a-zA-Z0-9][a-zA-Z0-9!#$&^_.+-]*/[a-zA-Z0-9][a-zA-Z0-9!#$&^_.+-]*')

// ----------------------------------------------------------------------------
// safe_cookie - Safe HTTP cookie operations
// ----------------------------------------------------------------------------

// Valid cookie name
// Usage: proven.isValidCookieName(name)
// CEL: name.matches('^[a-zA-Z0-9!#$%&\'*+.^_`|~-]+$') && size(name) > 0

// Cookie value no special chars
// Usage: proven.isValidCookieValue(value)
// CEL: !value.contains(';') && !value.contains(',') && !value.contains(' ')

// Secure cookie attributes
// Usage: proven.hasSecureAttributes(secure, sameSite)
// CEL: secure == true && sameSite in ['Strict', 'Lax', 'None']

// Valid Max-Age
// Usage: proven.isValidMaxAge(maxAge)
// CEL: maxAge >= 0

// Cookie path valid
// Usage: proven.isValidCookiePath(path)
// CEL: path.startsWith('/') && !path.contains(';')

// ----------------------------------------------------------------------------
// safe_content_type - Safe Content-Type handling
// ----------------------------------------------------------------------------

// JSON content type
// Usage: proven.isJsonContentType(ct)
// CEL: ct.matches('(?i)^application/json') || ct.matches('(?i)^application/.*\\+json')

// XML content type
// Usage: proven.isXmlContentType(ct)
// CEL: ct.matches('(?i)^(application|text)/xml') || ct.matches('(?i)^application/.*\\+xml')

// HTML content type
// Usage: proven.isHtmlContentType(ct)
// CEL: ct.matches('(?i)^text/html')

// Plain text content type
// Usage: proven.isTextContentType(ct)
// CEL: ct.matches('(?i)^text/')

// Binary content type
// Usage: proven.isBinaryContentType(ct)
// CEL: ct.matches('(?i)^(application/octet-stream|image/|audio/|video/)')

// Form content type
// Usage: proven.isFormContentType(ct)
// CEL: ct.matches('(?i)^(application/x-www-form-urlencoded|multipart/form-data)')

// ============================================================================
// KUBERNETES ADMISSION POLICY EXAMPLES
// ============================================================================

/*
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingAdmissionPolicy
metadata:
  name: proven-comprehensive-security
spec:
  failurePolicy: Fail
  matchConstraints:
    resourceRules:
    - apiGroups:   [""]
      apiVersions: ["v1"]
      operations:  ["CREATE", "UPDATE"]
      resources:   ["pods"]
  validations:
    # Non-root requirement using proven pattern
    - expression: |
        object.spec.containers.all(c,
          has(c.securityContext) &&
          has(c.securityContext.runAsNonRoot) &&
          c.securityContext.runAsNonRoot == true
        )
      message: "All containers must run as non-root"

    # No privileged containers
    - expression: |
        object.spec.containers.all(c,
          !has(c.securityContext.privileged) ||
          c.securityContext.privileged == false
        )
      message: "Containers must not run in privileged mode"

    # Resource limits required (safe_math patterns)
    - expression: |
        object.spec.containers.all(c,
          has(c.resources) &&
          has(c.resources.limits) &&
          has(c.resources.limits.memory) &&
          has(c.resources.limits.cpu)
        )
      message: "All containers must have CPU and memory limits"

    # Valid port ranges (safe_network pattern)
    - expression: |
        !has(object.spec.containers) ||
        object.spec.containers.all(c,
          !has(c.ports) ||
          c.ports.all(p, p.containerPort >= 1 && p.containerPort <= 65535)
        )
      message: "Container ports must be between 1 and 65535"

    # Image from allowed registries (safe_url pattern)
    - expression: |
        object.spec.containers.all(c,
          c.image.startsWith('gcr.io/') ||
          c.image.startsWith('docker.io/library/') ||
          c.image.startsWith('registry.k8s.io/')
        )
      message: "Images must be from approved registries"

    # No path traversal in volume mounts (safe_path pattern)
    - expression: |
        !has(object.spec.containers) ||
        object.spec.containers.all(c,
          !has(c.volumeMounts) ||
          c.volumeMounts.all(v, !v.mountPath.matches('\\.\\./'))
        )
      message: "Volume mount paths must not contain path traversal"

    # Labels follow naming conventions (safe_string pattern)
    - expression: |
        has(object.metadata.labels) &&
        object.metadata.labels.all(k, k.matches('^[a-z0-9A-Z][a-z0-9A-Z._-]*$'))
      message: "Label keys must be valid identifiers"
*/

// ============================================================================
// FIREBASE SECURITY RULES EXAMPLES
// ============================================================================

/*
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Proven helper functions
    function isNonEmpty(s) {
      return s != null && s.size() > 0;
    }

    function isValidEmail(s) {
      return s.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }

    function inRange(n, min, max) {
      return n >= min && n <= max;
    }

    function isValidPort(p) {
      return p is int && p >= 1 && p <= 65535;
    }

    function isValidUUID(s) {
      return s.matches('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$');
    }

    function isValidE164Phone(s) {
      return s.matches('^\\+[1-9][0-9]{6,14}$');
    }

    function hasNoInjection(s) {
      return !s.matches('(?i)(<script|javascript:|SELECT\\s|DROP\\s)');
    }

    function isValidCoordinate(lat, lon) {
      return lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;
    }

    function isStrongPassword(s) {
      return s.size() >= 12 &&
             s.matches('.*[A-Z].*') &&
             s.matches('.*[a-z].*') &&
             s.matches('.*[0-9].*') &&
             s.matches('.*[!@#$%^&*].*');
    }

    // Users collection with comprehensive validation
    match /users/{userId} {
      allow read: if request.auth != null;

      allow create: if request.auth != null
        && isNonEmpty(request.resource.data.name)
        && request.resource.data.name.size() <= 255
        && hasNoInjection(request.resource.data.name)
        && isValidEmail(request.resource.data.email)
        && (!('phone' in request.resource.data) || isValidE164Phone(request.resource.data.phone));

      allow update: if request.auth.uid == userId
        && isNonEmpty(request.resource.data.name)
        && request.resource.data.name.size() <= 255
        && hasNoInjection(request.resource.data.name);
    }

    // Locations collection with geo validation
    match /locations/{locationId} {
      allow read: if request.auth != null;

      allow write: if request.auth != null
        && isValidCoordinate(request.resource.data.latitude, request.resource.data.longitude)
        && isNonEmpty(request.resource.data.name);
    }

    // Config collection with safe_network patterns
    match /config/{configId} {
      allow read: if request.auth != null;

      allow write: if request.auth.token.admin == true
        && inRange(request.resource.data.maxConnections, 1, 1000)
        && isValidPort(request.resource.data.port)
        && isValidUUID(request.resource.data.instanceId);
    }
  }
}
*/

// ============================================================================
// CEL LIBRARY IMPLEMENTATION (Go)
// ============================================================================

/*
// Go implementation of Proven CEL functions
package proven

import (
    "regexp"

    "github.com/google/cel-go/cel"
    "github.com/google/cel-go/common/types"
    "github.com/google/cel-go/common/types/ref"
)

const (
    Version     = "0.4.0"
    ModuleCount = 38
)

// ProvenLib returns CEL function declarations for Proven safety primitives
func ProvenLib() cel.EnvOption {
    return cel.Lib(&provenLib{})
}

type provenLib struct{}

func (*provenLib) CompileOptions() []cel.EnvOption {
    return []cel.EnvOption{
        // Core: safe_math
        cel.Function("proven.inRange",
            cel.Overload("proven_in_range_int_int_int",
                []*cel.Type{cel.IntType, cel.IntType, cel.IntType},
                cel.BoolType,
                cel.FunctionBinding(inRange),
            ),
        ),
        cel.Function("proven.isPositive",
            cel.Overload("proven_is_positive_int",
                []*cel.Type{cel.IntType},
                cel.BoolType,
                cel.UnaryBinding(isPositive),
            ),
        ),

        // Core: safe_string
        cel.Function("proven.isNonEmpty",
            cel.Overload("proven_is_non_empty_string",
                []*cel.Type{cel.StringType},
                cel.BoolType,
                cel.UnaryBinding(isNonEmpty),
            ),
        ),
        cel.Function("proven.detectInjection",
            cel.Overload("proven_detect_injection_string",
                []*cel.Type{cel.StringType},
                cel.BoolType,
                cel.UnaryBinding(detectInjection),
            ),
        ),

        // Core: safe_email
        cel.Function("proven.isEmail",
            cel.Overload("proven_is_email_string",
                []*cel.Type{cel.StringType},
                cel.BoolType,
                cel.UnaryBinding(isEmail),
            ),
        ),

        // Core: safe_network
        cel.Function("proven.isValidPort",
            cel.Overload("proven_is_valid_port_int",
                []*cel.Type{cel.IntType},
                cel.BoolType,
                cel.UnaryBinding(isValidPort),
            ),
        ),
        cel.Function("proven.isIPv4",
            cel.Overload("proven_is_ipv4_string",
                []*cel.Type{cel.StringType},
                cel.BoolType,
                cel.UnaryBinding(isIPv4),
            ),
        ),

        // Core: safe_uuid
        cel.Function("proven.isUUID",
            cel.Overload("proven_is_uuid_string",
                []*cel.Type{cel.StringType},
                cel.BoolType,
                cel.UnaryBinding(isUUID),
            ),
        ),

        // Core: safe_path
        cel.Function("proven.hasPathTraversal",
            cel.Overload("proven_has_path_traversal_string",
                []*cel.Type{cel.StringType},
                cel.BoolType,
                cel.UnaryBinding(hasPathTraversal),
            ),
        ),

        // Data: safe_datetime
        cel.Function("proven.isISODate",
            cel.Overload("proven_is_iso_date_string",
                []*cel.Type{cel.StringType},
                cel.BoolType,
                cel.UnaryBinding(isISODate),
            ),
        ),

        // Data: safe_version
        cel.Function("proven.isSemVer",
            cel.Overload("proven_is_semver_string",
                []*cel.Type{cel.StringType},
                cel.BoolType,
                cel.UnaryBinding(isSemVer),
            ),
        ),

        // Algorithm: safe_geo
        cel.Function("proven.isValidCoordinate",
            cel.Overload("proven_is_valid_coordinate_double_double",
                []*cel.Type{cel.DoubleType, cel.DoubleType},
                cel.BoolType,
                cel.BinaryBinding(isValidCoordinate),
            ),
        ),

        // Security: safe_password
        cel.Function("proven.isStrongPassword",
            cel.Overload("proven_is_strong_password_string_int",
                []*cel.Type{cel.StringType, cel.IntType},
                cel.BoolType,
                cel.BinaryBinding(isStrongPassword),
            ),
        ),

        // HTTP: safe_header
        cel.Function("proven.hasNoCRLF",
            cel.Overload("proven_has_no_crlf_string",
                []*cel.Type{cel.StringType},
                cel.BoolType,
                cel.UnaryBinding(hasNoCRLF),
            ),
        ),
    }
}

func (*provenLib) ProgramOptions() []cel.ProgramOption {
    return nil
}

// Core implementations

func inRange(args ...ref.Val) ref.Val {
    if len(args) != 3 {
        return types.False
    }
    n, ok1 := args[0].Value().(int64)
    min, ok2 := args[1].Value().(int64)
    max, ok3 := args[2].Value().(int64)
    if !ok1 || !ok2 || !ok3 {
        return types.False
    }
    return types.Bool(n >= min && n <= max)
}

func isPositive(val ref.Val) ref.Val {
    n, ok := val.Value().(int64)
    if !ok {
        return types.False
    }
    return types.Bool(n > 0)
}

func isNonEmpty(val ref.Val) ref.Val {
    s, ok := val.Value().(string)
    if !ok {
        return types.False
    }
    return types.Bool(len(s) > 0)
}

var injectionPattern = regexp.MustCompile(`(?i)(<script|javascript:|SELECT\s|DROP\s|--|/\*)`)

func detectInjection(val ref.Val) ref.Val {
    s, ok := val.Value().(string)
    if !ok {
        return types.False
    }
    return types.Bool(injectionPattern.MatchString(s))
}

var emailPattern = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)

func isEmail(val ref.Val) ref.Val {
    s, ok := val.Value().(string)
    if !ok {
        return types.False
    }
    return types.Bool(emailPattern.MatchString(s))
}

func isValidPort(val ref.Val) ref.Val {
    port, ok := val.Value().(int64)
    if !ok {
        return types.False
    }
    return types.Bool(port >= 1 && port <= 65535)
}

var ipv4Pattern = regexp.MustCompile(`^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`)

func isIPv4(val ref.Val) ref.Val {
    s, ok := val.Value().(string)
    if !ok {
        return types.False
    }
    return types.Bool(ipv4Pattern.MatchString(s))
}

var uuidPattern = regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`)

func isUUID(val ref.Val) ref.Val {
    s, ok := val.Value().(string)
    if !ok {
        return types.False
    }
    return types.Bool(uuidPattern.MatchString(s))
}

var pathTraversalPattern = regexp.MustCompile(`\.\./|\.\.\\`)

func hasPathTraversal(val ref.Val) ref.Val {
    s, ok := val.Value().(string)
    if !ok {
        return types.False
    }
    return types.Bool(pathTraversalPattern.MatchString(s))
}

var isoDatePattern = regexp.MustCompile(`^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$`)

func isISODate(val ref.Val) ref.Val {
    s, ok := val.Value().(string)
    if !ok {
        return types.False
    }
    return types.Bool(isoDatePattern.MatchString(s))
}

var semverPattern = regexp.MustCompile(`^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$`)

func isSemVer(val ref.Val) ref.Val {
    s, ok := val.Value().(string)
    if !ok {
        return types.False
    }
    return types.Bool(semverPattern.MatchString(s))
}

func isValidCoordinate(lhs, rhs ref.Val) ref.Val {
    lat, ok1 := lhs.Value().(float64)
    lon, ok2 := rhs.Value().(float64)
    if !ok1 || !ok2 {
        return types.False
    }
    return types.Bool(lat >= -90.0 && lat <= 90.0 && lon >= -180.0 && lon <= 180.0)
}

var (
    upperPattern   = regexp.MustCompile(`[A-Z]`)
    lowerPattern   = regexp.MustCompile(`[a-z]`)
    digitPattern   = regexp.MustCompile(`[0-9]`)
    specialPattern = regexp.MustCompile(`[!@#$%^&*(),.?":{}|<>]`)
)

func isStrongPassword(lhs, rhs ref.Val) ref.Val {
    s, ok1 := lhs.Value().(string)
    minLen, ok2 := rhs.Value().(int64)
    if !ok1 || !ok2 {
        return types.False
    }
    if int64(len(s)) < minLen {
        return types.False
    }
    return types.Bool(
        upperPattern.MatchString(s) &&
        lowerPattern.MatchString(s) &&
        digitPattern.MatchString(s) &&
        specialPattern.MatchString(s),
    )
}

func hasNoCRLF(val ref.Val) ref.Val {
    s, ok := val.Value().(string)
    if !ok {
        return types.True
    }
    for _, c := range s {
        if c == '\r' || c == '\n' {
            return types.False
        }
    }
    return types.True
}
*/

// ============================================================================
// ENVOY PROXY WASM FILTER EXAMPLE
// ============================================================================

/*
// Example: Using Proven CEL expressions in Envoy WASM filter configuration
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: proven-security-filter
spec:
  configPatches:
    - applyTo: HTTP_FILTER
      match:
        context: SIDECAR_INBOUND
      patch:
        operation: INSERT_BEFORE
        value:
          name: envoy.filters.http.rbac
          typed_config:
            "@type": type.googleapis.com/envoy.extensions.filters.http.rbac.v3.RBAC
            rules:
              action: ALLOW
              policies:
                "proven-validated-requests":
                  permissions:
                    - any: true
                  principals:
                    - metadata:
                        filter: envoy.filters.http.header_to_metadata
                        path:
                          - key: request_id
                        value:
                          # UUID validation using proven.isUUID pattern
                          string_match:
                            safe_regex:
                              google_re2: {}
                              regex: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
*/

// ============================================================================
// END OF FILE
// ============================================================================
