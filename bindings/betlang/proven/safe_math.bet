-- SPDX-License-Identifier: PMPL-1.0-or-later
-- Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

{- | SafeMath - Overflow-checked arithmetic via libproven FFI.

   BetLang's probabilistic metaphors make this module naturally expressive:
   each arithmetic operation is a "wager" that returns odds<Int64, ProvenError>
   where the error variant precisely describes the failure (Overflow, Underflow,
   DivByZero).

   All computation is performed in Idris 2 via the Zig FFI layer.
   NO arithmetic logic is reimplemented in BetLang.
-}

module Proven.SafeMath

import Proven.FFI
import Proven (ProvenError, odds, int_result_to_odds)

-- ============================================================================
-- Checked arithmetic operations
-- ============================================================================

-- | Safely add two integers with overflow detection.
-- Returns Lose(Overflow) if the result would exceed Int64 range.
-- Delegates to proven_math_add_checked in libproven.
bet fn safe_add(a : Int64, b : Int64) -> odds<Int64, ProvenError> =
  int_result_to_odds(FFI.proven_math_add_checked(a, b))

-- | Safely subtract two integers with underflow detection.
-- Returns Lose(Underflow) if the result would go below Int64 range.
-- Delegates to proven_math_sub_checked in libproven.
bet fn safe_sub(a : Int64, b : Int64) -> odds<Int64, ProvenError> =
  int_result_to_odds(FFI.proven_math_sub_checked(a, b))

-- | Safely multiply two integers with overflow detection.
-- Returns Lose(Overflow) if the result would exceed Int64 range.
-- Delegates to proven_math_mul_checked in libproven.
bet fn safe_mul(a : Int64, b : Int64) -> odds<Int64, ProvenError> =
  int_result_to_odds(FFI.proven_math_mul_checked(a, b))

-- | Safely divide two integers.
-- Returns Lose(DivByZero) if the denominator is zero.
-- Returns Lose(Overflow) for INT64_MIN / -1.
-- Delegates to proven_math_div in libproven.
bet fn safe_div(a : Int64, b : Int64) -> odds<Int64, ProvenError> =
  int_result_to_odds(FFI.proven_math_div(a, b))

-- | Safe modulo operation.
-- Returns Lose(DivByZero) if the denominator is zero.
-- Delegates to proven_math_mod in libproven.
bet fn safe_mod(a : Int64, b : Int64) -> odds<Int64, ProvenError> =
  int_result_to_odds(FFI.proven_math_mod(a, b))

-- | Safe absolute value.
-- Returns Lose(Overflow) for INT64_MIN (cannot be represented as positive Int64).
-- Delegates to proven_math_abs_safe in libproven.
bet fn safe_abs(n : Int64) -> odds<Int64, ProvenError> =
  int_result_to_odds(FFI.proven_math_abs_safe(n))

-- | Safe negation. Equivalent to safe_sub(0, n).
-- Returns Lose(Overflow) if negation of INT64_MIN.
-- Delegates to proven_math_sub_checked in libproven.
bet fn safe_negate(n : Int64) -> odds<Int64, ProvenError> =
  int_result_to_odds(FFI.proven_math_sub_checked(0i64, n))

-- | Clamp a value to [lo, hi] range.
-- This operation cannot fail -- a sure bet.
-- Delegates to proven_math_clamp in libproven.
bet fn clamp(lo : Int64, hi : Int64, value : Int64) -> Int64 =
  FFI.proven_math_clamp(lo, hi, value)

-- | Safe integer exponentiation with overflow checking.
-- Returns Lose(Overflow) if the result would exceed Int64 range.
-- Delegates to proven_math_pow_checked in libproven.
bet fn safe_pow(base : Int64, exp : UInt32) -> odds<Int64, ProvenError> =
  int_result_to_odds(FFI.proven_math_pow_checked(base, exp))

-- | Check if a value falls within [lo, hi].
-- This is a convenience function built on clamp.
bet fn in_range(value : Int64, lo : Int64, hi : Int64) -> Bool =
  value == clamp(lo, hi, value)

-- ============================================================================
-- BetLang specific: wagering idiom examples
-- ============================================================================

-- | Demonstrate BetLang's wagering idiom on arithmetic.
-- The compiler guarantees all odds are handled.
--
-- Example:
--   match safe_add(a, b) with
--   | Win(result)     => handle_payout(result)
--   | Lose(Overflow)  => handle_bust()
--   | Lose(Underflow) => handle_loss()
--   | Lose(e)         => handle_other(e)
