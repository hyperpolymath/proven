-- SPDX-License-Identifier: PMPL-1.0-or-later
-- Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

{- | SafeJson - JSON validation and type detection via libproven FFI.

   BetLang's wagering metaphors make JSON validation expressive: the
   odds<T, E> return type precisely captures whether the JSON wager
   wins (valid) or loses (parse failure). Root type detection is typed.

   All computation is performed in Idris 2 via the Zig FFI layer.
   NO JSON logic is reimplemented in BetLang.
-}

module Proven.SafeJson

import Proven.FFI
import Proven (ProvenError, odds, Lose, Win, bool_result_to_odds, float_result_to_odds)

-- ============================================================================
-- JSON types matching the C ABI enum
-- ============================================================================

-- | JSON value types as returned by the Idris 2 JSON parser.
stake type JsonType =
  | JsonNull
  | JsonBool
  | JsonNumber
  | JsonString
  | JsonArray
  | JsonObject
  | JsonInvalid

-- | Convert a raw C ABI type code to a JsonType.
bet fn int_to_json_type(code : Int32) -> JsonType =
  match code with
  | 0  => JsonNull
  | 1  => JsonBool
  | 2  => JsonNumber
  | 3  => JsonString
  | 4  => JsonArray
  | 5  => JsonObject
  | _  => JsonInvalid

-- ============================================================================
-- JSON validation
-- ============================================================================

-- | Check if a string is valid JSON.
-- Returns Win(true) if valid, Win(false) if not.
-- Delegates to proven_json_is_valid in libproven.
bet fn is_valid_json(input : String) -> odds<Bool, ProvenError> =
  let bytes = string_to_utf8(input)
  bool_result_to_odds(
    FFI.proven_json_is_valid(bytes.ptr, bytes.len)
  )

-- | Get the JSON value type at the root level.
-- Returns JsonInvalid if the string is not valid JSON.
-- Delegates to proven_json_get_type in libproven.
bet fn json_type(input : String) -> JsonType =
  let bytes = string_to_utf8(input)
  int_to_json_type(FFI.proven_json_get_type(bytes.ptr, bytes.len))

-- | Validate JSON and return the type in one step.
-- Returns Lose(ParseFailure) if the input is not valid JSON.
-- Combines proven_json_is_valid and proven_json_get_type from libproven.
bet fn validate_json(input : String) -> odds<JsonType, ProvenError> =
  match is_valid_json(input) with
  | Win(true)  => Win(json_type(input))
  | Win(false) => Lose(ParseFailure)
  | Lose(e)    => Lose(e)

-- ============================================================================
-- Safe expression evaluation
-- ============================================================================

-- | Safely evaluate an arithmetic expression string.
-- Supports +, -, *, /, parentheses, negative and decimal numbers.
-- Returns Lose(ParseFailure) for invalid expressions.
-- Returns Lose(DivByZero) for division by zero.
-- Delegates to proven_calculator_eval in libproven.
bet fn eval_expression(expr : String) -> odds<Float64, ProvenError> =
  let bytes = string_to_utf8(expr)
  float_result_to_odds(
    FFI.proven_calculator_eval(bytes.ptr, bytes.len)
  )

-- ============================================================================
-- BetLang specific: typed JSON validation
-- ============================================================================

-- | A validated JSON string type. Can only be constructed through the
-- validate function, ensuring the JSON has been parsed by the Idris 2
-- verified JSON validator.
stake type ValidatedJson = private ValidatedJson(String, JsonType)

-- | Get the original JSON string.
bet fn validated_json_string(json : ValidatedJson) -> String =
  match json with
  | ValidatedJson(s, _) => s

-- | Get the root type of the validated JSON.
bet fn validated_json_type(json : ValidatedJson) -> JsonType =
  match json with
  | ValidatedJson(_, t) => t

-- | Create a ValidatedJson value, returning an error if validation fails.
bet fn make_validated_json(input : String) -> odds<ValidatedJson, ProvenError> =
  match validate_json(input) with
  | Win(t)  => Win(ValidatedJson(input, t))
  | Lose(e) => Lose(e)
