; SPDX-License-Identifier: PMPL-1.0
; Proven - Safety primitives for Balanced Ternary Computing
;
; Balanced ternary uses three values: N (-1), Z (0), P (+1)
; Based on the Soviet Setun computer architecture.
; This is a specification format for ternary computing simulation.
;
; VERSION: 0.4.0
; MODULE_COUNT: 38

; ============================================================================
; LIBRARY METADATA
; ============================================================================

(define VERSION "0.4.0")
(define MODULE_COUNT 38)

(define MODULES
  '(; Core (11)
    safe_math safe_string safe_path safe_email safe_url
    safe_network safe_crypto safe_uuid safe_currency safe_phone safe_hex
    ; Data (7)
    safe_json safe_datetime safe_float safe_version safe_color safe_angle safe_unit
    ; Data Structures (5)
    safe_buffer safe_queue safe_bloom safe_lru safe_graph
    ; Resilience (4)
    safe_rate_limiter safe_circuit_breaker safe_retry safe_monotonic
    ; State (2)
    safe_state_machine safe_calculator
    ; Algorithm (4)
    safe_geo safe_probability safe_checksum safe_tensor
    ; Security (2)
    safe_password safe_ml
    ; HTTP (3)
    safe_header safe_cookie safe_content_type))

; ============================================================================
; TRIT VALUES
; ============================================================================

(define-trit N -1)  ; Negative
(define-trit Z  0)  ; Zero
(define-trit P +1)  ; Positive

; ============================================================================
; RESULT TYPE
; ============================================================================

(define-type (Result T)
  (variant Ok (value T))
  (variant Err (code Integer) (message String)))

(define (result-ok v) (Ok v))
(define (result-err code msg) (Err code msg))
(define (result-is-ok r) (match r ((Ok _) #t) ((Err _ _) #f)))
(define (result-is-err r) (not (result-is-ok r)))
(define (result-unwrap-or r default) (match r ((Ok v) v) ((Err _ _) default)))
(define (result-map r f) (match r ((Ok v) (Ok (f v))) ((Err c m) (Err c m))))

; ============================================================================
; OPTION TYPE
; ============================================================================

(define-type (Option T)
  (variant Some (value T))
  (variant None))

(define (option-some v) (Some v))
(define (option-none) (None))
(define (option-is-some o) (match o ((Some _) #t) ((None) #f)))
(define (option-is-none o) (not (option-is-some o)))
(define (option-unwrap-or o default) (match o ((Some v) v) ((None) default)))
(define (option-map o f) (match o ((Some v) (Some (f v))) ((None) (None))))

; ============================================================================
; TRIT OPERATIONS
; ============================================================================

; Negation: N->P, Z->Z, P->N
(define (trit-neg t) (match t (N P) (Z Z) (P N)))

; AND (minimum)
(define (trit-and a b)
  (cond ((or (= a N) (= b N)) N)
        ((or (= a Z) (= b Z)) Z)
        (else P)))

; OR (maximum)
(define (trit-or a b)
  (cond ((or (= a P) (= b P)) P)
        ((or (= a Z) (= b Z)) Z)
        (else N)))

; XOR (sum mod 3)
(define (trit-xor a b)
  (let ((sum (+ a b)))
    (cond ((> sum 1) N) ((< sum -1) P) (else sum))))

; Multiplication
(define (trit-mul a b) (* a b))

; Consensus (majority of 3)
(define (trit-consensus a b c)
  (let ((sum (+ a b c)))
    (cond ((>= sum 2) P) ((<= sum -2) N) (else Z))))

; ============================================================================
; TRYTE (6 trits, range -364 to +364)
; ============================================================================

(define TRYTE-MIN -364)
(define TRYTE-MAX  364)
(define TRYTE-TRITS 6)

(define (tryte-from-int n)
  (cond ((< n TRYTE-MIN) (result-err 1 "Underflow"))
        ((> n TRYTE-MAX) (result-err 2 "Overflow"))
        (else (result-ok n))))

(define (tryte-clamp n)
  (cond ((< n TRYTE-MIN) TRYTE-MIN)
        ((> n TRYTE-MAX) TRYTE-MAX)
        (else n)))

(define (tryte-valid? n)
  (and (>= n TRYTE-MIN) (<= n TRYTE-MAX)))

; ============================================================================
; TERNARY WORD (9 trits, range -9841 to +9841)
; ============================================================================

(define WORD-MIN -9841)
(define WORD-MAX  9841)
(define WORD-TRITS 9)

(define (word-from-int n)
  (cond ((< n WORD-MIN) (result-err 1 "Underflow"))
        ((> n WORD-MAX) (result-err 2 "Overflow"))
        (else (result-ok n))))

(define (word-clamp n)
  (cond ((< n WORD-MIN) WORD-MIN)
        ((> n WORD-MAX) WORD-MAX)
        (else n)))

; ============================================================================
; MODULE 1: SAFE_MATH - Safe Mathematical Operations
; ============================================================================

(define-module safe_math
  (description "Safe mathematical operations with overflow detection for balanced ternary"))

; Safe addition with overflow detection
(define (safe-add a b)
  (let ((sum (+ a b)))
    (cond ((< sum WORD-MIN) (result-err 1 "Underflow"))
          ((> sum WORD-MAX) (result-err 2 "Overflow"))
          (else (result-ok sum)))))

; Saturating addition
(define (safe-add-saturating a b) (word-clamp (+ a b)))

; Safe subtraction
(define (safe-sub a b)
  (let ((diff (- a b)))
    (cond ((< diff WORD-MIN) (result-err 1 "Underflow"))
          ((> diff WORD-MAX) (result-err 2 "Overflow"))
          (else (result-ok diff)))))

; Saturating subtraction
(define (safe-sub-saturating a b) (word-clamp (- a b)))

; Safe multiplication
(define (safe-mul a b)
  (let ((prod (* a b)))
    (cond ((< prod WORD-MIN) (result-err 1 "Underflow"))
          ((> prod WORD-MAX) (result-err 2 "Overflow"))
          (else (result-ok prod)))))

; Safe division with zero check
(define (safe-div a b)
  (if (= b 0)
      (result-err 3 "Division by zero")
      (result-ok (quotient a b))))

; Safe modulo
(define (safe-mod a b)
  (if (= b 0)
      (result-err 3 "Division by zero")
      (result-ok (remainder a b))))

; Safe negation
(define (safe-neg a)
  (if (= a WORD-MIN)
      (result-err 2 "Overflow")
      (result-ok (- a))))

; Safe absolute value
(define (safe-abs a)
  (if (= a WORD-MIN)
      (result-err 2 "Overflow")
      (result-ok (abs a))))

; Safe power
(define (safe-pow base exp)
  (letrec ((pow-iter (lambda (b e acc)
    (cond ((= e 0) (result-ok acc))
          ((> acc WORD-MAX) (result-err 2 "Overflow"))
          ((< acc WORD-MIN) (result-err 1 "Underflow"))
          (else (pow-iter b (- e 1) (* acc b)))))))
    (if (< exp 0)
        (result-err 4 "Negative exponent")
        (pow-iter base exp 1))))

; Check overflow
(define (would-overflow-add a b)
  (let ((sum (+ a b)))
    (or (< sum WORD-MIN) (> sum WORD-MAX))))

; Clamp value
(define (safe-clamp value min max)
  (cond ((< value min) min)
        ((> value max) max)
        (else value)))

; Increment
(define (safe-inc a) (safe-add a 1))

; Decrement
(define (safe-dec a) (safe-sub a 1))

; ============================================================================
; MODULE 2: SAFE_STRING - Safe String Operations
; ============================================================================

(define-module safe_string
  (description "Safe string operations with bounds checking for balanced ternary"))

(define STRING-MAX-LEN 9841)

; Safe string length (bounded)
(define (safe-string-len s)
  (if (> (string-length s) STRING-MAX-LEN)
      STRING-MAX-LEN
      (string-length s)))

; Safe substring with bounds checking
(define (safe-substring s start len)
  (let ((slen (string-length s)))
    (cond ((< start 0) (result-err 1 "Negative start index"))
          ((>= start slen) (result-err 2 "Start index out of bounds"))
          ((< len 0) (result-err 3 "Negative length"))
          (else (result-ok (substring s start (min (+ start len) slen)))))))

; Safe character at index
(define (safe-char-at s index)
  (if (or (< index 0) (>= index (string-length s)))
      (option-none)
      (option-some (string-ref s index))))

; Safe concatenation with length limit
(define (safe-concat a b)
  (let ((total-len (+ (string-length a) (string-length b))))
    (if (> total-len STRING-MAX-LEN)
        (result-err 2 "String too long")
        (result-ok (string-append a b)))))

; Truncate string to max length
(define (safe-truncate s max-len)
  (if (<= (string-length s) max-len)
      s
      (substring s 0 max-len)))

; Check if string is valid ternary representation
(define (valid-ternary-string? s)
  (let ((chars (string->list s)))
    (and (not (null? chars))
         (for-all (lambda (c) (or (char=? c #\N) (char=? c #\Z) (char=? c #\P))) chars))))

; ============================================================================
; MODULE 3: SAFE_PATH - Safe Path Operations
; ============================================================================

(define-module safe_path
  (description "Safe file path operations for balanced ternary systems"))

(define PATH-MAX-LEN 4096)
(define PATH-COMPONENT-MAX 255)

; Validate path component
(define (valid-path-component? s)
  (and (> (string-length s) 0)
       (<= (string-length s) PATH-COMPONENT-MAX)
       (not (string-contains? s "/"))
       (not (string-contains? s "\0"))))

; Safe path join
(define (safe-path-join base component)
  (cond ((not (valid-path-component? component))
         (result-err 1 "Invalid path component"))
        ((> (+ (string-length base) (string-length component) 1) PATH-MAX-LEN)
         (result-err 2 "Path too long"))
        (else
         (result-ok (string-append base "/" component)))))

; Normalize path (remove . and ..)
(define (safe-path-normalize path)
  (if (> (string-length path) PATH-MAX-LEN)
      (result-err 2 "Path too long")
      (result-ok (normalize-path-internal path))))

; Extract filename from path
(define (safe-path-filename path)
  (let ((parts (string-split path "/")))
    (if (null? parts)
        (option-none)
        (option-some (last parts)))))

; Extract extension from path
(define (safe-path-extension path)
  (let ((filename (option-unwrap-or (safe-path-filename path) "")))
    (let ((dot-pos (string-last-index-of filename #\.)))
      (if (< dot-pos 0)
          (option-none)
          (option-some (substring filename (+ dot-pos 1)))))))

; Check path traversal attempt
(define (path-traversal? path)
  (or (string-contains? path "..")
      (string-contains? path "//")
      (string-starts-with? path "/")))

; ============================================================================
; MODULE 4: SAFE_EMAIL - Safe Email Operations
; ============================================================================

(define-module safe_email
  (description "Safe email address validation for balanced ternary"))

(define EMAIL-MAX-LEN 254)
(define EMAIL-LOCAL-MAX 64)
(define EMAIL-DOMAIN-MAX 253)

; Validate email address structure
(define (valid-email? email)
  (and (<= (string-length email) EMAIL-MAX-LEN)
       (let ((at-pos (string-index-of email #\@)))
         (and (> at-pos 0)
              (<= at-pos EMAIL-LOCAL-MAX)
              (< at-pos (- (string-length email) 1))
              (<= (- (string-length email) at-pos 1) EMAIL-DOMAIN-MAX)
              (not (string-starts-with? email "."))
              (not (string-ends-with? email "."))
              (not (string-contains? email ".."))))))

; Extract local part
(define (email-local-part email)
  (let ((at-pos (string-index-of email #\@)))
    (if (< at-pos 0)
        (option-none)
        (option-some (substring email 0 at-pos)))))

; Extract domain part
(define (email-domain email)
  (let ((at-pos (string-index-of email #\@)))
    (if (< at-pos 0)
        (option-none)
        (option-some (substring email (+ at-pos 1))))))

; Create validated email
(define (safe-email-create email)
  (if (valid-email? email)
      (result-ok email)
      (result-err 1 "Invalid email format")))

; ============================================================================
; MODULE 5: SAFE_URL - Safe URL Operations
; ============================================================================

(define-module safe_url
  (description "Safe URL parsing and validation for balanced ternary"))

(define URL-MAX-LEN 2048)

; URL components
(define-type URL
  (scheme String)
  (host String)
  (port (Option Integer))
  (path String)
  (query (Option String))
  (fragment (Option String)))

; Validate URL scheme
(define (valid-scheme? scheme)
  (or (string=? scheme "http")
      (string=? scheme "https")
      (string=? scheme "ftp")
      (string=? scheme "file")))

; Safe URL parse
(define (safe-url-parse url-string)
  (cond ((> (string-length url-string) URL-MAX-LEN)
         (result-err 1 "URL too long"))
        ((not (string-contains? url-string "://"))
         (result-err 2 "Invalid URL format"))
        (else
         (parse-url-internal url-string))))

; URL encode (percent encoding)
(define (url-encode s)
  (encode-percent s))

; URL decode
(define (url-decode s)
  (decode-percent s))

; Check for URL injection attempts
(define (url-injection? url)
  (or (string-contains? url "javascript:")
      (string-contains? url "data:")
      (string-contains? url "vbscript:")))

; ============================================================================
; MODULE 6: SAFE_NETWORK - Safe Network Operations
; ============================================================================

(define-module safe_network
  (description "Safe network address validation for balanced ternary"))

; IPv4 address type
(define-type IPv4 (a Integer) (b Integer) (c Integer) (d Integer))

; Validate IPv4 octet
(define (valid-octet? n) (and (>= n 0) (<= n 255)))

; Create safe IPv4
(define (safe-ipv4 a b c d)
  (if (and (valid-octet? a) (valid-octet? b)
           (valid-octet? c) (valid-octet? d))
      (result-ok (IPv4 a b c d))
      (result-err 1 "Invalid IPv4 octet")))

; Parse IPv4 from string
(define (parse-ipv4 s)
  (let ((parts (string-split s ".")))
    (if (not (= (length parts) 4))
        (result-err 2 "Invalid IPv4 format")
        (let ((octets (map string->integer parts)))
          (if (for-all valid-octet? octets)
              (apply safe-ipv4 octets)
              (result-err 1 "Invalid IPv4 octet"))))))

; Check if IPv4 is private
(define (ipv4-private? ip)
  (or (= (IPv4-a ip) 10)
      (and (= (IPv4-a ip) 172) (>= (IPv4-b ip) 16) (<= (IPv4-b ip) 31))
      (and (= (IPv4-a ip) 192) (= (IPv4-b ip) 168))))

; Check if IPv4 is loopback
(define (ipv4-loopback? ip)
  (= (IPv4-a ip) 127))

; Port validation
(define (valid-port? port)
  (and (>= port 0) (<= port 65535)))

; Safe port
(define (safe-port p)
  (if (valid-port? p)
      (result-ok p)
      (result-err 1 "Invalid port number")))

; ============================================================================
; MODULE 7: SAFE_CRYPTO - Safe Cryptographic Operations
; ============================================================================

(define-module safe_crypto
  (description "Safe cryptographic operations for balanced ternary"))

(define HASH-LEN-256 32)
(define HASH-LEN-512 64)
(define KEY-LEN-MIN 16)

; Hash types
(define-type HashResult (bytes (List Integer)) (len Integer))

; Create safe hash result
(define (safe-hash-create bytes len)
  (if (= (length bytes) len)
      (result-ok (HashResult bytes len))
      (result-err 1 "Hash length mismatch")))

; Constant-time comparison (ternary version)
(define (constant-time-compare a b)
  (if (not (= (length a) (length b)))
      N  ; Not equal
      (let ((diff (fold-left (lambda (acc pair)
                              (trit-or acc (if (= (car pair) (cdr pair)) Z P)))
                            Z
                            (zip a b))))
        (if (= diff Z) P N))))

; Validate key length
(define (valid-key-length? len)
  (and (>= len KEY-LEN-MIN)
       (= (remainder len 8) 0)))

; Safe key generation placeholder
(define (safe-key-generate len)
  (if (valid-key-length? len)
      (result-ok (generate-random-bytes len))
      (result-err 1 "Invalid key length")))

; Ternary hash function (simulated)
(define (ternary-hash data)
  (let ((sum (fold-left + 0 data)))
    (map (lambda (i)
           (let ((v (remainder (+ sum i) 3)))
             (cond ((= v 0) Z) ((= v 1) P) (else N))))
         (range 0 HASH-LEN-256))))

; ============================================================================
; MODULE 8: SAFE_UUID - Safe UUID Operations
; ============================================================================

(define-module safe_uuid
  (description "Safe UUID generation and validation for balanced ternary"))

(define UUID-LEN 36)
(define UUID-BYTES 16)

; UUID type
(define-type UUID (bytes (List Integer)))

; Validate UUID format
(define (valid-uuid-format? s)
  (and (= (string-length s) UUID-LEN)
       (char=? (string-ref s 8) #\-)
       (char=? (string-ref s 13) #\-)
       (char=? (string-ref s 18) #\-)
       (char=? (string-ref s 23) #\-)))

; Parse UUID from string
(define (parse-uuid s)
  (if (not (valid-uuid-format? s))
      (result-err 1 "Invalid UUID format")
      (let ((hex-chars (string-filter (lambda (c) (not (char=? c #\-))) s)))
        (result-ok (UUID (hex-string-to-bytes hex-chars))))))

; UUID to string
(define (uuid-to-string uuid)
  (let ((hex (bytes-to-hex-string (UUID-bytes uuid))))
    (string-append (substring hex 0 8) "-"
                   (substring hex 8 12) "-"
                   (substring hex 12 16) "-"
                   (substring hex 16 20) "-"
                   (substring hex 20 32))))

; Generate nil UUID
(define (uuid-nil)
  (UUID (make-list UUID-BYTES 0)))

; Check if nil UUID
(define (uuid-nil? uuid)
  (for-all (lambda (b) (= b 0)) (UUID-bytes uuid)))

; ============================================================================
; MODULE 9: SAFE_CURRENCY - Safe Currency Operations
; ============================================================================

(define-module safe_currency
  (description "Safe currency operations with precision handling for balanced ternary"))

; Currency amount (in minor units to avoid floating point)
(define-type Money (amount Integer) (currency String) (decimals Integer))

(define CURRENCY-MAX 999999999999)  ; Max amount in minor units
(define CURRENCY-MIN (- CURRENCY-MAX))

; Create safe money
(define (safe-money amount currency decimals)
  (cond ((or (< amount CURRENCY-MIN) (> amount CURRENCY-MAX))
         (result-err 1 "Amount out of range"))
        ((or (< decimals 0) (> decimals 8))
         (result-err 2 "Invalid decimal places"))
        (else
         (result-ok (Money amount currency decimals)))))

; Add money (same currency only)
(define (safe-money-add a b)
  (if (not (string=? (Money-currency a) (Money-currency b)))
      (result-err 3 "Currency mismatch")
      (safe-add (Money-amount a) (Money-amount b))))

; Subtract money
(define (safe-money-sub a b)
  (if (not (string=? (Money-currency a) (Money-currency b)))
      (result-err 3 "Currency mismatch")
      (safe-sub (Money-amount a) (Money-amount b))))

; Format money to string
(define (money-format m)
  (let ((divisor (expt 10 (Money-decimals m))))
    (string-append (Money-currency m) " "
                   (number->string (quotient (Money-amount m) divisor))
                   "."
                   (pad-left (number->string (remainder (Money-amount m) divisor))
                            (Money-decimals m) #\0))))

; ============================================================================
; MODULE 10: SAFE_PHONE - Safe Phone Number Operations
; ============================================================================

(define-module safe_phone
  (description "Safe phone number validation for balanced ternary"))

(define PHONE-MAX-LEN 15)
(define PHONE-MIN-LEN 7)

; Phone number type
(define-type PhoneNumber
  (country-code String)
  (number String))

; Validate phone number (E.164 format)
(define (valid-phone? phone)
  (let ((digits (string-filter char-numeric? phone)))
    (and (>= (string-length digits) PHONE-MIN-LEN)
         (<= (string-length digits) PHONE-MAX-LEN))))

; Parse phone number
(define (parse-phone s)
  (let ((cleaned (string-filter (lambda (c)
                                  (or (char-numeric? c) (char=? c #\+)))
                                s)))
    (if (valid-phone? cleaned)
        (result-ok (PhoneNumber
                    (if (string-starts-with? cleaned "+")
                        (substring cleaned 1 4)
                        "")
                    cleaned))
        (result-err 1 "Invalid phone number"))))

; Format phone number
(define (phone-format phone)
  (if (> (string-length (PhoneNumber-country-code phone)) 0)
      (string-append "+" (PhoneNumber-country-code phone) " "
                     (PhoneNumber-number phone))
      (PhoneNumber-number phone)))

; ============================================================================
; MODULE 11: SAFE_HEX - Safe Hexadecimal Operations
; ============================================================================

(define-module safe_hex
  (description "Safe hexadecimal encoding/decoding for balanced ternary"))

(define HEX-CHARS "0123456789abcdef")

; Check if valid hex character
(define (hex-char? c)
  (or (and (char>=? c #\0) (char<=? c #\9))
      (and (char>=? c #\a) (char<=? c #\f))
      (and (char>=? c #\A) (char<=? c #\F))))

; Check if valid hex string
(define (valid-hex-string? s)
  (and (= (remainder (string-length s) 2) 0)
       (for-all hex-char? (string->list s))))

; Hex char to value
(define (hex-char-value c)
  (cond ((and (char>=? c #\0) (char<=? c #\9))
         (- (char->integer c) (char->integer #\0)))
        ((and (char>=? c #\a) (char<=? c #\f))
         (+ 10 (- (char->integer c) (char->integer #\a))))
        ((and (char>=? c #\A) (char<=? c #\F))
         (+ 10 (- (char->integer c) (char->integer #\A))))
        (else -1)))

; Bytes to hex string
(define (bytes-to-hex bytes)
  (apply string-append
         (map (lambda (b)
                (string (string-ref HEX-CHARS (quotient b 16))
                        (string-ref HEX-CHARS (remainder b 16))))
              bytes)))

; Hex string to bytes
(define (hex-to-bytes s)
  (if (not (valid-hex-string? s))
      (result-err 1 "Invalid hex string")
      (result-ok
       (let loop ((chars (string->list s)) (result '()))
         (if (null? chars)
             (reverse result)
             (loop (cddr chars)
                   (cons (+ (* 16 (hex-char-value (car chars)))
                           (hex-char-value (cadr chars)))
                         result)))))))

; Ternary to hex conversion
(define (ternary-to-hex trits)
  (bytes-to-hex (ternary-to-bytes trits)))

; ============================================================================
; MODULE 12: SAFE_JSON - Safe JSON Operations
; ============================================================================

(define-module safe_json
  (description "Safe JSON parsing and generation for balanced ternary"))

(define JSON-MAX-DEPTH 32)
(define JSON-MAX-STRING-LEN 1048576)

; JSON value types
(define-type JSONValue
  (variant JSONNull)
  (variant JSONBool (value Boolean))
  (variant JSONNumber (value Number))
  (variant JSONString (value String))
  (variant JSONArray (values (List JSONValue)))
  (variant JSONObject (pairs (List (Pair String JSONValue)))))

; Safe JSON parse with depth limit
(define (safe-json-parse s max-depth)
  (if (> (string-length s) JSON-MAX-STRING-LEN)
      (result-err 1 "JSON string too long")
      (parse-json-with-depth s 0 max-depth)))

; Safe JSON stringify
(define (safe-json-stringify value)
  (match value
    ((JSONNull) "null")
    ((JSONBool b) (if b "true" "false"))
    ((JSONNumber n) (number->string n))
    ((JSONString s) (string-append "\"" (json-escape-string s) "\""))
    ((JSONArray vals) (string-append "[" (string-join (map safe-json-stringify vals) ",") "]"))
    ((JSONObject pairs) (string-append "{"
                                       (string-join
                                        (map (lambda (p)
                                               (string-append "\"" (car p) "\":"
                                                              (safe-json-stringify (cdr p))))
                                             pairs) ",") "}"))))

; JSON path access
(define (json-get-path value path)
  (if (null? path)
      (option-some value)
      (match value
        ((JSONObject pairs)
         (let ((found (assoc (car path) pairs)))
           (if found
               (json-get-path (cdr found) (cdr path))
               (option-none))))
        ((JSONArray vals)
         (if (and (integer? (car path))
                  (>= (car path) 0)
                  (< (car path) (length vals)))
             (json-get-path (list-ref vals (car path)) (cdr path))
             (option-none)))
        (_ (option-none)))))

; ============================================================================
; MODULE 13: SAFE_DATETIME - Safe Date/Time Operations
; ============================================================================

(define-module safe_datetime
  (description "Safe date and time operations for balanced ternary"))

; Date type
(define-type Date (year Integer) (month Integer) (day Integer))

; Time type
(define-type Time (hour Integer) (minute Integer) (second Integer))

; DateTime type
(define-type DateTime (date Date) (time Time))

; Validate date components
(define (valid-month? m) (and (>= m 1) (<= m 12)))
(define (valid-day? d m y)
  (and (>= d 1)
       (<= d (days-in-month m y))))

(define (days-in-month m y)
  (cond ((member m '(1 3 5 7 8 10 12)) 31)
        ((member m '(4 6 9 11)) 30)
        ((= m 2) (if (leap-year? y) 29 28))))

(define (leap-year? y)
  (or (and (= (remainder y 4) 0) (not (= (remainder y 100) 0)))
      (= (remainder y 400) 0)))

; Create safe date
(define (safe-date y m d)
  (cond ((not (valid-month? m))
         (result-err 1 "Invalid month"))
        ((not (valid-day? d m y))
         (result-err 2 "Invalid day"))
        (else
         (result-ok (Date y m d)))))

; Create safe time
(define (safe-time h m s)
  (cond ((not (and (>= h 0) (<= h 23)))
         (result-err 1 "Invalid hour"))
        ((not (and (>= m 0) (<= m 59)))
         (result-err 2 "Invalid minute"))
        ((not (and (>= s 0) (<= s 59)))
         (result-err 3 "Invalid second"))
        (else
         (result-ok (Time h m s)))))

; Add days to date
(define (date-add-days date days)
  (let ((julian (date-to-julian date)))
    (julian-to-date (+ julian days))))

; Difference in days
(define (date-diff a b)
  (- (date-to-julian a) (date-to-julian b)))

; ============================================================================
; MODULE 14: SAFE_FLOAT - Safe Floating Point Operations
; ============================================================================

(define-module safe_float
  (description "Safe floating point operations for balanced ternary"))

(define EPSILON 1e-10)
(define FLOAT-MAX 1e308)
(define FLOAT-MIN -1e308)

; Safe float comparison with epsilon
(define (float-equal? a b epsilon)
  (< (abs (- a b)) epsilon))

; Safe float add
(define (safe-float-add a b)
  (let ((sum (+ a b)))
    (cond ((nan? sum) (result-err 1 "Result is NaN"))
          ((infinite? sum) (result-err 2 "Result is infinite"))
          (else (result-ok sum)))))

; Safe float divide
(define (safe-float-div a b)
  (cond ((float-equal? b 0.0 EPSILON)
         (result-err 3 "Division by zero"))
        (else
         (let ((quot (/ a b)))
           (if (or (nan? quot) (infinite? quot))
               (result-err 4 "Invalid result")
               (result-ok quot))))))

; Safe float sqrt
(define (safe-float-sqrt x)
  (if (< x 0)
      (result-err 5 "Square root of negative")
      (result-ok (sqrt x))))

; Clamp float
(define (float-clamp x min max)
  (cond ((< x min) min)
        ((> x max) max)
        (else x)))

; Round to decimal places
(define (float-round-to x places)
  (let ((mult (expt 10 places)))
    (/ (round (* x mult)) mult)))

; ============================================================================
; MODULE 15: SAFE_VERSION - Safe Semantic Version Operations
; ============================================================================

(define-module safe_version
  (description "Safe semantic versioning for balanced ternary"))

; Semantic version type
(define-type SemVer
  (major Integer)
  (minor Integer)
  (patch Integer)
  (prerelease (Option String))
  (build (Option String)))

; Create safe version
(define (safe-version major minor patch)
  (if (or (< major 0) (< minor 0) (< patch 0))
      (result-err 1 "Version components must be non-negative")
      (result-ok (SemVer major minor patch (option-none) (option-none)))))

; Parse version string
(define (parse-version s)
  (let ((parts (string-split s ".")))
    (if (< (length parts) 3)
        (result-err 2 "Invalid version format")
        (let ((nums (map string->integer (take parts 3))))
          (if (for-all (lambda (n) (and n (>= n 0))) nums)
              (apply safe-version nums)
              (result-err 3 "Invalid version number"))))))

; Compare versions
(define (version-compare a b)
  (cond ((> (SemVer-major a) (SemVer-major b)) P)
        ((< (SemVer-major a) (SemVer-major b)) N)
        ((> (SemVer-minor a) (SemVer-minor b)) P)
        ((< (SemVer-minor a) (SemVer-minor b)) N)
        ((> (SemVer-patch a) (SemVer-patch b)) P)
        ((< (SemVer-patch a) (SemVer-patch b)) N)
        (else Z)))

; Version to string
(define (version-to-string v)
  (string-append (number->string (SemVer-major v)) "."
                 (number->string (SemVer-minor v)) "."
                 (number->string (SemVer-patch v))))

; Bump version
(define (version-bump-major v)
  (SemVer (+ (SemVer-major v) 1) 0 0 (option-none) (option-none)))
(define (version-bump-minor v)
  (SemVer (SemVer-major v) (+ (SemVer-minor v) 1) 0 (option-none) (option-none)))
(define (version-bump-patch v)
  (SemVer (SemVer-major v) (SemVer-minor v) (+ (SemVer-patch v) 1) (option-none) (option-none)))

; ============================================================================
; MODULE 16: SAFE_COLOR - Safe Color Operations
; ============================================================================

(define-module safe_color
  (description "Safe color operations for balanced ternary"))

; RGB color type (0-255 per channel)
(define-type RGB (r Integer) (g Integer) (b Integer))

; HSL color type (h: 0-360, s: 0-100, l: 0-100)
(define-type HSL (h Integer) (s Integer) (l Integer))

; RGBA with alpha
(define-type RGBA (r Integer) (g Integer) (b Integer) (a Integer))

; Validate RGB component
(define (valid-rgb-component? c) (and (>= c 0) (<= c 255)))

; Create safe RGB
(define (safe-rgb r g b)
  (if (and (valid-rgb-component? r)
           (valid-rgb-component? g)
           (valid-rgb-component? b))
      (result-ok (RGB r g b))
      (result-err 1 "RGB components must be 0-255")))

; Parse hex color
(define (parse-hex-color s)
  (let ((hex (if (string-starts-with? s "#") (substring s 1) s)))
    (cond ((= (string-length hex) 6)
           (let ((r (hex-to-int (substring hex 0 2)))
                 (g (hex-to-int (substring hex 2 4)))
                 (b (hex-to-int (substring hex 4 6))))
             (safe-rgb r g b)))
          ((= (string-length hex) 3)
           (let ((r (hex-to-int (string (string-ref hex 0) (string-ref hex 0))))
                 (g (hex-to-int (string (string-ref hex 1) (string-ref hex 1))))
                 (b (hex-to-int (string (string-ref hex 2) (string-ref hex 2)))))
             (safe-rgb r g b)))
          (else (result-err 2 "Invalid hex color format")))))

; RGB to hex string
(define (rgb-to-hex color)
  (string-append "#"
                 (pad-left (int-to-hex (RGB-r color)) 2 #\0)
                 (pad-left (int-to-hex (RGB-g color)) 2 #\0)
                 (pad-left (int-to-hex (RGB-b color)) 2 #\0)))

; Lighten color
(define (color-lighten color amount)
  (safe-rgb (min 255 (+ (RGB-r color) amount))
            (min 255 (+ (RGB-g color) amount))
            (min 255 (+ (RGB-b color) amount))))

; Darken color
(define (color-darken color amount)
  (safe-rgb (max 0 (- (RGB-r color) amount))
            (max 0 (- (RGB-g color) amount))
            (max 0 (- (RGB-b color) amount))))

; ============================================================================
; MODULE 17: SAFE_ANGLE - Safe Angle Operations
; ============================================================================

(define-module safe_angle
  (description "Safe angle operations for balanced ternary"))

(define PI 3.141592653589793)
(define TAU (* 2 PI))

; Angle type (stored in radians internally)
(define-type Angle (radians Number))

; Create angle from degrees
(define (angle-from-degrees deg)
  (Angle (* deg (/ PI 180))))

; Create angle from radians
(define (angle-from-radians rad)
  (Angle rad))

; Normalize angle to [0, 2*PI)
(define (angle-normalize angle)
  (let ((rad (Angle-radians angle)))
    (Angle (- rad (* TAU (floor (/ rad TAU)))))))

; Normalize angle to [-PI, PI)
(define (angle-normalize-signed angle)
  (let ((normalized (angle-normalize angle)))
    (if (>= (Angle-radians normalized) PI)
        (Angle (- (Angle-radians normalized) TAU))
        normalized)))

; Convert to degrees
(define (angle-to-degrees angle)
  (* (Angle-radians angle) (/ 180 PI)))

; Add angles
(define (angle-add a b)
  (angle-normalize (Angle (+ (Angle-radians a) (Angle-radians b)))))

; Subtract angles
(define (angle-sub a b)
  (angle-normalize (Angle (- (Angle-radians a) (Angle-radians b)))))

; Difference between angles (shortest path)
(define (angle-diff a b)
  (angle-normalize-signed (angle-sub a b)))

; Trigonometric functions
(define (angle-sin a) (sin (Angle-radians a)))
(define (angle-cos a) (cos (Angle-radians a)))
(define (angle-tan a) (tan (Angle-radians a)))

; ============================================================================
; MODULE 18: SAFE_UNIT - Safe Unit Conversion Operations
; ============================================================================

(define-module safe_unit
  (description "Safe unit conversions for balanced ternary"))

; Quantity with unit
(define-type Quantity (value Number) (unit String))

; Length conversions
(define (meters-to-feet m) (Quantity (* m 3.28084) "ft"))
(define (feet-to-meters ft) (Quantity (* ft 0.3048) "m"))
(define (miles-to-km mi) (Quantity (* mi 1.60934) "km"))
(define (km-to-miles km) (Quantity (* km 0.621371) "mi"))

; Temperature conversions
(define (celsius-to-fahrenheit c)
  (Quantity (+ (* c 1.8) 32) "F"))
(define (fahrenheit-to-celsius f)
  (Quantity (/ (- f 32) 1.8) "C"))
(define (celsius-to-kelvin c)
  (Quantity (+ c 273.15) "K"))
(define (kelvin-to-celsius k)
  (if (< k 0)
      (result-err 1 "Kelvin cannot be negative")
      (result-ok (Quantity (- k 273.15) "C"))))

; Mass conversions
(define (kg-to-pounds kg) (Quantity (* kg 2.20462) "lb"))
(define (pounds-to-kg lb) (Quantity (* lb 0.453592) "kg"))

; Volume conversions
(define (liters-to-gallons l) (Quantity (* l 0.264172) "gal"))
(define (gallons-to-liters g) (Quantity (* g 3.78541) "L"))

; Safe conversion with range check
(define (safe-convert value converter min max)
  (if (or (< value min) (> value max))
      (result-err 1 "Value out of range")
      (result-ok (converter value))))

; ============================================================================
; MODULE 19: SAFE_BUFFER - Safe Buffer Operations
; ============================================================================

(define-module safe_buffer
  (description "Safe bounded buffer operations for balanced ternary"))

; Bounded buffer type
(define-type BoundedBuffer
  (data (List Any))
  (capacity Integer)
  (count Integer))

; Create bounded buffer
(define (buffer-create capacity)
  (if (<= capacity 0)
      (result-err 1 "Capacity must be positive")
      (result-ok (BoundedBuffer '() capacity 0))))

; Check if buffer is empty
(define (buffer-empty? buf)
  (= (BoundedBuffer-count buf) 0))

; Check if buffer is full
(define (buffer-full? buf)
  (>= (BoundedBuffer-count buf) (BoundedBuffer-capacity buf)))

; Push to buffer
(define (buffer-push buf value)
  (if (buffer-full? buf)
      (result-err 2 "Buffer full")
      (result-ok (BoundedBuffer
                  (append (BoundedBuffer-data buf) (list value))
                  (BoundedBuffer-capacity buf)
                  (+ (BoundedBuffer-count buf) 1)))))

; Pop from buffer
(define (buffer-pop buf)
  (if (buffer-empty? buf)
      (result-err 3 "Buffer empty")
      (let ((data (BoundedBuffer-data buf)))
        (result-ok (cons (last data)
                        (BoundedBuffer
                         (butlast data)
                         (BoundedBuffer-capacity buf)
                         (- (BoundedBuffer-count buf) 1)))))))

; Get element at index
(define (buffer-get buf index)
  (if (or (< index 0) (>= index (BoundedBuffer-count buf)))
      (result-err 4 "Index out of bounds")
      (result-ok (list-ref (BoundedBuffer-data buf) index))))

; ============================================================================
; MODULE 20: SAFE_QUEUE - Safe Queue Operations
; ============================================================================

(define-module safe_queue
  (description "Safe FIFO queue operations for balanced ternary"))

; Ring buffer queue
(define-type RingQueue
  (data (Vector Any))
  (head Integer)
  (tail Integer)
  (count Integer)
  (capacity Integer))

; Create ring queue
(define (queue-create capacity)
  (if (<= capacity 0)
      (result-err 1 "Capacity must be positive")
      (result-ok (RingQueue (make-vector capacity #f) 0 0 0 capacity))))

; Queue empty check
(define (queue-empty? q)
  (= (RingQueue-count q) 0))

; Queue full check
(define (queue-full? q)
  (= (RingQueue-count q) (RingQueue-capacity q)))

; Enqueue (add to tail)
(define (queue-enqueue q value)
  (if (queue-full? q)
      (result-err 2 "Queue full")
      (let ((new-data (vector-copy (RingQueue-data q))))
        (vector-set! new-data (RingQueue-tail q) value)
        (result-ok (RingQueue
                    new-data
                    (RingQueue-head q)
                    (remainder (+ (RingQueue-tail q) 1) (RingQueue-capacity q))
                    (+ (RingQueue-count q) 1)
                    (RingQueue-capacity q))))))

; Dequeue (remove from head)
(define (queue-dequeue q)
  (if (queue-empty? q)
      (result-err 3 "Queue empty")
      (let ((value (vector-ref (RingQueue-data q) (RingQueue-head q))))
        (result-ok (cons value
                        (RingQueue
                         (RingQueue-data q)
                         (remainder (+ (RingQueue-head q) 1) (RingQueue-capacity q))
                         (RingQueue-tail q)
                         (- (RingQueue-count q) 1)
                         (RingQueue-capacity q)))))))

; Peek at head
(define (queue-peek q)
  (if (queue-empty? q)
      (option-none)
      (option-some (vector-ref (RingQueue-data q) (RingQueue-head q)))))

; ============================================================================
; MODULE 21: SAFE_BLOOM - Safe Bloom Filter Operations
; ============================================================================

(define-module safe_bloom
  (description "Safe Bloom filter for balanced ternary"))

; Bloom filter type
(define-type BloomFilter
  (bits (Vector Boolean))
  (num-hash Integer)
  (size Integer))

; Create bloom filter
(define (bloom-create size num-hash)
  (if (or (<= size 0) (<= num-hash 0))
      (result-err 1 "Size and hash count must be positive")
      (result-ok (BloomFilter (make-vector size #f) num-hash size))))

; Hash function (simulated)
(define (bloom-hash data seed size)
  (remainder (+ (ternary-hash-simple data) seed) size))

; Add item to bloom filter
(define (bloom-add filter item)
  (let ((new-bits (vector-copy (BloomFilter-bits filter))))
    (for-each (lambda (i)
                (let ((hash (bloom-hash item i (BloomFilter-size filter))))
                  (vector-set! new-bits hash #t)))
              (range 0 (BloomFilter-num-hash filter)))
    (BloomFilter new-bits
                 (BloomFilter-num-hash filter)
                 (BloomFilter-size filter))))

; Check if item might be in filter
(define (bloom-might-contain? filter item)
  (for-all (lambda (i)
             (let ((hash (bloom-hash item i (BloomFilter-size filter))))
               (vector-ref (BloomFilter-bits filter) hash)))
           (range 0 (BloomFilter-num-hash filter))))

; Estimate false positive rate
(define (bloom-false-positive-rate filter items-added)
  (let* ((m (BloomFilter-size filter))
         (k (BloomFilter-num-hash filter))
         (n items-added)
         (exp-val (exp (- (/ (* k n) m)))))
    (expt (- 1 exp-val) k)))

; ============================================================================
; MODULE 22: SAFE_LRU - Safe LRU Cache Operations
; ============================================================================

(define-module safe_lru
  (description "Safe LRU cache operations for balanced ternary"))

; LRU cache entry
(define-type LRUEntry
  (key Any)
  (value Any)
  (access-time Integer))

; LRU cache
(define-type LRUCache
  (entries (List LRUEntry))
  (capacity Integer)
  (time-counter Integer))

; Create LRU cache
(define (lru-create capacity)
  (if (<= capacity 0)
      (result-err 1 "Capacity must be positive")
      (result-ok (LRUCache '() capacity 0))))

; Get from cache
(define (lru-get cache key)
  (let ((entry (find (lambda (e) (equal? (LRUEntry-key e) key))
                     (LRUCache-entries cache))))
    (if entry
        (let ((new-entries (map (lambda (e)
                                  (if (equal? (LRUEntry-key e) key)
                                      (LRUEntry key (LRUEntry-value e) (LRUCache-time-counter cache))
                                      e))
                                (LRUCache-entries cache))))
          (option-some (cons (LRUEntry-value entry)
                            (LRUCache new-entries
                                      (LRUCache-capacity cache)
                                      (+ (LRUCache-time-counter cache) 1)))))
        (option-none))))

; Put into cache
(define (lru-put cache key value)
  (let* ((time (LRUCache-time-counter cache))
         (new-entry (LRUEntry key value time))
         (filtered (filter (lambda (e) (not (equal? (LRUEntry-key e) key)))
                          (LRUCache-entries cache)))
         (new-entries (cons new-entry filtered)))
    (if (> (length new-entries) (LRUCache-capacity cache))
        (let* ((sorted (sort new-entries
                            (lambda (a b) (< (LRUEntry-access-time a)
                                            (LRUEntry-access-time b)))))
               (evicted (cdr sorted)))
          (LRUCache evicted (LRUCache-capacity cache) (+ time 1)))
        (LRUCache new-entries (LRUCache-capacity cache) (+ time 1)))))

; Remove from cache
(define (lru-remove cache key)
  (LRUCache (filter (lambda (e) (not (equal? (LRUEntry-key e) key)))
                    (LRUCache-entries cache))
            (LRUCache-capacity cache)
            (LRUCache-time-counter cache)))

; ============================================================================
; MODULE 23: SAFE_GRAPH - Safe Graph Operations
; ============================================================================

(define-module safe_graph
  (description "Safe graph data structure operations for balanced ternary"))

; Edge type
(define-type Edge
  (from Integer)
  (to Integer)
  (weight Number))

; Graph type (adjacency list)
(define-type Graph
  (vertices Integer)
  (edges (List Edge))
  (directed Boolean))

; Create graph
(define (graph-create vertices directed)
  (if (<= vertices 0)
      (result-err 1 "Vertices must be positive")
      (result-ok (Graph vertices '() directed))))

; Add edge with validation
(define (graph-add-edge graph from to weight)
  (cond ((or (< from 0) (>= from (Graph-vertices graph)))
         (result-err 2 "Invalid source vertex"))
        ((or (< to 0) (>= to (Graph-vertices graph)))
         (result-err 3 "Invalid destination vertex"))
        (else
         (let ((new-edges (cons (Edge from to weight) (Graph-edges graph))))
           (result-ok (Graph (Graph-vertices graph)
                             (if (Graph-directed graph)
                                 new-edges
                                 (cons (Edge to from weight) new-edges))
                             (Graph-directed graph)))))))

; Get neighbors of vertex
(define (graph-neighbors graph vertex)
  (if (or (< vertex 0) (>= vertex (Graph-vertices graph)))
      (result-err 2 "Invalid vertex")
      (result-ok (filter-map (lambda (e)
                               (if (= (Edge-from e) vertex)
                                   (option-some (cons (Edge-to e) (Edge-weight e)))
                                   (option-none)))
                             (Graph-edges graph)))))

; Check if edge exists
(define (graph-has-edge? graph from to)
  (any (lambda (e) (and (= (Edge-from e) from) (= (Edge-to e) to)))
       (Graph-edges graph)))

; Get in-degree of vertex
(define (graph-in-degree graph vertex)
  (length (filter (lambda (e) (= (Edge-to e) vertex)) (Graph-edges graph))))

; Get out-degree of vertex
(define (graph-out-degree graph vertex)
  (length (filter (lambda (e) (= (Edge-from e) vertex)) (Graph-edges graph))))

; ============================================================================
; MODULE 24: SAFE_RATE_LIMITER - Safe Rate Limiting Operations
; ============================================================================

(define-module safe_rate_limiter
  (description "Safe rate limiting algorithms for balanced ternary"))

; Rate limit result
(define-type RateLimitResult
  (variant Allowed)
  (variant Denied (retry-after Integer)))

; Token bucket
(define-type TokenBucket
  (capacity Integer)
  (tokens Integer)
  (refill-rate Integer)
  (last-refill Integer))

; Create token bucket
(define (token-bucket-create capacity refill-rate)
  (if (or (<= capacity 0) (<= refill-rate 0))
      (result-err 1 "Capacity and refill rate must be positive")
      (result-ok (TokenBucket capacity capacity refill-rate 0))))

; Refill tokens
(define (token-bucket-refill bucket current-time)
  (let* ((elapsed (- current-time (TokenBucket-last-refill bucket)))
         (new-tokens (+ (TokenBucket-tokens bucket)
                       (* (TokenBucket-refill-rate bucket) elapsed)))
         (capped (min new-tokens (TokenBucket-capacity bucket))))
    (TokenBucket (TokenBucket-capacity bucket)
                 capped
                 (TokenBucket-refill-rate bucket)
                 current-time)))

; Try to acquire tokens
(define (token-bucket-acquire bucket count current-time)
  (let ((refilled (token-bucket-refill bucket current-time)))
    (if (>= (TokenBucket-tokens refilled) count)
        (cons (Allowed)
              (TokenBucket (TokenBucket-capacity refilled)
                          (- (TokenBucket-tokens refilled) count)
                          (TokenBucket-refill-rate refilled)
                          current-time))
        (let* ((needed (- count (TokenBucket-tokens refilled)))
               (wait (ceiling (/ needed (TokenBucket-refill-rate refilled)))))
          (cons (Denied wait) refilled)))))

; Sliding window rate limiter
(define-type SlidingWindow
  (max-requests Integer)
  (window-size Integer)
  (requests (List Integer)))

(define (sliding-window-create max-requests window-size)
  (result-ok (SlidingWindow max-requests window-size '())))

(define (sliding-window-request window current-time)
  (let* ((cutoff (- current-time (SlidingWindow-window-size window)))
         (valid (filter (lambda (t) (>= t cutoff))
                       (SlidingWindow-requests window))))
    (if (< (length valid) (SlidingWindow-max-requests window))
        (cons (Allowed)
              (SlidingWindow (SlidingWindow-max-requests window)
                            (SlidingWindow-window-size window)
                            (cons current-time valid)))
        (let ((oldest (apply min valid)))
          (cons (Denied (- (+ oldest (SlidingWindow-window-size window))
                          current-time))
                (SlidingWindow (SlidingWindow-max-requests window)
                              (SlidingWindow-window-size window)
                              valid))))))

; ============================================================================
; MODULE 25: SAFE_CIRCUIT_BREAKER - Safe Circuit Breaker Operations
; ============================================================================

(define-module safe_circuit_breaker
  (description "Safe circuit breaker pattern for balanced ternary"))

; Circuit state
(define-type CircuitState
  (variant Closed)
  (variant Open)
  (variant HalfOpen))

; Circuit breaker
(define-type CircuitBreaker
  (state CircuitState)
  (failure-count Integer)
  (failure-threshold Integer)
  (success-threshold Integer)
  (success-count Integer)
  (timeout Integer)
  (last-failure-time Integer))

; Create circuit breaker
(define (circuit-breaker-create failure-threshold success-threshold timeout)
  (if (or (<= failure-threshold 0) (<= success-threshold 0) (<= timeout 0))
      (result-err 1 "Thresholds and timeout must be positive")
      (result-ok (CircuitBreaker (Closed) 0 failure-threshold success-threshold 0 timeout 0))))

; Check if request allowed
(define (circuit-breaker-allow? cb current-time)
  (match (CircuitBreaker-state cb)
    ((Closed) #t)
    ((HalfOpen) #t)
    ((Open)
     (>= (- current-time (CircuitBreaker-last-failure-time cb))
         (CircuitBreaker-timeout cb)))))

; Record success
(define (circuit-breaker-success cb)
  (match (CircuitBreaker-state cb)
    ((Closed) cb)
    ((HalfOpen)
     (let ((new-count (+ (CircuitBreaker-success-count cb) 1)))
       (if (>= new-count (CircuitBreaker-success-threshold cb))
           (CircuitBreaker (Closed) 0
                          (CircuitBreaker-failure-threshold cb)
                          (CircuitBreaker-success-threshold cb)
                          0 (CircuitBreaker-timeout cb) 0)
           (CircuitBreaker (HalfOpen) 0
                          (CircuitBreaker-failure-threshold cb)
                          (CircuitBreaker-success-threshold cb)
                          new-count (CircuitBreaker-timeout cb) 0))))
    ((Open) cb)))

; Record failure
(define (circuit-breaker-failure cb current-time)
  (match (CircuitBreaker-state cb)
    ((HalfOpen)
     (CircuitBreaker (Open) 0
                    (CircuitBreaker-failure-threshold cb)
                    (CircuitBreaker-success-threshold cb)
                    0 (CircuitBreaker-timeout cb) current-time))
    ((Closed)
     (let ((new-count (+ (CircuitBreaker-failure-count cb) 1)))
       (if (>= new-count (CircuitBreaker-failure-threshold cb))
           (CircuitBreaker (Open) 0
                          (CircuitBreaker-failure-threshold cb)
                          (CircuitBreaker-success-threshold cb)
                          0 (CircuitBreaker-timeout cb) current-time)
           (CircuitBreaker (Closed) new-count
                          (CircuitBreaker-failure-threshold cb)
                          (CircuitBreaker-success-threshold cb)
                          0 (CircuitBreaker-timeout cb) current-time))))
    ((Open) cb)))

; ============================================================================
; MODULE 26: SAFE_RETRY - Safe Retry Operations
; ============================================================================

(define-module safe_retry
  (description "Safe retry policies for balanced ternary"))

; Retry policy types
(define-type RetryPolicy
  (variant FixedDelay (delay Integer) (max-retries Integer))
  (variant ExponentialBackoff (initial-delay Integer) (max-delay Integer)
                              (multiplier Number) (max-retries Integer))
  (variant LinearBackoff (initial-delay Integer) (increment Integer)
                         (max-delay Integer) (max-retries Integer)))

; Calculate delay for attempt
(define (retry-delay policy attempt)
  (if (<= attempt 0)
      (result-err 1 "Attempt must be positive")
      (match policy
        ((FixedDelay delay max)
         (if (> attempt max)
             (option-none)
             (option-some delay)))
        ((ExponentialBackoff initial max mult max-retries)
         (if (> attempt max-retries)
             (option-none)
             (option-some (min max
                              (round (* initial (expt mult (- attempt 1))))))))
        ((LinearBackoff initial inc max max-retries)
         (if (> attempt max-retries)
             (option-none)
             (option-some (min max
                              (+ initial (* inc (- attempt 1))))))))))

; Check if should retry
(define (retry-should? policy attempt)
  (option-is-some (retry-delay policy attempt)))

; Create exponential backoff with jitter
(define (retry-with-jitter policy attempt jitter-factor)
  (let ((base-delay (option-unwrap-or (retry-delay policy attempt) 0)))
    (if (= base-delay 0)
        (option-none)
        (let ((jitter (* base-delay jitter-factor (- (* 2 (random)) 1))))
          (option-some (max 0 (round (+ base-delay jitter))))))))

; ============================================================================
; MODULE 27: SAFE_MONOTONIC - Safe Monotonic Counter Operations
; ============================================================================

(define-module safe_monotonic
  (description "Safe monotonic counter operations for balanced ternary"))

; Monotonic counter (can only increase)
(define-type MonotonicCounter
  (value Integer)
  (max-value Integer))

; Create monotonic counter
(define (monotonic-create initial max-value)
  (if (> initial max-value)
      (result-err 1 "Initial value exceeds maximum")
      (result-ok (MonotonicCounter initial max-value))))

; Increment counter
(define (monotonic-inc counter amount)
  (if (<= amount 0)
      (result-err 2 "Amount must be positive")
      (let ((new-value (+ (MonotonicCounter-value counter) amount)))
        (if (> new-value (MonotonicCounter-max-value counter))
            (result-err 3 "Would exceed maximum")
            (result-ok (MonotonicCounter new-value
                                         (MonotonicCounter-max-value counter)))))))

; Get current value
(define (monotonic-value counter)
  (MonotonicCounter-value counter))

; Check if at maximum
(define (monotonic-at-max? counter)
  (= (MonotonicCounter-value counter) (MonotonicCounter-max-value counter)))

; Monotonic timestamp
(define-type MonotonicTimestamp
  (epoch Integer)
  (sequence Integer))

; Create monotonic timestamp
(define (monotonic-timestamp-create epoch)
  (MonotonicTimestamp epoch 0))

; Next timestamp (guaranteed increasing)
(define (monotonic-timestamp-next ts current-epoch)
  (if (> current-epoch (MonotonicTimestamp-epoch ts))
      (MonotonicTimestamp current-epoch 0)
      (MonotonicTimestamp (MonotonicTimestamp-epoch ts)
                         (+ (MonotonicTimestamp-sequence ts) 1))))

; Compare timestamps
(define (monotonic-timestamp-compare a b)
  (cond ((> (MonotonicTimestamp-epoch a) (MonotonicTimestamp-epoch b)) P)
        ((< (MonotonicTimestamp-epoch a) (MonotonicTimestamp-epoch b)) N)
        ((> (MonotonicTimestamp-sequence a) (MonotonicTimestamp-sequence b)) P)
        ((< (MonotonicTimestamp-sequence a) (MonotonicTimestamp-sequence b)) N)
        (else Z)))

; ============================================================================
; MODULE 28: SAFE_STATE_MACHINE - Safe State Machine Operations
; ============================================================================

(define-module safe_state_machine
  (description "Safe state machine with validated transitions for balanced ternary"))

; State machine
(define-type StateMachine
  (current-state Any)
  (transitions (List (Pair Any (List Any))))
  (history (List Any))
  (max-history Integer))

; Create state machine
(define (state-machine-create initial-state)
  (StateMachine initial-state '() '() 100))

; Add valid transition
(define (state-machine-add-transition sm from to)
  (let ((existing (assoc from (StateMachine-transitions sm))))
    (StateMachine
     (StateMachine-current-state sm)
     (if existing
         (map (lambda (t)
                (if (equal? (car t) from)
                    (cons from (cons to (cdr t)))
                    t))
              (StateMachine-transitions sm))
         (cons (cons from (list to)) (StateMachine-transitions sm)))
     (StateMachine-history sm)
     (StateMachine-max-history sm))))

; Check if transition is valid
(define (state-machine-can-transition? sm to)
  (let ((valid (assoc (StateMachine-current-state sm)
                      (StateMachine-transitions sm))))
    (and valid (member to (cdr valid)))))

; Perform transition
(define (state-machine-transition sm to)
  (if (not (state-machine-can-transition? sm to))
      (result-err 1 "Invalid transition")
      (let* ((new-history (cons (StateMachine-current-state sm)
                               (StateMachine-history sm)))
             (trimmed (if (> (length new-history) (StateMachine-max-history sm))
                         (take new-history (StateMachine-max-history sm))
                         new-history)))
        (result-ok (StateMachine to
                                 (StateMachine-transitions sm)
                                 trimmed
                                 (StateMachine-max-history sm))))))

; Get valid transitions from current state
(define (state-machine-valid-transitions sm)
  (let ((valid (assoc (StateMachine-current-state sm)
                      (StateMachine-transitions sm))))
    (if valid (cdr valid) '())))

; ============================================================================
; MODULE 29: SAFE_CALCULATOR - Safe Calculator Operations
; ============================================================================

(define-module safe_calculator
  (description "Safe calculator with ternary display for balanced ternary"))

; Calculator state
(define-type Calculator
  (display Integer)
  (memory Integer)
  (pending-op (Option Symbol))
  (pending-value Integer))

; Create calculator
(define (calculator-create)
  (Calculator 0 0 (option-none) 0))

; Input digit
(define (calculator-digit calc digit)
  (if (or (< digit 0) (> digit 9))
      (result-err 1 "Invalid digit")
      (let ((new-display (+ (* (Calculator-display calc) 10) digit)))
        (if (> (abs new-display) WORD-MAX)
            (result-err 2 "Overflow")
            (result-ok (Calculator new-display
                                  (Calculator-memory calc)
                                  (Calculator-pending-op calc)
                                  (Calculator-pending-value calc)))))))

; Clear display
(define (calculator-clear calc)
  (Calculator 0
              (Calculator-memory calc)
              (option-none)
              0))

; All clear
(define (calculator-all-clear calc)
  (calculator-create))

; Set operation
(define (calculator-operation calc op)
  (Calculator 0
              (Calculator-memory calc)
              (option-some op)
              (Calculator-display calc)))

; Calculate result
(define (calculator-equals calc)
  (match (Calculator-pending-op calc)
    ((None) (result-ok calc))
    ((Some op)
     (let ((a (Calculator-pending-value calc))
           (b (Calculator-display calc)))
       (let ((result-val (cond ((eq? op '+) (safe-add a b))
                               ((eq? op '-) (safe-sub a b))
                               ((eq? op '*) (safe-mul a b))
                               ((eq? op '/) (safe-div a b))
                               (else (result-err 3 "Unknown operation")))))
         (if (result-is-err result-val)
             result-val
             (result-ok (Calculator (result-unwrap-or result-val 0)
                                   (Calculator-memory calc)
                                   (option-none)
                                   0))))))))

; Memory operations
(define (calculator-memory-store calc)
  (Calculator (Calculator-display calc)
              (Calculator-display calc)
              (Calculator-pending-op calc)
              (Calculator-pending-value calc)))

(define (calculator-memory-recall calc)
  (Calculator (Calculator-memory calc)
              (Calculator-memory calc)
              (Calculator-pending-op calc)
              (Calculator-pending-value calc)))

(define (calculator-memory-clear calc)
  (Calculator (Calculator-display calc)
              0
              (Calculator-pending-op calc)
              (Calculator-pending-value calc)))

; ============================================================================
; MODULE 30: SAFE_GEO - Safe Geographic Operations
; ============================================================================

(define-module safe_geo
  (description "Safe geographic coordinate operations for balanced ternary"))

(define EARTH-RADIUS-KM 6371.0)
(define EARTH-RADIUS-MI 3958.8)

; Geographic coordinate
(define-type Coordinate
  (lat Number)
  (lon Number))

; Validate coordinate
(define (valid-coordinate? lat lon)
  (and (>= lat -90.0) (<= lat 90.0)
       (>= lon -180.0) (<= lon 180.0)
       (not (nan? lat)) (not (nan? lon))))

; Create safe coordinate
(define (safe-coordinate lat lon)
  (if (valid-coordinate? lat lon)
      (result-ok (Coordinate lat lon))
      (result-err 1 "Invalid coordinates")))

; Convert to radians
(define (deg-to-rad deg) (* deg (/ PI 180)))
(define (rad-to-deg rad) (* rad (/ 180 PI)))

; Haversine distance
(define (haversine-distance c1 c2 radius)
  (let* ((lat1 (deg-to-rad (Coordinate-lat c1)))
         (lat2 (deg-to-rad (Coordinate-lat c2)))
         (dlat (deg-to-rad (- (Coordinate-lat c2) (Coordinate-lat c1))))
         (dlon (deg-to-rad (- (Coordinate-lon c2) (Coordinate-lon c1))))
         (a (+ (expt (sin (/ dlat 2)) 2)
               (* (cos lat1) (cos lat2) (expt (sin (/ dlon 2)) 2))))
         (c (* 2 (asin (sqrt a)))))
    (* radius c)))

; Distance in km
(define (distance-km c1 c2)
  (haversine-distance c1 c2 EARTH-RADIUS-KM))

; Distance in miles
(define (distance-mi c1 c2)
  (haversine-distance c1 c2 EARTH-RADIUS-MI))

; Bearing calculation
(define (bearing c1 c2)
  (let* ((lat1 (deg-to-rad (Coordinate-lat c1)))
         (lat2 (deg-to-rad (Coordinate-lat c2)))
         (dlon (deg-to-rad (- (Coordinate-lon c2) (Coordinate-lon c1))))
         (y (* (sin dlon) (cos lat2)))
         (x (- (* (cos lat1) (sin lat2))
               (* (sin lat1) (cos lat2) (cos dlon))))
         (brng (rad-to-deg (atan y x))))
    (remainder (+ brng 360) 360)))

; Bounding box
(define-type BoundingBox
  (min-lat Number)
  (min-lon Number)
  (max-lat Number)
  (max-lon Number))

; Create bounding box
(define (safe-bounding-box min-lat min-lon max-lat max-lon)
  (cond ((> min-lat max-lat)
         (result-err 1 "min-lat must be <= max-lat"))
        ((not (and (valid-coordinate? min-lat min-lon)
                   (valid-coordinate? max-lat max-lon)))
         (result-err 2 "Invalid coordinates"))
        (else
         (result-ok (BoundingBox min-lat min-lon max-lat max-lon)))))

; Check if coordinate in bounding box
(define (bbox-contains? bbox coord)
  (and (>= (Coordinate-lat coord) (BoundingBox-min-lat bbox))
       (<= (Coordinate-lat coord) (BoundingBox-max-lat bbox))
       (>= (Coordinate-lon coord) (BoundingBox-min-lon bbox))
       (<= (Coordinate-lon coord) (BoundingBox-max-lon bbox))))

; ============================================================================
; MODULE 31: SAFE_PROBABILITY - Safe Probability Operations
; ============================================================================

(define-module safe_probability
  (description "Safe probability calculations for balanced ternary"))

; Probability type (0.0 to 1.0)
(define-type Probability (value Number))

; Create safe probability
(define (safe-probability p)
  (cond ((< p 0.0) (result-err 1 "Probability cannot be negative"))
        ((> p 1.0) (result-err 2 "Probability cannot exceed 1.0"))
        ((nan? p) (result-err 3 "Probability cannot be NaN"))
        (else (result-ok (Probability p)))))

; Complement (1 - p)
(define (probability-complement p)
  (Probability (- 1.0 (Probability-value p))))

; AND (multiplication for independent events)
(define (probability-and p1 p2)
  (Probability (* (Probability-value p1) (Probability-value p2))))

; OR (union)
(define (probability-or p1 p2)
  (let ((v1 (Probability-value p1))
        (v2 (Probability-value p2)))
    (Probability (- (+ v1 v2) (* v1 v2)))))

; Conditional probability P(A|B) = P(A and B) / P(B)
(define (probability-conditional p-and-ab p-b)
  (if (< (Probability-value p-b) 1e-10)
      (result-err 4 "Division by zero probability")
      (safe-probability (/ (Probability-value p-and-ab)
                          (Probability-value p-b)))))

; Bayes theorem
(define (probability-bayes p-b-given-a p-a p-b)
  (probability-conditional (probability-and p-b-given-a p-a) p-b))

; Convert to ternary confidence (N, Z, P)
(define (probability-to-ternary p)
  (let ((v (Probability-value p)))
    (cond ((< v 0.33) N)
          ((< v 0.67) Z)
          (else P))))

; ============================================================================
; MODULE 32: SAFE_CHECKSUM - Safe Checksum Operations
; ============================================================================

(define-module safe_checksum
  (description "Safe checksum calculations for balanced ternary"))

; CRC-32 polynomial
(define CRC32-POLY #xEDB88320)

; Simple checksum (sum of bytes mod 256)
(define (checksum-simple data)
  (remainder (fold-left + 0 data) 256))

; Ternary checksum (sum of trits mod 3)
(define (checksum-ternary trits)
  (let ((sum (fold-left + 0 trits)))
    (let ((mod (remainder sum 3)))
      (cond ((= mod 0) Z)
            ((= mod 1) P)
            (else N)))))

; Luhn algorithm for digit validation
(define (checksum-luhn digits)
  (let* ((reversed (reverse digits))
         (doubled (map-indexed
                   (lambda (d i)
                     (if (= (remainder i 2) 1)
                         (let ((x (* d 2)))
                           (if (> x 9) (- x 9) x))
                         d))
                   reversed))
         (total (fold-left + 0 doubled)))
    (= (remainder total 10) 0)))

; Calculate Luhn check digit
(define (checksum-luhn-digit digits)
  (let* ((extended (append digits '(0)))
         (reversed (reverse extended))
         (doubled (map-indexed
                   (lambda (d i)
                     (if (= (remainder i 2) 1)
                         (let ((x (* d 2)))
                           (if (> x 9) (- x 9) x))
                         d))
                   reversed))
         (total (fold-left + 0 doubled)))
    (remainder (- 10 (remainder total 10)) 10)))

; Verify checksum
(define (checksum-verify data expected algorithm)
  (let ((computed (case algorithm
                    ((simple) (checksum-simple data))
                    ((ternary) (checksum-ternary data))
                    ((luhn) (if (checksum-luhn data) 1 0))
                    (else -1))))
    (= computed expected)))

; ============================================================================
; MODULE 33: SAFE_TENSOR - Safe Tensor Operations
; ============================================================================

(define-module safe_tensor
  (description "Safe tensor operations for balanced ternary"))

; Tensor shape
(define-type TensorShape (dims (List Integer)))

; Tensor
(define-type Tensor
  (shape TensorShape)
  (data (List Number)))

; Calculate total elements from shape
(define (shape-size shape)
  (fold-left * 1 (TensorShape-dims shape)))

; Create tensor with validation
(define (tensor-create shape data)
  (let ((expected-size (shape-size shape)))
    (if (not (= (length data) expected-size))
        (result-err 1 "Data size does not match shape")
        (result-ok (Tensor shape data)))))

; Create zeros tensor
(define (tensor-zeros shape)
  (Tensor shape (make-list (shape-size shape) 0)))

; Create ones tensor
(define (tensor-ones shape)
  (Tensor shape (make-list (shape-size shape) 1)))

; Get element at indices
(define (tensor-get tensor indices)
  (let ((shape (Tensor-shape tensor)))
    (if (not (= (length indices) (length (TensorShape-dims shape))))
        (result-err 2 "Index dimensions mismatch")
        (let ((flat-index (tensor-flat-index shape indices)))
          (if (< flat-index 0)
              (result-err 3 "Index out of bounds")
              (result-ok (list-ref (Tensor-data tensor) flat-index)))))))

; Calculate flat index from multi-dimensional indices
(define (tensor-flat-index shape indices)
  (let ((dims (TensorShape-dims shape)))
    (if (any (lambda (pair) (or (< (car pair) 0) (>= (car pair) (cdr pair))))
             (zip indices dims))
        -1
        (let loop ((idx indices) (dims-tail dims) (acc 0) (stride 1))
          (if (null? idx)
              acc
              (let ((new-stride (* stride (last dims-tail))))
                (loop (butlast idx)
                      (butlast dims-tail)
                      (+ acc (* (last idx) stride))
                      new-stride)))))))

; Element-wise operations
(define (tensor-add a b)
  (if (not (equal? (Tensor-shape a) (Tensor-shape b)))
      (result-err 4 "Shape mismatch")
      (result-ok (Tensor (Tensor-shape a)
                        (map + (Tensor-data a) (Tensor-data b))))))

(define (tensor-mul a b)
  (if (not (equal? (Tensor-shape a) (Tensor-shape b)))
      (result-err 4 "Shape mismatch")
      (result-ok (Tensor (Tensor-shape a)
                        (map * (Tensor-data a) (Tensor-data b))))))

; Scalar operations
(define (tensor-scale tensor scalar)
  (Tensor (Tensor-shape tensor)
          (map (lambda (x) (* x scalar)) (Tensor-data tensor))))

; Reshape tensor
(define (tensor-reshape tensor new-shape)
  (if (not (= (shape-size (Tensor-shape tensor)) (shape-size new-shape)))
      (result-err 5 "Cannot reshape: different total elements")
      (result-ok (Tensor new-shape (Tensor-data tensor)))))

; ============================================================================
; MODULE 34: SAFE_PASSWORD - Safe Password Operations
; ============================================================================

(define-module safe_password
  (description "Safe password handling for balanced ternary"))

(define PASSWORD-MIN-LEN 8)
(define PASSWORD-MAX-LEN 128)
(define SALT-LEN 16)

; Password strength levels (ternary)
(define-type PasswordStrength
  (variant Weak)     ; N
  (variant Medium)   ; Z
  (variant Strong))  ; P

; Check password strength
(define (password-strength password)
  (let* ((len (string-length password))
         (has-upper (string-any char-upper-case? password))
         (has-lower (string-any char-lower-case? password))
         (has-digit (string-any char-numeric? password))
         (has-special (string-any (lambda (c)
                                    (not (or (char-alphabetic? c)
                                            (char-numeric? c))))
                                  password))
         (score (+ (if (>= len 12) 1 0)
                  (if has-upper 1 0)
                  (if has-lower 1 0)
                  (if has-digit 1 0)
                  (if has-special 1 0))))
    (cond ((<= score 2) (Weak))
          ((<= score 3) (Medium))
          (else (Strong)))))

; Validate password
(define (password-validate password)
  (cond ((< (string-length password) PASSWORD-MIN-LEN)
         (result-err 1 "Password too short"))
        ((> (string-length password) PASSWORD-MAX-LEN)
         (result-err 2 "Password too long"))
        ((not (string-any char-upper-case? password))
         (result-err 3 "Password must contain uppercase"))
        ((not (string-any char-lower-case? password))
         (result-err 4 "Password must contain lowercase"))
        ((not (string-any char-numeric? password))
         (result-err 5 "Password must contain digit"))
        (else (result-ok password))))

; Check for common passwords (simplified)
(define COMMON-PASSWORDS '("password" "123456" "qwerty" "admin" "letmein"))

(define (password-is-common? password)
  (member (string-downcase password) COMMON-PASSWORDS))

; Strength to ternary
(define (password-strength-to-trit strength)
  (match strength
    ((Weak) N)
    ((Medium) Z)
    ((Strong) P)))

; ============================================================================
; MODULE 35: SAFE_ML - Safe Machine Learning Operations
; ============================================================================

(define-module safe_ml
  (description "Safe machine learning primitives for balanced ternary"))

; Activation functions with bounds
(define (sigmoid x)
  (/ 1.0 (+ 1.0 (exp (- x)))))

(define (relu x)
  (max 0.0 x))

(define (tanh-activation x)
  (tanh x))

; Bounded sigmoid (prevents extreme values)
(define (safe-sigmoid x)
  (let ((clamped (float-clamp x -500.0 500.0)))
    (/ 1.0 (+ 1.0 (exp (- clamped))))))

; Softmax with numerical stability
(define (safe-softmax values)
  (let* ((max-val (apply max values))
         (shifted (map (lambda (x) (- x max-val)) values))
         (exps (map exp shifted))
         (sum-exps (fold-left + 0.0 exps)))
    (if (< sum-exps 1e-10)
        (result-err 1 "Softmax denominator too small")
        (result-ok (map (lambda (e) (/ e sum-exps)) exps)))))

; Cross-entropy loss with epsilon for stability
(define (cross-entropy-loss predicted actual epsilon)
  (let ((clipped (map (lambda (p) (float-clamp p epsilon (- 1.0 epsilon)))
                      predicted)))
    (- (fold-left + 0.0
                 (map (lambda (p a) (* a (log p)))
                      clipped actual)))))

; Mean squared error
(define (mse-loss predicted actual)
  (let ((n (length predicted)))
    (if (not (= n (length actual)))
        (result-err 2 "Length mismatch")
        (result-ok (/ (fold-left + 0.0
                                 (map (lambda (p a) (expt (- p a) 2))
                                      predicted actual))
                      n)))))

; Gradient clipping
(define (clip-gradient gradient max-norm)
  (let ((norm (sqrt (fold-left + 0.0 (map (lambda (g) (* g g)) gradient)))))
    (if (<= norm max-norm)
        gradient
        (map (lambda (g) (* g (/ max-norm norm))) gradient))))

; Ternary quantization (for ternary neural networks)
(define (ternary-quantize value threshold)
  (cond ((< value (- threshold)) N)
        ((> value threshold) P)
        (else Z)))

; ============================================================================
; MODULE 36: SAFE_HEADER - Safe HTTP Header Operations
; ============================================================================

(define-module safe_header
  (description "Safe HTTP header operations for balanced ternary"))

(define HEADER-NAME-MAX 256)
(define HEADER-VALUE-MAX 8192)

; HTTP header
(define-type HTTPHeader
  (name String)
  (value String))

; Validate header name (RFC 7230)
(define (valid-header-name? name)
  (and (> (string-length name) 0)
       (<= (string-length name) HEADER-NAME-MAX)
       (string-all (lambda (c)
                     (and (>= (char->integer c) 33)
                          (<= (char->integer c) 126)
                          (not (member c '(#\( #\) #\< #\> #\@ #\, #\; #\:
                                          #\\ #\" #\/ #\[ #\] #\? #\= #\{ #\})))))
                   name)))

; Validate header value
(define (valid-header-value? value)
  (and (<= (string-length value) HEADER-VALUE-MAX)
       (not (string-any (lambda (c)
                          (or (= (char->integer c) 0)
                              (= (char->integer c) 10)
                              (= (char->integer c) 13)))
                        value))))

; Create safe header
(define (safe-header name value)
  (cond ((not (valid-header-name? name))
         (result-err 1 "Invalid header name"))
        ((not (valid-header-value? value))
         (result-err 2 "Invalid header value"))
        (else
         (result-ok (HTTPHeader name value)))))

; Parse header line
(define (parse-header-line line)
  (let ((colon-pos (string-index-of line #\:)))
    (if (< colon-pos 0)
        (result-err 3 "Missing colon in header")
        (let ((name (string-trim (substring line 0 colon-pos)))
              (value (string-trim (substring line (+ colon-pos 1)))))
          (safe-header name value)))))

; Header to string
(define (header-to-string header)
  (string-append (HTTPHeader-name header) ": " (HTTPHeader-value header)))

; Common security headers
(define (security-headers)
  (list (HTTPHeader "X-Content-Type-Options" "nosniff")
        (HTTPHeader "X-Frame-Options" "DENY")
        (HTTPHeader "X-XSS-Protection" "1; mode=block")
        (HTTPHeader "Strict-Transport-Security" "max-age=31536000; includeSubDomains")))

; ============================================================================
; MODULE 37: SAFE_COOKIE - Safe HTTP Cookie Operations
; ============================================================================

(define-module safe_cookie
  (description "Safe HTTP cookie operations for balanced ternary"))

(define COOKIE-NAME-MAX 256)
(define COOKIE-VALUE-MAX 4096)

; Cookie attributes
(define-type CookieAttributes
  (domain (Option String))
  (path (Option String))
  (expires (Option Integer))
  (max-age (Option Integer))
  (secure Boolean)
  (http-only Boolean)
  (same-site (Option String)))

; Cookie
(define-type Cookie
  (name String)
  (value String)
  (attributes CookieAttributes))

; Validate cookie name
(define (valid-cookie-name? name)
  (and (> (string-length name) 0)
       (<= (string-length name) COOKIE-NAME-MAX)
       (not (string-any (lambda (c)
                          (or (= (char->integer c) 0)
                              (member c '(#\( #\) #\< #\> #\@ #\, #\; #\:
                                         #\\ #\" #\/ #\[ #\] #\? #\= #\{ #\}
                                         #\space #\tab))))
                        name))))

; Validate cookie value
(define (valid-cookie-value? value)
  (and (<= (string-length value) COOKIE-VALUE-MAX)
       (not (string-any (lambda (c)
                          (or (= (char->integer c) 0)
                              (member c '(#\, #\; #\space #\tab))))
                        value))))

; Create default attributes
(define (default-cookie-attributes)
  (CookieAttributes (option-none) (option-none) (option-none)
                    (option-none) #f #f (option-none)))

; Create secure cookie attributes
(define (secure-cookie-attributes)
  (CookieAttributes (option-none) (option-some "/") (option-none)
                    (option-none) #t #t (option-some "Strict")))

; Create safe cookie
(define (safe-cookie name value attributes)
  (cond ((not (valid-cookie-name? name))
         (result-err 1 "Invalid cookie name"))
        ((not (valid-cookie-value? value))
         (result-err 2 "Invalid cookie value"))
        (else
         (result-ok (Cookie name value attributes)))))

; Cookie to Set-Cookie header value
(define (cookie-to-set-header cookie)
  (let ((base (string-append (Cookie-name cookie) "=" (Cookie-value cookie)))
        (attrs (Cookie-attributes cookie)))
    (string-append base
                   (if (CookieAttributes-secure attrs) "; Secure" "")
                   (if (CookieAttributes-http-only attrs) "; HttpOnly" "")
                   (option-fold (CookieAttributes-same-site attrs)
                               ""
                               (lambda (s) (string-append "; SameSite=" s)))
                   (option-fold (CookieAttributes-path attrs)
                               ""
                               (lambda (p) (string-append "; Path=" p))))))

; ============================================================================
; MODULE 38: SAFE_CONTENT_TYPE - Safe Content Type Operations
; ============================================================================

(define-module safe_content_type
  (description "Safe MIME content type operations for balanced ternary"))

; Content type structure
(define-type ContentType
  (type String)
  (subtype String)
  (parameters (List (Pair String String))))

; Common content types
(define CONTENT-TYPE-JSON "application/json")
(define CONTENT-TYPE-HTML "text/html")
(define CONTENT-TYPE-PLAIN "text/plain")
(define CONTENT-TYPE-XML "application/xml")
(define CONTENT-TYPE-FORM "application/x-www-form-urlencoded")
(define CONTENT-TYPE-MULTIPART "multipart/form-data")
(define CONTENT-TYPE-OCTET "application/octet-stream")

; Parse content type
(define (parse-content-type s)
  (let* ((parts (string-split s ";"))
         (main (string-trim (car parts)))
         (params (map (lambda (p)
                        (let ((kv (string-split (string-trim p) "=")))
                          (if (= (length kv) 2)
                              (cons (car kv) (cadr kv))
                              (cons (car kv) ""))))
                      (cdr parts)))
         (type-parts (string-split main "/")))
    (if (not (= (length type-parts) 2))
        (result-err 1 "Invalid content type format")
        (result-ok (ContentType (car type-parts)
                               (cadr type-parts)
                               params)))))

; Create content type
(define (safe-content-type type subtype)
  (if (or (string-null? type) (string-null? subtype))
      (result-err 2 "Type and subtype cannot be empty")
      (result-ok (ContentType type subtype '()))))

; Add parameter
(define (content-type-with-param ct name value)
  (ContentType (ContentType-type ct)
               (ContentType-subtype ct)
               (cons (cons name value) (ContentType-parameters ct))))

; Content type to string
(define (content-type-to-string ct)
  (let ((base (string-append (ContentType-type ct) "/" (ContentType-subtype ct))))
    (if (null? (ContentType-parameters ct))
        base
        (string-append base "; "
                       (string-join (map (lambda (p)
                                           (string-append (car p) "=" (cdr p)))
                                         (ContentType-parameters ct))
                                   "; ")))))

; Get charset parameter
(define (content-type-charset ct)
  (let ((found (assoc "charset" (ContentType-parameters ct))))
    (if found (option-some (cdr found)) (option-none))))

; Check if content type matches
(define (content-type-matches? ct type subtype)
  (and (or (string=? type "*") (string=? type (ContentType-type ct)))
       (or (string=? subtype "*") (string=? subtype (ContentType-subtype ct)))))

; Check if content type is text-based
(define (content-type-is-text? ct)
  (or (string=? (ContentType-type ct) "text")
      (and (string=? (ContentType-type ct) "application")
           (or (string=? (ContentType-subtype ct) "json")
               (string=? (ContentType-subtype ct) "xml")
               (string-ends-with? (ContentType-subtype ct) "+json")
               (string-ends-with? (ContentType-subtype ct) "+xml")))))

; ============================================================================
; TERNARY LOGIC GATES (Extended)
; ============================================================================

; Half-adder: returns (sum . carry)
(define (ternary-half-adder a b)
  (let ((sum (+ a b)))
    (cond ((= sum 2) (cons N P))
          ((= sum -2) (cons P N))
          (else (cons sum Z)))))

; Full-adder
(define (ternary-full-adder a b cin)
  (let ((sum (+ a b cin)))
    (cond ((>= sum 2) (cons (- sum 3) P))
          ((<= sum -2) (cons (+ sum 3) N))
          (else (cons sum Z)))))

; Ternary multiplexer
(define (ternary-mux select a b c)
  (cond ((= select N) a)
        ((= select Z) b)
        ((= select P) c)))

; ============================================================================
; BOUNDED TYPES
; ============================================================================

; Percentage (0-100)
(define (percentage-create n) (max 0 (min 100 n)))
(define (percentage-to-fraction p) (/ p 100.0))

; Resource bar
(define-type ResourceBar (current Integer) (maximum Integer))

(define (resource-create curr max-val)
  (let ((m (max 1 max-val)))
    (ResourceBar (max 0 (min m curr)) m)))

(define (resource-add rb amount)
  (resource-create (+ (resource-current rb) amount) (resource-maximum rb)))

(define (resource-empty? rb) (= (resource-current rb) 0))
(define (resource-full? rb) (= (resource-current rb) (resource-maximum rb)))

; ============================================================================
; VECTOR2
; ============================================================================

(define-type TernaryVec2 (x Integer) (y Integer))

(define (tvec2-create x y) (TernaryVec2 (tryte-clamp x) (tryte-clamp y)))
(define (tvec2-add a b) (tvec2-create (+ (tvec2-x a) (tvec2-x b))
                                       (+ (tvec2-y a) (tvec2-y b))))
(define (tvec2-sub a b) (tvec2-create (- (tvec2-x a) (tvec2-x b))
                                       (- (tvec2-y a) (tvec2-y b))))
(define (tvec2-neg v) (tvec2-create (- (tvec2-x v)) (- (tvec2-y v))))

; Manhattan distance
(define (tvec2-manhattan a b)
  (+ (abs (- (tvec2-x a) (tvec2-x b)))
     (abs (- (tvec2-y a) (tvec2-y b)))))

; ============================================================================
; SETUN COMPATIBILITY
; ============================================================================

; Setun used 9-trit words (-9841 to +9841)
(define SETUN-MIN -9841)
(define SETUN-MAX  9841)

(define (setun-word-from-int n)
  (cond ((< n SETUN-MIN) (result-err 1 "Below Setun range"))
        ((> n SETUN-MAX) (result-err 2 "Above Setun range"))
        (else (result-ok n))))

; Setun address (5 trits, -121 to +121)
(define SETUN-ADDR-MIN -121)
(define SETUN-ADDR-MAX  121)

(define (setun-addr-valid? n)
  (and (>= n SETUN-ADDR-MIN) (<= n SETUN-ADDR-MAX)))

; ============================================================================
; UTILITY
; ============================================================================

; Convert int to ternary string (N/Z/P notation)
(define (int-to-ternary-string n width)
  (letrec ((convert (lambda (v acc count)
    (if (= count width) (list->string (reverse acc))
        (let* ((rem (modulo (+ v 1) 3))
               (trit (- rem 1))
               (next (quotient (+ v 1 (- trit)) 3))
               (ch (cond ((= trit -1) #\N) ((= trit 0) #\Z) (else #\P))))
          (convert next (cons ch acc) (+ count 1)))))))
    (convert n '() 0)))

; Parse ternary string to int
(define (ternary-string-to-int s)
  (let ((chars (string->list s)))
    (fold-left (lambda (acc c)
                 (let ((trit (cond ((char=? c #\N) -1)
                                  ((char=? c #\Z) 0)
                                  ((char=? c #\P) 1)
                                  (else 0))))
                   (+ (* acc 3) trit)))
               0
               chars)))

; ============================================================================
; MODULE EXPORTS
; ============================================================================

(define-exports
  ; Library info
  VERSION MODULE_COUNT MODULES

  ; Core types
  Result Option Trit
  result-ok result-err result-is-ok result-is-err result-unwrap-or result-map
  option-some option-none option-is-some option-is-none option-unwrap-or option-map

  ; Trit operations
  trit-neg trit-and trit-or trit-xor trit-mul trit-consensus

  ; Tryte and Word
  TRYTE-MIN TRYTE-MAX tryte-from-int tryte-clamp tryte-valid?
  WORD-MIN WORD-MAX word-from-int word-clamp

  ; All 38 modules
  safe_math safe_string safe_path safe_email safe_url
  safe_network safe_crypto safe_uuid safe_currency safe_phone safe_hex
  safe_json safe_datetime safe_float safe_version safe_color safe_angle safe_unit
  safe_buffer safe_queue safe_bloom safe_lru safe_graph
  safe_rate_limiter safe_circuit_breaker safe_retry safe_monotonic
  safe_state_machine safe_calculator
  safe_geo safe_probability safe_checksum safe_tensor
  safe_password safe_ml
  safe_header safe_cookie safe_content_type

  ; Ternary logic
  ternary-half-adder ternary-full-adder ternary-mux

  ; Bounded types
  percentage-create percentage-to-fraction
  ResourceBar resource-create resource-add resource-empty? resource-full?

  ; Vectors
  TernaryVec2 tvec2-create tvec2-add tvec2-sub tvec2-neg tvec2-manhattan

  ; Setun compatibility
  SETUN-MIN SETUN-MAX setun-word-from-int
  SETUN-ADDR-MIN SETUN-ADDR-MAX setun-addr-valid?

  ; Utility
  int-to-ternary-string ternary-string-to-int)
