* SPDX-License-Identifier: PMPL-1.0
* Proven - Safety primitives for SPICE analog circuit simulation
*
* Safe subcircuits for analog computing including bounded sources,
* protected op-amps, and safe computation blocks for all 38 proven modules.
*
* Compatible with: ngspice, LTspice, HSPICE, PSpice

* ============================================================================
* LIBRARY METADATA
* ============================================================================

.PARAM VERSION="0.4.0"
.PARAM MODULE_COUNT=38

* ============================================================================
* GLOBAL PARAMETERS
* ============================================================================

.PARAM proven_vdd=5.0
.PARAM proven_vss=0.0
.PARAM proven_vmax=10.0
.PARAM proven_vmin=-10.0
.PARAM proven_imax=100m
.PARAM proven_epsilon=1n

* ============================================================================
* MODULE CATEGORY: CORE (11 modules)
* ============================================================================

* ----------------------------------------------------------------------------
* 1. SAFE_MATH - Safe bounded arithmetic operations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_math_add in1 in2 out vmin=-10 vmax=10
* Safe addition with output clamping
Bsum out 0 V = MIN(MAX(V(in1) + V(in2), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_math_sub in1 in2 out vmin=-10 vmax=10
* Safe subtraction with output clamping
Bdiff out 0 V = MIN(MAX(V(in1) - V(in2), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_math_mul in1 in2 out scale=10 vmin=-10 vmax=10
* Safe multiplication with scaling and clamping
Bprod out 0 V = MIN(MAX(V(in1) * V(in2) / {scale}, {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_math_div in1 in2 out scale=1 vmin=-10 vmax=10 divisor_min=0.1
* Safe division with divide-by-zero protection
Bdiv_safe div_safe 0 V = IF(ABS(V(in2)) < {divisor_min}, SIGN(V(in2)+1n)*{divisor_min}, V(in2))
Bquot out 0 V = MIN(MAX(V(in1) / V(div_safe) * {scale}, {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_math_abs in out vmax=10
* Safe absolute value with clamping
Babs out 0 V = MIN(ABS(V(in)), {vmax})
.ENDS

.SUBCKT proven_safe_math_clamp in out vmin=-10 vmax=10
* Clamp value to range
Bclamp out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_math_pow in exp out vmin=-10 vmax=10
* Safe power with clamping (uses voltage as exponent approximation)
Bpow out 0 V = MIN(MAX(PWR(ABS(V(in))+1n, V(exp)) * SIGN(V(in)), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_math_sqrt in out vmax=10
* Safe square root (non-negative input enforced)
Bsqrt out 0 V = MIN(IF(V(in) > 0, SQRT(V(in)), 0), {vmax})
.ENDS

.SUBCKT proven_safe_math_exp in out scale=1 vmax=10
* Safe exponential with saturation
Bexp out 0 V = MIN(EXP(V(in) / {scale}), {vmax})
.ENDS

.SUBCKT proven_safe_math_log in out in_min=1m vmin=-10
* Safe logarithm with minimum input protection
Blog out 0 V = MAX(IF(V(in) > {in_min}, LOG(V(in)), LOG({in_min})), {vmin})
.ENDS

* ----------------------------------------------------------------------------
* 2. SAFE_STRING - String length and validation (analog encoding)
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_string_length pulse_in out vmax=255
* Count pulses representing string characters
* Each pulse above threshold counts as one character
Ccount count 0 1 IC=0
Scharge pulse_in count pulse_in 0 SW_PULSE
.MODEL SW_PULSE SW VT=2.5 RON=1k ROFF=1MEG
Blength out 0 V = MIN(V(count), {vmax})
.ENDS

.SUBCKT proven_safe_string_valid in out vhigh=5 vlow=0 min_v=0 max_v=127
* Validate analog signal represents valid character range
Bvalid out 0 V = IF(V(in) >= {min_v} & V(in) <= {max_v}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_string_compare in1 in2 out vhigh=5 vlow=0 tolerance=0.1
* Compare two analog values (string character comparison)
Bcompare out 0 V = IF(ABS(V(in1) - V(in2)) < {tolerance}, {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 3. SAFE_PATH - Path validation circuits
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_path_valid in out vhigh=5 vlow=0 max_depth=10
* Validate path depth (encoded as voltage level)
Bdepth out 0 V = IF(V(in) >= 0 & V(in) <= {max_depth}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_path_normalize in out vmin=0 vmax=10
* Normalize path representation to valid range
Bnorm out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_path_join in1 in2 out vmax=20
* Join two path segments (additive with saturation)
Bjoin out 0 V = MIN(V(in1) + V(in2), {vmax})
.ENDS

* ----------------------------------------------------------------------------
* 4. SAFE_EMAIL - Email validation circuits
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_email_valid in_local in_domain out vhigh=5 vlow=0
* Validate email components are in valid ranges
Blocal local_ok 0 V = IF(V(in_local) > 0 & V(in_local) <= 64, 1, 0)
Bdomain domain_ok 0 V = IF(V(in_domain) > 0 & V(in_domain) <= 255, 1, 0)
Bvalid out 0 V = IF(V(local_ok) > 0.5 & V(domain_ok) > 0.5, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_email_normalize in out vmin=0 vmax=64
* Normalize email local part length
Bnorm out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

* ----------------------------------------------------------------------------
* 5. SAFE_URL - URL validation and parsing circuits
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_url_valid in_scheme in_host in_port out vhigh=5 vlow=0
* Validate URL components
Bscheme scheme_ok 0 V = IF(V(in_scheme) > 0, 1, 0)
Bhost host_ok 0 V = IF(V(in_host) > 0, 1, 0)
Bport port_ok 0 V = IF(V(in_port) >= 0 & V(in_port) <= 65535, 1, 0)
Bvalid out 0 V = IF(V(scheme_ok)*V(host_ok)*V(port_ok) > 0.5, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_url_port_clamp in out vmin=0 vmax=65535
* Clamp port number to valid range
Bclamp out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

* ----------------------------------------------------------------------------
* 6. SAFE_NETWORK - Network parameter validation
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_network_ip4_valid in out vhigh=5 vlow=0
* Validate IPv4 octet (0-255)
Bvalid out 0 V = IF(V(in) >= 0 & V(in) <= 255, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_network_port_valid in out vhigh=5 vlow=0
* Validate port range
Bvalid out 0 V = IF(V(in) >= 0 & V(in) <= 65535, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_network_timeout in out min_t=0 max_t=30
* Clamp timeout value to safe range
Btimeout out 0 V = MIN(MAX(V(in), {min_t}), {max_t})
.ENDS

.SUBCKT proven_safe_network_rate_limit in rate_limit out vhigh=5 vlow=0
* Check if rate is within limit
Blimit out 0 V = IF(V(in) <= V(rate_limit), {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 7. SAFE_CRYPTO - Cryptographic safety primitives
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_crypto_key_strength in out vhigh=5 vlow=0 min_bits=128
* Validate key strength (voltage represents bit count)
Bstrength out 0 V = IF(V(in) >= {min_bits}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_crypto_entropy_check in out vhigh=5 vlow=0 threshold=0.5
* Check if entropy meets threshold
Bentropy out 0 V = IF(V(in) >= {threshold}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_crypto_hash_compare in1 in2 out vhigh=5 vlow=0 tolerance=1m
* Constant-time hash comparison (analog approximation)
Rdel1 in1 del1 1k
Cdel1 del1 0 1n
Rdel2 in2 del2 1k
Cdel2 del2 0 1n
Bcompare out 0 V = IF(ABS(V(del1) - V(del2)) < {tolerance}, {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 8. SAFE_UUID - UUID generation and validation
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_uuid_valid in_hi in_lo out vhigh=5 vlow=0
* Validate UUID components (non-zero check)
Bvalid out 0 V = IF(ABS(V(in_hi)) > 1m | ABS(V(in_lo)) > 1m, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_uuid_version in out vhigh=5 vlow=0 expected=4
* Check UUID version (encoded as voltage)
Bversion out 0 V = IF(ABS(V(in) - {expected}) < 0.5, {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 9. SAFE_CURRENCY - Currency calculation safety
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_currency_add in1 in2 out vmin=-1e9 vmax=1e9
* Safe currency addition with overflow protection
Bsum out 0 V = MIN(MAX(V(in1) + V(in2), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_currency_round in out precision=0.01
* Round to currency precision
Bround out 0 V = INT(V(in) / {precision} + 0.5) * {precision}
.ENDS

.SUBCKT proven_safe_currency_convert in rate out vmin=-1e9 vmax=1e9 rate_min=1e-6
* Safe currency conversion with rate validation
Brate_safe rate_safe 0 V = IF(ABS(V(rate)) < {rate_min}, {rate_min}, V(rate))
Bconvert out 0 V = MIN(MAX(V(in) * V(rate_safe), {vmin}), {vmax})
.ENDS

* ----------------------------------------------------------------------------
* 10. SAFE_PHONE - Phone number validation
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_phone_valid in out vhigh=5 vlow=0 min_digits=7 max_digits=15
* Validate phone number digit count
Bvalid out 0 V = IF(V(in) >= {min_digits} & V(in) <= {max_digits}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_phone_country_code in out vmin=1 vmax=999
* Validate and clamp country code
Bclamp out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

* ----------------------------------------------------------------------------
* 11. SAFE_HEX - Hexadecimal encoding safety
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_hex_valid in out vhigh=5 vlow=0
* Validate hex digit (0-15 range)
Bvalid out 0 V = IF(V(in) >= 0 & V(in) <= 15, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_hex_encode in out vmax=15
* Encode value as hex digit
Bhex out 0 V = MIN(MAX(INT(V(in)), 0), {vmax})
.ENDS

.SUBCKT proven_safe_hex_decode in out vmax=255
* Decode hex pair to byte
Bdecode out 0 V = MIN(MAX(V(in), 0), {vmax})
.ENDS

* ============================================================================
* MODULE CATEGORY: DATA (7 modules)
* ============================================================================

* ----------------------------------------------------------------------------
* 12. SAFE_JSON - JSON structure validation
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_json_depth in out vhigh=5 vlow=0 max_depth=32
* Validate JSON nesting depth
Bdepth out 0 V = IF(V(in) >= 0 & V(in) <= {max_depth}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_json_size in out vhigh=5 vlow=0 max_size=1e6
* Validate JSON size
Bsize out 0 V = IF(V(in) >= 0 & V(in) <= {max_size}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_json_array_length in out vmax=1000
* Clamp array length to safe maximum
Blen out 0 V = MIN(MAX(V(in), 0), {vmax})
.ENDS

* ----------------------------------------------------------------------------
* 13. SAFE_DATETIME - Date/time validation
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_datetime_hour in out vmin=0 vmax=23
* Validate and clamp hour
Bhour out 0 V = MIN(MAX(INT(V(in)), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_datetime_minute in out vmin=0 vmax=59
* Validate and clamp minute
Bmin out 0 V = MIN(MAX(INT(V(in)), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_datetime_second in out vmin=0 vmax=59
* Validate and clamp second
Bsec out 0 V = MIN(MAX(INT(V(in)), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_datetime_day in month out vmin=1 vmax=31
* Validate day for month (simplified - max 31)
Bday out 0 V = MIN(MAX(INT(V(in)), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_datetime_month in out vmin=1 vmax=12
* Validate and clamp month
Bmonth out 0 V = MIN(MAX(INT(V(in)), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_datetime_year in out vmin=1 vmax=9999
* Validate year range
Byear out 0 V = MIN(MAX(INT(V(in)), {vmin}), {vmax})
.ENDS

* ----------------------------------------------------------------------------
* 14. SAFE_FLOAT - Floating point safety
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_float_finite in out vhigh=5 vlow=0 vmax=1e38
* Check if value is finite
Bfinite out 0 V = IF(ABS(V(in)) < {vmax}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_float_clamp in out vmin=-1e38 vmax=1e38
* Clamp to finite range
Bclamp out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_float_epsilon_compare in1 in2 out vhigh=5 vlow=0 epsilon=1e-9
* Compare with epsilon tolerance
Bcompare out 0 V = IF(ABS(V(in1) - V(in2)) < {epsilon}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_float_normalize in out vmin=-1 vmax=1
* Normalize to -1 to 1 range
Brange range 0 V = MAX(ABS({vmin}), ABS({vmax}))
Bnorm out 0 V = V(in) / (V(range) + 1n)
.ENDS

* ----------------------------------------------------------------------------
* 15. SAFE_VERSION - Semantic versioning
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_version_compare v1_major v1_minor v1_patch v2_major v2_minor v2_patch out
* Compare semantic versions: out > 0 if v1 > v2, < 0 if v1 < v2, 0 if equal
Bmajor_diff major_diff 0 V = V(v1_major) - V(v2_major)
Bminor_diff minor_diff 0 V = V(v1_minor) - V(v2_minor)
Bpatch_diff patch_diff 0 V = V(v1_patch) - V(v2_patch)
Bcompare out 0 V = IF(V(major_diff) != 0, V(major_diff),
+                     IF(V(minor_diff) != 0, V(minor_diff), V(patch_diff)))
.ENDS

.SUBCKT proven_safe_version_valid major minor patch out vhigh=5 vlow=0
* Validate version components are non-negative
Bvalid out 0 V = IF(V(major) >= 0 & V(minor) >= 0 & V(patch) >= 0, {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 16. SAFE_COLOR - Color space safety
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_color_rgb in_r in_g in_b out_r out_g out_b vmin=0 vmax=255
* Clamp RGB values to valid range
Br out_r 0 V = MIN(MAX(V(in_r), {vmin}), {vmax})
Bg out_g 0 V = MIN(MAX(V(in_g), {vmin}), {vmax})
Bb out_b 0 V = MIN(MAX(V(in_b), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_color_hsv_hue in out vmin=0 vmax=360
* Clamp and wrap hue value
Bhue out 0 V = V(in) - INT(V(in) / {vmax}) * {vmax}
.ENDS

.SUBCKT proven_safe_color_alpha in out vmin=0 vmax=1
* Clamp alpha channel
Balpha out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_color_blend in1 in2 alpha out vmin=0 vmax=255
* Blend two colors with alpha
Balpha_clamp alpha_c 0 V = MIN(MAX(V(alpha), 0), 1)
Bblend out 0 V = MIN(MAX(V(in1) * (1 - V(alpha_c)) + V(in2) * V(alpha_c), {vmin}), {vmax})
.ENDS

* ----------------------------------------------------------------------------
* 17. SAFE_ANGLE - Angular measurement safety
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_angle_degrees in out vmin=0 vmax=360
* Normalize angle to 0-360 degrees
Bnorm out 0 V = V(in) - INT(V(in) / {vmax}) * {vmax}
.ENDS

.SUBCKT proven_safe_angle_radians in out vmax=6.28318530718
* Normalize angle to 0-2*pi radians
Bnorm out 0 V = V(in) - INT(V(in) / {vmax}) * {vmax}
.ENDS

.SUBCKT proven_safe_angle_deg_to_rad in out
* Convert degrees to radians
Bconv out 0 V = V(in) * 0.01745329252
.ENDS

.SUBCKT proven_safe_angle_rad_to_deg in out
* Convert radians to degrees
Bconv out 0 V = V(in) * 57.2957795131
.ENDS

.SUBCKT proven_safe_angle_sin in out
* Safe sine function
Bsin out 0 V = SIN(V(in))
.ENDS

.SUBCKT proven_safe_angle_cos in out
* Safe cosine function
Bcos out 0 V = COS(V(in))
.ENDS

* ----------------------------------------------------------------------------
* 18. SAFE_UNIT - Unit conversion safety
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_unit_convert in factor offset out vmin=-1e38 vmax=1e38
* Safe unit conversion: out = in * factor + offset
Bconv out 0 V = MIN(MAX(V(in) * V(factor) + V(offset), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_unit_si_prefix in prefix_exp out
* Apply SI prefix (prefix_exp: -12 to 12 for pico to tera)
Bprefix out 0 V = V(in) * PWR(10, V(prefix_exp))
.ENDS

* ============================================================================
* MODULE CATEGORY: DATA STRUCTURES (5 modules)
* ============================================================================

* ----------------------------------------------------------------------------
* 19. SAFE_BUFFER - Circular buffer operations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_buffer_write data write_ptr size out_ptr vmin=0
* Safe buffer write with wrap-around
Bnext out_ptr 0 V = IF(V(write_ptr) + 1 >= V(size), {vmin}, V(write_ptr) + 1)
.ENDS

.SUBCKT proven_safe_buffer_read read_ptr size valid out_valid vhigh=5 vlow=0
* Validate buffer read pointer
Bvalid out_valid 0 V = IF(V(read_ptr) >= 0 & V(read_ptr) < V(size) & V(valid) > 0.5, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_buffer_full write_ptr read_ptr size out vhigh=5 vlow=0
* Check if buffer is full
Bnext next 0 V = IF(V(write_ptr) + 1 >= V(size), 0, V(write_ptr) + 1)
Bfull out 0 V = IF(ABS(V(next) - V(read_ptr)) < 0.5, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_buffer_empty write_ptr read_ptr out vhigh=5 vlow=0
* Check if buffer is empty
Bempty out 0 V = IF(ABS(V(write_ptr) - V(read_ptr)) < 0.5, {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 20. SAFE_QUEUE - Queue operations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_queue_enqueue head tail size out_tail overflow vhigh=5 vlow=0
* Safe enqueue with overflow detection
Bnext next 0 V = IF(V(tail) + 1 >= V(size), 0, V(tail) + 1)
Boverflow overflow 0 V = IF(ABS(V(next) - V(head)) < 0.5, {vhigh}, {vlow})
Btail out_tail 0 V = IF(V(overflow) > 0.5, V(tail), V(next))
.ENDS

.SUBCKT proven_safe_queue_dequeue head tail size out_head underflow vhigh=5 vlow=0
* Safe dequeue with underflow detection
Bempty empty 0 V = IF(ABS(V(head) - V(tail)) < 0.5, 1, 0)
Bunderflow underflow 0 V = IF(V(empty) > 0.5, {vhigh}, {vlow})
Bnext next 0 V = IF(V(head) + 1 >= V(size), 0, V(head) + 1)
Bhead out_head 0 V = IF(V(empty) > 0.5, V(head), V(next))
.ENDS

.SUBCKT proven_safe_queue_size head tail capacity out
* Calculate queue size
Bsize out 0 V = IF(V(tail) >= V(head), V(tail) - V(head), V(capacity) - V(head) + V(tail))
.ENDS

* ----------------------------------------------------------------------------
* 21. SAFE_BLOOM - Bloom filter operations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_bloom_hash in seed out vmax=1023
* Simple hash function for bloom filter index
Bhash out 0 V = ABS(INT((V(in) * V(seed) * 2654435761) - INT(V(in) * V(seed) * 2654435761 / {vmax}) * {vmax}))
.ENDS

.SUBCKT proven_safe_bloom_fp_rate n m k out
* Estimate false positive rate: (1 - e^(-k*n/m))^k
* n = items, m = bits, k = hash functions
Bexp exp_term 0 V = EXP(-V(k) * V(n) / (V(m) + 1n))
Bfp out 0 V = PWR(1 - V(exp_term), V(k))
.ENDS

* ----------------------------------------------------------------------------
* 22. SAFE_LRU - LRU cache operations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_lru_access time_in age_out vmax=1e9
* Update access time with overflow protection
Bage age_out 0 V = MIN(V(time_in), {vmax})
.ENDS

.SUBCKT proven_safe_lru_evict age1 age2 select_out vhigh=5 vlow=0
* Select older entry for eviction (lower age = older)
Bselect select_out 0 V = IF(V(age1) < V(age2), {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_lru_full count capacity out vhigh=5 vlow=0
* Check if cache is full
Bfull out 0 V = IF(V(count) >= V(capacity), {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 23. SAFE_GRAPH - Graph operations safety
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_graph_edge_valid src dst node_count out vhigh=5 vlow=0
* Validate edge endpoints
Bvalid out 0 V = IF(V(src) >= 0 & V(src) < V(node_count) & V(dst) >= 0 & V(dst) < V(node_count), {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_graph_weight in out vmin=0 vmax=1e6
* Clamp edge weight to valid range
Bweight out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_graph_degree in out vmax=1000
* Clamp node degree
Bdegree out 0 V = MIN(MAX(V(in), 0), {vmax})
.ENDS

.SUBCKT proven_safe_graph_path_length in out vmax=1e9
* Clamp path length (for shortest path algorithms)
Blen out 0 V = MIN(MAX(V(in), 0), {vmax})
.ENDS

* ============================================================================
* MODULE CATEGORY: RESILIENCE (4 modules)
* ============================================================================

* ----------------------------------------------------------------------------
* 24. SAFE_RATE_LIMITER - Rate limiting circuits
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_rate_limiter request tokens out_allow out_tokens vhigh=5 vlow=0 bucket_max=10
* Token bucket rate limiter
Bhas_tokens has_tokens 0 V = IF(V(tokens) >= 1, 1, 0)
Ballow out_allow 0 V = IF(V(request) > 0.5 & V(has_tokens) > 0.5, {vhigh}, {vlow})
Bnew_tokens out_tokens 0 V = IF(V(out_allow) > 0.5, MAX(V(tokens) - 1, 0), V(tokens))
.ENDS

.SUBCKT proven_safe_rate_limiter_refill tokens refill_rate dt out vmax=100
* Refill tokens over time
Brefill out 0 V = MIN(V(tokens) + V(refill_rate) * V(dt), {vmax})
.ENDS

* ----------------------------------------------------------------------------
* 25. SAFE_CIRCUIT_BREAKER - Circuit breaker pattern
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_circuit_breaker failures threshold state_in state_out vopen=2 vhalf=1 vclosed=0
* Circuit breaker state machine
* States: 0=closed, 1=half-open, 2=open
Btrip trip 0 V = IF(V(failures) >= V(threshold), 1, 0)
Bstate state_out 0 V = IF(V(state_in) < 0.5 & V(trip) > 0.5, {vopen},
+                        IF(V(state_in) > 1.5, {vhalf}, V(state_in)))
.ENDS

.SUBCKT proven_safe_circuit_breaker_allow state out vhigh=5 vlow=0
* Check if requests are allowed (closed or half-open)
Ballow out 0 V = IF(V(state) < 1.5, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_circuit_breaker_reset success state_in state_out vclosed=0
* Reset to closed on success in half-open state
Breset state_out 0 V = IF(V(state_in) > 0.5 & V(state_in) < 1.5 & V(success) > 0.5, {vclosed}, V(state_in))
.ENDS

* ----------------------------------------------------------------------------
* 26. SAFE_RETRY - Retry logic with backoff
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_retry_backoff attempt base_delay out vmax=60
* Exponential backoff delay calculation
Bdelay out 0 V = MIN(V(base_delay) * PWR(2, V(attempt)), {vmax})
.ENDS

.SUBCKT proven_safe_retry_jitter delay jitter_pct noise out vmin=0
* Add jitter to delay
Bjitter jitter 0 V = V(delay) * V(jitter_pct) * V(noise)
Bout out 0 V = MAX(V(delay) + V(jitter), {vmin})
.ENDS

.SUBCKT proven_safe_retry_should attempt max_attempts out vhigh=5 vlow=0
* Check if retry should be attempted
Bshould out 0 V = IF(V(attempt) < V(max_attempts), {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 27. SAFE_MONOTONIC - Monotonic sequence operations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_monotonic_next current out vmax=1e18
* Generate next monotonic value
Bnext out 0 V = MIN(V(current) + 1, {vmax})
.ENDS

.SUBCKT proven_safe_monotonic_valid prev current out vhigh=5 vlow=0
* Validate monotonic ordering
Bvalid out 0 V = IF(V(current) > V(prev), {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_monotonic_timestamp time_in counter out vmax=1e18
* Combine timestamp with counter for unique monotonic ID
Bcombine out 0 V = MIN(V(time_in) * 1000 + V(counter), {vmax})
.ENDS

* ============================================================================
* MODULE CATEGORY: STATE (2 modules)
* ============================================================================

* ----------------------------------------------------------------------------
* 28. SAFE_STATE_MACHINE - State machine operations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_state_machine state_in event transition_table_valid state_out verror=-1
* State transition with validation
Bvalid valid 0 V = V(transition_table_valid)
Btrans state_out 0 V = IF(V(valid) > 0.5, V(event), {verror})
.ENDS

.SUBCKT proven_safe_state_machine_valid state max_state out vhigh=5 vlow=0
* Validate state is in valid range
Bvalid out 0 V = IF(V(state) >= 0 & V(state) <= V(max_state), {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_state_machine_init initial_state out
* Initialize state machine
Binit out 0 V = V(initial_state)
.ENDS

* ----------------------------------------------------------------------------
* 29. SAFE_CALCULATOR - Calculator stack operations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_calculator_push value sp max_sp out_sp overflow vhigh=5 vlow=0
* Push with stack overflow check
Boverflow overflow 0 V = IF(V(sp) >= V(max_sp), {vhigh}, {vlow})
Bout_sp out_sp 0 V = IF(V(overflow) < 0.5, V(sp) + 1, V(sp))
.ENDS

.SUBCKT proven_safe_calculator_pop sp out_sp underflow vhigh=5 vlow=0
* Pop with stack underflow check
Bunderflow underflow 0 V = IF(V(sp) <= 0, {vhigh}, {vlow})
Bout_sp out_sp 0 V = IF(V(underflow) < 0.5, V(sp) - 1, V(sp))
.ENDS

.SUBCKT proven_safe_calculator_binop a b op out vmin=-1e38 vmax=1e38
* Binary operation: op=0:add, 1:sub, 2:mul, 3:div
Badd add 0 V = V(a) + V(b)
Bsub sub 0 V = V(a) - V(b)
Bmul mul 0 V = V(a) * V(b)
Bdiv_safe div_safe 0 V = IF(ABS(V(b)) < 1n, SIGN(V(b)+1n)*1n, V(b))
Bdiv div 0 V = V(a) / V(div_safe)
Bselect out 0 V = MIN(MAX(IF(V(op) < 0.5, V(add),
+                            IF(V(op) < 1.5, V(sub),
+                            IF(V(op) < 2.5, V(mul), V(div)))), {vmin}), {vmax})
.ENDS

* ============================================================================
* MODULE CATEGORY: ALGORITHM (4 modules)
* ============================================================================

* ----------------------------------------------------------------------------
* 30. SAFE_GEO - Geographic calculations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_geo_lat in out vmin=-90 vmax=90
* Clamp latitude to valid range
Blat out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_geo_lon in out vmin=-180 vmax=180
* Clamp and wrap longitude
Blon out 0 V = V(in) - INT((V(in) + 180) / 360) * 360
.ENDS

.SUBCKT proven_safe_geo_distance lat1 lon1 lat2 lon2 out
* Haversine distance approximation (simplified for analog)
* Using small angle approximation for demonstration
Bdlat dlat 0 V = (V(lat2) - V(lat1)) * 0.01745329252
Bdlon dlon 0 V = (V(lon2) - V(lon1)) * 0.01745329252
Bavg_lat avg_lat 0 V = (V(lat1) + V(lat2)) / 2 * 0.01745329252
Ba a 0 V = PWR(SIN(V(dlat)/2), 2) + COS(V(avg_lat)) * PWR(SIN(V(dlon)/2), 2)
Bc c 0 V = 2 * ATAN(SQRT(V(a) + 1n) / SQRT(1 - V(a) + 1n))
Bdist out 0 V = 6371 * V(c)
.ENDS

.SUBCKT proven_safe_geo_bearing lat1 lon1 lat2 lon2 out
* Calculate bearing between two points (simplified)
Bdlon dlon 0 V = (V(lon2) - V(lon1)) * 0.01745329252
Blat1_r lat1_r 0 V = V(lat1) * 0.01745329252
Blat2_r lat2_r 0 V = V(lat2) * 0.01745329252
Bx x 0 V = SIN(V(dlon)) * COS(V(lat2_r))
By y 0 V = COS(V(lat1_r)) * SIN(V(lat2_r)) - SIN(V(lat1_r)) * COS(V(lat2_r)) * COS(V(dlon))
Bbearing out 0 V = ATAN2(V(x), V(y)) * 57.2957795131
.ENDS

* ----------------------------------------------------------------------------
* 31. SAFE_PROBABILITY - Probability calculations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_probability_clamp in out vmin=0 vmax=1
* Clamp probability to [0, 1]
Bclamp out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_probability_and p1 p2 out
* P(A and B) assuming independence
Bp_clamp1 p1c 0 V = MIN(MAX(V(p1), 0), 1)
Bp_clamp2 p2c 0 V = MIN(MAX(V(p2), 0), 1)
Band out 0 V = V(p1c) * V(p2c)
.ENDS

.SUBCKT proven_safe_probability_or p1 p2 out
* P(A or B) assuming independence
Bp_clamp1 p1c 0 V = MIN(MAX(V(p1), 0), 1)
Bp_clamp2 p2c 0 V = MIN(MAX(V(p2), 0), 1)
Bor out 0 V = V(p1c) + V(p2c) - V(p1c) * V(p2c)
.ENDS

.SUBCKT proven_safe_probability_not p out
* P(not A)
Bp_clamp pc 0 V = MIN(MAX(V(p), 0), 1)
Bnot out 0 V = 1 - V(pc)
.ENDS

.SUBCKT proven_safe_probability_bayes prior likelihood evidence out
* Bayes theorem: P(A|B) = P(B|A) * P(A) / P(B)
Bev_safe ev_safe 0 V = IF(V(evidence) < 1n, 1n, V(evidence))
Bbayes out 0 V = MIN(V(likelihood) * V(prior) / V(ev_safe), 1)
.ENDS

* ----------------------------------------------------------------------------
* 32. SAFE_CHECKSUM - Checksum calculations
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_checksum_xor in1 in2 out vmax=255
* XOR checksum component
Bxor out 0 V = ABS(INT(V(in1)) - INT(V(in2)) - 2*INT(V(in1)/2)*INT(V(in2)/2))
.ENDS

.SUBCKT proven_safe_checksum_sum in acc out vmax=65535
* Accumulating sum checksum
Bsum out 0 V = INT(V(acc) + V(in)) - INT((V(acc) + V(in)) / {vmax}) * {vmax}
.ENDS

.SUBCKT proven_safe_checksum_crc_step data crc poly out
* Single step CRC calculation (simplified)
Bxor xor_val 0 V = IF(INT(V(crc) / 128) > 0.5, V(poly), 0)
Bshift shift 0 V = INT(V(crc) * 2) - INT(V(crc) * 2 / 256) * 256
Bnew_crc out 0 V = V(shift) + V(data) - 2*INT(V(shift)/2)*INT(V(data)/2) + V(xor_val)
.ENDS

* ----------------------------------------------------------------------------
* 33. SAFE_TENSOR - Tensor operation safety
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_tensor_shape_valid dim1 dim2 dim3 out vhigh=5 vlow=0 max_dim=10000
* Validate tensor dimensions
Bvalid out 0 V = IF(V(dim1) > 0 & V(dim1) <= {max_dim} &
+                   V(dim2) > 0 & V(dim2) <= {max_dim} &
+                   V(dim3) > 0 & V(dim3) <= {max_dim}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_tensor_index_valid idx dim out vhigh=5 vlow=0
* Validate tensor index
Bvalid out 0 V = IF(V(idx) >= 0 & V(idx) < V(dim), {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_tensor_broadcast dim1 dim2 out_dim compatible vhigh=5 vlow=0
* Check broadcast compatibility and compute output dimension
Bcompat compatible 0 V = IF(V(dim1) == V(dim2) | V(dim1) == 1 | V(dim2) == 1, {vhigh}, {vlow})
Bout_dim out_dim 0 V = MAX(V(dim1), V(dim2))
.ENDS

.SUBCKT proven_safe_tensor_matmul_valid m1_rows m1_cols m2_rows m2_cols out vhigh=5 vlow=0
* Validate matrix multiplication dimensions
Bvalid out 0 V = IF(ABS(V(m1_cols) - V(m2_rows)) < 0.5, {vhigh}, {vlow})
.ENDS

* ============================================================================
* MODULE CATEGORY: SECURITY (2 modules)
* ============================================================================

* ----------------------------------------------------------------------------
* 34. SAFE_PASSWORD - Password validation
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_password_length in out vhigh=5 vlow=0 min_len=8 max_len=128
* Validate password length
Bvalid out 0 V = IF(V(in) >= {min_len} & V(in) <= {max_len}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_password_entropy in out vhigh=5 vlow=0 min_entropy=50
* Check password entropy meets minimum
Bentropy out 0 V = IF(V(in) >= {min_entropy}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_password_complexity has_upper has_lower has_digit has_special out vhigh=5 vlow=0 min_types=3
* Check password complexity (number of character types)
Bcount count 0 V = V(has_upper) + V(has_lower) + V(has_digit) + V(has_special)
Bcomplex out 0 V = IF(V(count) >= {min_types}, {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 35. SAFE_ML - Machine learning safety
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_ml_sigmoid in out vmin=0 vmax=1
* Sigmoid activation with bounds
Bsig out 0 V = {vmin} + ({vmax} - {vmin}) / (1 + EXP(-V(in)))
.ENDS

.SUBCKT proven_safe_ml_tanh in out vmin=-1 vmax=1
* Tanh activation with bounds
Btanh out 0 V = ({vmax} - {vmin}) / 2 * TANH(V(in)) + ({vmax} + {vmin}) / 2
.ENDS

.SUBCKT proven_safe_ml_relu in out vmax=10
* ReLU with upper bound
Brelu out 0 V = MIN(MAX(V(in), 0), {vmax})
.ENDS

.SUBCKT proven_safe_ml_leaky_relu in out alpha=0.01 vmin=-10 vmax=10
* Leaky ReLU with bounds
Bleaky out 0 V = MIN(MAX(IF(V(in) > 0, V(in), V(in) * {alpha}), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_ml_softmax_stable in max_in out
* Softmax with numerical stability (subtract max)
Bstable out 0 V = EXP(V(in) - V(max_in))
.ENDS

.SUBCKT proven_safe_ml_gradient_clip in out vmax=1
* Gradient clipping
Bclip out 0 V = MIN(MAX(V(in), -{vmax}), {vmax})
.ENDS

.SUBCKT proven_safe_ml_learning_rate in out vmin=1e-8 vmax=1
* Clamp learning rate to safe range
Blr out 0 V = MIN(MAX(V(in), {vmin}), {vmax})
.ENDS

* ============================================================================
* MODULE CATEGORY: HTTP (3 modules)
* ============================================================================

* ----------------------------------------------------------------------------
* 36. SAFE_HEADER - HTTP header validation
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_header_length in out vhigh=5 vlow=0 max_len=8192
* Validate header length
Bvalid out 0 V = IF(V(in) >= 0 & V(in) <= {max_len}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_header_count in out vhigh=5 vlow=0 max_count=100
* Validate header count
Bvalid out 0 V = IF(V(in) >= 0 & V(in) <= {max_count}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_header_name_char in out vhigh=5 vlow=0
* Validate header name character (printable ASCII, no colon)
Bvalid out 0 V = IF(V(in) >= 33 & V(in) <= 126 & ABS(V(in) - 58) > 0.5, {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 37. SAFE_COOKIE - Cookie validation
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_cookie_size in out vhigh=5 vlow=0 max_size=4096
* Validate cookie size
Bvalid out 0 V = IF(V(in) >= 0 & V(in) <= {max_size}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_cookie_count in out vhigh=5 vlow=0 max_count=50
* Validate cookie count per domain
Bvalid out 0 V = IF(V(in) >= 0 & V(in) <= {max_count}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_cookie_expiry in out vhigh=5 vlow=0 max_age=31536000
* Validate cookie max-age (1 year default max)
Bvalid out 0 V = IF(V(in) >= 0 & V(in) <= {max_age}, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_cookie_path_valid in out vhigh=5 vlow=0
* Validate cookie path starts with /
Bvalid out 0 V = IF(V(in) > 0, {vhigh}, {vlow})
.ENDS

* ----------------------------------------------------------------------------
* 38. SAFE_CONTENT_TYPE - Content-Type validation
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_content_type_valid type subtype out vhigh=5 vlow=0
* Validate content-type has type and subtype
Bvalid out 0 V = IF(V(type) > 0 & V(subtype) > 0, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_content_type_charset in out vhigh=5 vlow=0 utf8=1
* Check for safe charset (UTF-8 preferred)
Bcharset out 0 V = IF(ABS(V(in) - {utf8}) < 0.5, {vhigh}, {vlow})
.ENDS

.SUBCKT proven_safe_content_length in out vhigh=5 vlow=0 max_size=10485760
* Validate content-length (10MB default max)
Bvalid out 0 V = IF(V(in) >= 0 & V(in) <= {max_size}, {vhigh}, {vlow})
.ENDS

* ============================================================================
* UTILITY SUBCIRCUITS
* ============================================================================

* ----------------------------------------------------------------------------
* BOUNDED SOURCES (from original library, updated)
* ----------------------------------------------------------------------------

.SUBCKT proven_bounded_vsrc out_p out_n ctrl vmin=-10 vmax=10
* Safe bounded voltage source
B1 out_p out_n V = MIN(MAX(V(ctrl), {vmin}), {vmax})
.ENDS

.SUBCKT proven_bounded_isrc out_p out_n ctrl imin=-100m imax=100m
* Safe bounded current source
B1 out_p out_n I = MIN(MAX(V(ctrl)*1m, {imin}), {imax})
.ENDS

* ----------------------------------------------------------------------------
* SAFE OP-AMP
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_opamp inp inn out vsat_p=10 vsat_n=-10 gain=100k gbw=1MEG
* Safe operational amplifier with output limiting
Rin inp inn 1MEG
Ediff diff 0 inp inn {gain}
Rpole diff int 1k
Cpole int 0 {1/(2*3.14159*gbw*1k)}
Bout out 0 V = MIN(MAX(V(int), {vsat_n}), {vsat_p})
Rout out 0 100
.ENDS

* ----------------------------------------------------------------------------
* COMPARATORS
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_comparator inp inn out vhigh=5 vlow=0 hyst=0.1
* Safe comparator with hysteresis
.PARAM vth_high = {hyst/2}
.PARAM vth_low = {-hyst/2}
B1 out 0 V = IF(V(inp)-V(inn) > {vth_high}, {vhigh},
+              IF(V(inp)-V(inn) < {vth_low}, {vlow}, V(out)))
.ENDS

* ----------------------------------------------------------------------------
* INTEGRATOR AND DIFFERENTIATOR
* ----------------------------------------------------------------------------

.SUBCKT proven_safe_integrator in out reset vmin=-10 vmax=10 tau=1m ic=0
* Safe integrator with reset and output limiting
Cint int 0 1 IC={ic}
Gin 0 int in 0 {1/tau}
Sreset int 0 reset 0 SW
.MODEL SW SW VT=0.5 RON=1 ROFF=1MEG
B1 out 0 V = MIN(MAX(V(int), {vmin}), {vmax})
.ENDS

.SUBCKT proven_safe_differentiator in out vmin=-10 vmax=10 tau=1m fc=10k
* Safe differentiator with filtering and output limiting
Cdiff in diff {tau}
Rdiff diff 0 1
Rlp diff lp 1k
Clp lp 0 {1/(2*3.14159*fc*1k)}
B1 out 0 V = MIN(MAX(V(lp)*1k, {vmin}), {vmax})
.ENDS

* ----------------------------------------------------------------------------
* INTERPOLATION
* ----------------------------------------------------------------------------

.SUBCKT proven_lerp a b t out vmin=-10 vmax=10
* Linear interpolation with clamped t
Bt t_clamp 0 V = MIN(MAX(V(t), 0), 1)
Bout out 0 V = MIN(MAX(V(a) + (V(b) - V(a)) * V(t_clamp), {vmin}), {vmax})
.ENDS

.SUBCKT proven_smoothstep a b t out vmin=-10 vmax=10
* Smooth interpolation (cubic Hermite)
Bt t_clamp 0 V = MIN(MAX(V(t), 0), 1)
Bt_smooth t_smooth 0 V = V(t_clamp)*V(t_clamp)*(3 - 2*V(t_clamp))
Bout out 0 V = MIN(MAX(V(a) + (V(b) - V(a)) * V(t_smooth), {vmin}), {vmax})
.ENDS

* ============================================================================
* END OF PROVEN SPICE LIBRARY v0.4.0 - 38 MODULES
* ============================================================================

.END
