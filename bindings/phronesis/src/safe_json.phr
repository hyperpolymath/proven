{-- SPDX-License-Identifier: PMPL-1.0-or-later --}
{-- Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk> --}

-- | SafeJson - JSON validation and type detection via libproven FFI.
--
-- Phronesis's krisis type makes JSON validation expressive: the return type
-- precisely captures whether JSON is valid and what root type the document
-- has. Parse failures are typed krisis (judgments), not exceptions.
--
-- All computation is performed in Idris 2 via the Zig FFI layer.
-- NO JSON logic is reimplemented in Phronesis.

logos module Proven.SafeJson

import Proven.FFI
import Proven (ProvenError, krisis, Hamartia, Aletheia, bool_result_to_proven, float_result_to_proven)

-- ============================================================================
-- JSON types matching the C ABI enum
-- ============================================================================

-- | JSON value types as returned by the Idris 2 JSON parser.
logos type JsonType =
  | JsonNull
  | JsonBool
  | JsonNumber
  | JsonString
  | JsonArray
  | JsonObject
  | JsonInvalid

-- | Convert a raw C ABI type code to a JsonType.
gnosis fn int_to_json_type(code : Int32) -> JsonType =
  match code with
  | 0  => JsonNull
  | 1  => JsonBool
  | 2  => JsonNumber
  | 3  => JsonString
  | 4  => JsonArray
  | 5  => JsonObject
  | _  => JsonInvalid

-- ============================================================================
-- JSON validation
-- ============================================================================

-- | Check if a string is valid JSON.
-- Returns Aletheia(true) if valid, Aletheia(false) if not.
-- Delegates to proven_json_is_valid in libproven.
gnosis fn is_valid_json(input : String) -> krisis<Bool, ProvenError> =
  let bytes = string_to_utf8(input)
  bool_result_to_proven(
    FFI.proven_json_is_valid(bytes.ptr, bytes.len)
  )

-- | Get the JSON value type at the root level.
-- Returns JsonInvalid if the string is not valid JSON.
-- Delegates to proven_json_get_type in libproven.
gnosis fn json_type(input : String) -> JsonType =
  let bytes = string_to_utf8(input)
  int_to_json_type(FFI.proven_json_get_type(bytes.ptr, bytes.len))

-- | Validate JSON and return the type in one step.
-- Returns Hamartia(ParseFailure) if the input is not valid JSON.
-- Combines proven_json_is_valid and proven_json_get_type from libproven.
gnosis fn validate_json(input : String) -> krisis<JsonType, ProvenError> =
  match is_valid_json(input) with
  | Aletheia(true)  => Aletheia(json_type(input))
  | Aletheia(false) => Hamartia(ParseFailure)
  | Hamartia(e)     => Hamartia(e)

-- ============================================================================
-- Safe expression evaluation
-- ============================================================================

-- | Safely evaluate an arithmetic expression string.
-- Supports +, -, *, /, parentheses, negative and decimal numbers.
-- Returns Hamartia(ParseFailure) for invalid expressions.
-- Returns Hamartia(DivByZero) for division by zero.
-- Delegates to proven_calculator_eval in libproven.
gnosis fn eval_expression(expr : String) -> krisis<Float64, ProvenError> =
  let bytes = string_to_utf8(expr)
  float_result_to_proven(
    FFI.proven_calculator_eval(bytes.ptr, bytes.len)
  )

-- ============================================================================
-- Phronesis specific: validated JSON type
-- ============================================================================

-- | A validated JSON string type. Represents episteme (certain knowledge)
-- that the JSON has been parsed by the Idris 2 verified JSON validator.
logos type ValidatedJson = private ValidatedJson(String, JsonType)

-- | Get the original JSON string.
gnosis fn validated_json_string(json : ValidatedJson) -> String =
  match json with
  | ValidatedJson(s, _) => s

-- | Get the root type of the validated JSON.
gnosis fn validated_json_type(json : ValidatedJson) -> JsonType =
  match json with
  | ValidatedJson(_, t) => t

-- | Create a ValidatedJson value, returning an error if validation fails.
gnosis fn make_validated_json(input : String) -> krisis<ValidatedJson, ProvenError> =
  match validate_json(input) with
  | Aletheia(t)  => Aletheia(ValidatedJson(input, t))
  | Hamartia(e)  => Hamartia(e)
