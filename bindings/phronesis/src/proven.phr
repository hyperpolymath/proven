{-- SPDX-License-Identifier: PMPL-1.0-or-later --}
{-- Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk> --}

-- | Proven - FFI bindings to libproven (Idris 2 verified safety library)
-- for Phronesis.
--
-- Phronesis (Greek: practical wisdom/prudence) uses krisis<T, E> for error
-- handling, reflecting the language's philosophical approach to judgment
-- and decision-making in computation.
--
-- All computation is performed in Idris 2 via the Zig FFI layer.
-- NO safety logic is reimplemented in Phronesis.
--
-- Architecture:
--   Phronesis (.phr)
--     |  @sophia("C", ...)
--     v
--   libproven.so (Zig FFI layer)
--     |  Zig -> Idris2 RefC calls
--     v
--   Idris 2 (dependent types, totality checking)

logos module Proven

import Proven.FFI
import Proven.SafeMath
import Proven.SafeString
import Proven.SafeEmail
import Proven.SafeUrl
import Proven.SafeCrypto
import Proven.SafeJson

-- ============================================================================
-- Core error type for Proven operations (krisis = judgment/decision)
-- ============================================================================

-- | ProvenError enumerates all possible failure modes from the libproven C ABI.
-- In Phronesis, errors represent krisis (judgment) -- the system has judged
-- that the operation cannot proceed safely.
logos type ProvenError =
  | Overflow            -- Arithmetic overflow (status -3)
  | Underflow           -- Arithmetic underflow (status -4)
  | DivByZero           -- Division by zero (status -5)
  | NullPointer         -- Null pointer passed (status -1)
  | InvalidArgument     -- Invalid argument (status -2)
  | ParseFailure        -- Parse failure (status -6)
  | ValidationFailed    -- Validation failed (status -7)
  | OutOfBounds         -- Index out of bounds (status -8)
  | EncodingError       -- Encoding error (status -9)
  | AllocationFailed    -- Memory allocation failed (status -10)
  | NotImplemented      -- Feature not implemented (status -99)
  | UnknownError(Int32) -- Unrecognized status code

-- | Convert a raw C ABI status code to a ProvenError.
-- This function is total: every possible Int32 maps to exactly one error.
gnosis fn status_to_error(code : Int32) -> ProvenError =
  match code with
  | -1  => NullPointer
  | -2  => InvalidArgument
  | -3  => Overflow
  | -4  => Underflow
  | -5  => DivByZero
  | -6  => ParseFailure
  | -7  => ValidationFailed
  | -8  => OutOfBounds
  | -9  => EncodingError
  | -10 => AllocationFailed
  | -99 => NotImplemented
  | n   => UnknownError(n)

-- ============================================================================
-- krisis<T, E> result type (krisis = judgment/decision)
-- ============================================================================

-- | The core result type for all Proven operations.
-- krisis<T, ProvenError> is the canonical return type, representing
-- the judgment (krisis) of whether an operation succeeded or failed.
logos type krisis<T, E> =
  | Aletheia(T)   -- truth/success (aletheia = truth)
  | Hamartia(E)   -- error/failure (hamartia = missing the mark)

-- | Convert an FFI IntResult into a krisis<Int64, ProvenError>.
gnosis fn int_result_to_proven(ir : FFI.IntResult) -> krisis<Int64, ProvenError> =
  match ir.status with
  | 0 => Aletheia(ir.value)
  | s => Hamartia(status_to_error(s))

-- | Convert an FFI BoolResult into a krisis<Bool, ProvenError>.
gnosis fn bool_result_to_proven(br : FFI.BoolResult) -> krisis<Bool, ProvenError> =
  match br.status with
  | 0 => Aletheia(br.value != 0)
  | s => Hamartia(status_to_error(s))

-- | Convert an FFI FloatResult into a krisis<Float64, ProvenError>.
gnosis fn float_result_to_proven(fr : FFI.FloatResult) -> krisis<Float64, ProvenError> =
  match fr.status with
  | 0 => Aletheia(fr.value)
  | s => Hamartia(status_to_error(s))

-- | Convert an FFI StringResult into a krisis<String, ProvenError>,
-- freeing the C-allocated string after copying.
gnosis fn string_result_to_proven(sr : FFI.StringResult) -> krisis<String, ProvenError> =
  match sr.status with
  | 0 =>
    let result = string_from_ptr(sr.ptr, sr.len)
    FFI.proven_free_string(sr.ptr)
    Aletheia(result)
  | s => Hamartia(status_to_error(s))

-- ============================================================================
-- Lifecycle management
-- ============================================================================

-- | Initialize the Proven runtime. Must be called before any other function.
-- Returns Aletheia(()) on success.
gnosis fn init() -> krisis<Unit, ProvenError> =
  let status = FFI.proven_init()
  match status with
  | 0 => Aletheia(())
  | s => Hamartia(status_to_error(s))

-- | Deinitialize the Proven runtime. Call when done.
gnosis fn deinit() -> Unit =
  FFI.proven_deinit()

-- | Check if the Proven runtime is initialized.
gnosis fn is_initialized() -> Bool =
  FFI.proven_is_initialized()

-- | Get the library version as a tuple (major, minor, patch).
gnosis fn version() -> (UInt32, UInt32, UInt32) =
  (FFI.proven_version_major(), FFI.proven_version_minor(), FFI.proven_version_patch())

-- | Get the FFI ABI version for compatibility checking.
gnosis fn abi_version() -> UInt32 =
  FFI.proven_ffi_abi_version()

-- | Get the total module count in libproven.
gnosis fn module_count() -> UInt32 =
  FFI.proven_module_count()

-- ============================================================================
-- Re-exports
-- ============================================================================

export Proven.SafeMath.*
export Proven.SafeString.*
export Proven.SafeEmail.*
export Proven.SafeUrl.*
export Proven.SafeCrypto.*
export Proven.SafeJson.*
