{-- SPDX-License-Identifier: PMPL-1.0-or-later --}
{-- Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk> --}

-- | SafeMath - Overflow-checked arithmetic via libproven FFI.
--
-- Phronesis uses krisis<Int64, ProvenError> to express arithmetic results,
-- where Hamartia (missing the mark) precisely names the failure: Overflow,
-- Underflow, or DivByZero.
--
-- All computation is performed in Idris 2 via the Zig FFI layer.
-- NO arithmetic logic is reimplemented in Phronesis.

logos module Proven.SafeMath

import Proven.FFI
import Proven (ProvenError, krisis, int_result_to_proven)

-- ============================================================================
-- Checked arithmetic operations
-- ============================================================================

-- | Safely add two integers with overflow detection.
-- Returns Hamartia(Overflow) if the result would exceed Int64 range.
-- Delegates to proven_math_add_checked in libproven.
gnosis fn safe_add(a : Int64, b : Int64) -> krisis<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_add_checked(a, b))

-- | Safely subtract two integers with underflow detection.
-- Returns Hamartia(Underflow) if the result would go below Int64 range.
-- Delegates to proven_math_sub_checked in libproven.
gnosis fn safe_sub(a : Int64, b : Int64) -> krisis<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_sub_checked(a, b))

-- | Safely multiply two integers with overflow detection.
-- Returns Hamartia(Overflow) if the result would exceed Int64 range.
-- Delegates to proven_math_mul_checked in libproven.
gnosis fn safe_mul(a : Int64, b : Int64) -> krisis<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_mul_checked(a, b))

-- | Safely divide two integers.
-- Returns Hamartia(DivByZero) if the denominator is zero.
-- Returns Hamartia(Overflow) for INT64_MIN / -1.
-- Delegates to proven_math_div in libproven.
gnosis fn safe_div(a : Int64, b : Int64) -> krisis<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_div(a, b))

-- | Safe modulo operation.
-- Returns Hamartia(DivByZero) if the denominator is zero.
-- Delegates to proven_math_mod in libproven.
gnosis fn safe_mod(a : Int64, b : Int64) -> krisis<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_mod(a, b))

-- | Safe absolute value.
-- Returns Hamartia(Overflow) for INT64_MIN (cannot be represented as positive Int64).
-- Delegates to proven_math_abs_safe in libproven.
gnosis fn safe_abs(n : Int64) -> krisis<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_abs_safe(n))

-- | Safe negation. Equivalent to safe_sub(0, n).
-- Returns Hamartia(Overflow) if negation of INT64_MIN.
-- Delegates to proven_math_sub_checked in libproven.
gnosis fn safe_negate(n : Int64) -> krisis<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_sub_checked(0, n))

-- | Clamp a value to [lo, hi] range.
-- This operation cannot fail -- it always yields aletheia (truth).
-- Delegates to proven_math_clamp in libproven.
gnosis fn clamp(lo : Int64, hi : Int64, value : Int64) -> Int64 =
  FFI.proven_math_clamp(lo, hi, value)

-- | Safe integer exponentiation with overflow checking.
-- Returns Hamartia(Overflow) if the result would exceed Int64 range.
-- Delegates to proven_math_pow_checked in libproven.
gnosis fn safe_pow(base : Int64, exp : UInt32) -> krisis<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_pow_checked(base, exp))

-- | Check if a value falls within [lo, hi].
-- This is a convenience function built on clamp.
gnosis fn in_range(value : Int64, lo : Int64, hi : Int64) -> Bool =
  value == clamp(lo, hi, value)
