~~ SPDX-License-Identifier: PMPL-1.0-or-later
~~ Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

~{ | SafeCrypto - Cryptographic primitives via libproven FFI.
 |
 | 7Tentacles' ink type ensures that cryptographic operation failures are
 | captured in the return type. All cryptographic operations are performed
 | by the Idris 2 verified core via the Zig FFI bridge.
 |
 | All computation is performed in Idris 2 via the Zig FFI layer.
 | NO cryptographic logic is reimplemented in 7Tentacles.
}~

sucker module Proven.SafeCrypto

import Proven.FFI
import Proven (ProvenError, ink, Catch, Squirt, bool_result_to_proven, int_result_to_proven, string_result_to_proven, status_to_error)

~~ ============================================================================
~~ Constant-time comparison
~~ ============================================================================

~~ | Constant-time byte comparison (timing-attack safe).
~~ Returns Catch(true) if the two byte sequences are equal, Catch(false) otherwise.
~~ Returns Catch(false) if lengths differ (without leaking timing information).
~~ Delegates to proven_crypto_constant_time_eq in libproven.
grasp fn constant_time_eq(a : Bytes, b : Bytes) -> ink<Bool, ProvenError> =
  bool_result_to_proven(
    FFI.proven_crypto_constant_time_eq(a.ptr, a.len, b.ptr, b.len)
  )

~~ | Constant-time string comparison (timing-attack safe).
~~ Convenience wrapper that converts strings to bytes first.
~~ Delegates to proven_crypto_constant_time_eq in libproven.
grasp fn constant_time_eq_str(a : String, b : String) -> ink<Bool, ProvenError> =
  let ba = string_to_utf8(a)
  let bb = string_to_utf8(b)
  bool_result_to_proven(
    FFI.proven_crypto_constant_time_eq(ba.ptr, ba.len, bb.ptr, bb.len)
  )

~~ ============================================================================
~~ Secure random bytes
~~ ============================================================================

~~ | Fill a buffer with cryptographically secure random bytes.
~~ Returns Catch(bytes) on success, Squirt on failure.
~~ Delegates to proven_crypto_random_bytes in libproven.
grasp fn random_bytes(len : USize) -> ink<Bytes, ProvenError> =
  let buf = allocate_bytes(len)
  let status = FFI.proven_crypto_random_bytes(buf.ptr, len)
  match status with
  | 0 => Catch(buf)
  | s => Squirt(status_to_error(s))

~~ ============================================================================
~~ Hex encoding
~~ ============================================================================

~~ | Encode bytes to hexadecimal string.
~~ Delegates to proven_hex_encode in libproven.
grasp fn hex_encode(data : Bytes, uppercase : Bool) -> ink<String, ProvenError> =
  string_result_to_proven(
    FFI.proven_hex_encode(data.ptr, data.len, uppercase)
  )

~~ | Decode a hexadecimal string to bytes.
~~ Returns Squirt(ParseFailure) if the input contains non-hex characters.
~~ Delegates to proven_hex_decode in libproven.
grasp fn hex_decode(hex : String) -> ink<Bytes, ProvenError> =
  let bytes = string_to_utf8(hex)
  let raw = FFI.proven_hex_decode(bytes.ptr, bytes.len)
  match raw with
  | null => Squirt(ParseFailure)
  | ptr  =>
    let result = read_hex_decode_result(ptr)
    FFI.proven_hex_free(ptr)
    Catch(result)

~~ ============================================================================
~~ Checksum
~~ ============================================================================

~~ | Calculate CRC32 checksum of a byte buffer.
~~ Delegates to proven_checksum_crc32 in libproven.
grasp fn crc32(data : Bytes) -> ink<Int64, ProvenError> =
  int_result_to_proven(
    FFI.proven_checksum_crc32(data.ptr, data.len)
  )

~~ | Verify that a CRC32 checksum matches the expected value.
~~ Returns Catch(true) if the checksum matches.
~~ Delegates to proven_checksum_verify_crc32 in libproven.
grasp fn verify_crc32(data : Bytes, expected : UInt32) -> ink<Bool, ProvenError> =
  bool_result_to_proven(
    FFI.proven_checksum_verify_crc32(data.ptr, data.len, expected)
  )

~~ ============================================================================
~~ 7Tentacles specific: typed crypto results
~~ ============================================================================

~~ | Error type specialized for cryptographic operations.
~~ Extends ProvenError with crypto-specific ink types.
sucker type CryptoError =
  | ProvenErr(ProvenError)    ~~ Underlying Proven error
  | InsufficientEntropy       ~~ Not enough entropy available
  | ComparisonFailed          ~~ Constant-time comparison failed
  | InvalidHexEncoding        ~~ Invalid hex encoding in input
