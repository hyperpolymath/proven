~~ SPDX-License-Identifier: PMPL-1.0-or-later
~~ Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

~{ | SafeMath - Overflow-checked arithmetic via libproven FFI.
 |
 | 7Tentacles uses ink<Int64, ProvenError> to express arithmetic results,
 | where Squirt (defensive ink) precisely names the failure: Overflow,
 | Underflow, or DivByZero.
 |
 | All computation is performed in Idris 2 via the Zig FFI layer.
 | NO arithmetic logic is reimplemented in 7Tentacles.
}~

sucker module Proven.SafeMath

import Proven.FFI
import Proven (ProvenError, ink, int_result_to_proven)

~~ ============================================================================
~~ Checked arithmetic operations
~~ ============================================================================

~~ | Safely add two integers with overflow detection.
~~ Returns Squirt(Overflow) if the result would exceed Int64 range.
~~ Delegates to proven_math_add_checked in libproven.
grasp fn safe_add(a : Int64, b : Int64) -> ink<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_add_checked(a, b))

~~ | Safely subtract two integers with underflow detection.
~~ Returns Squirt(Underflow) if the result would go below Int64 range.
~~ Delegates to proven_math_sub_checked in libproven.
grasp fn safe_sub(a : Int64, b : Int64) -> ink<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_sub_checked(a, b))

~~ | Safely multiply two integers with overflow detection.
~~ Returns Squirt(Overflow) if the result would exceed Int64 range.
~~ Delegates to proven_math_mul_checked in libproven.
grasp fn safe_mul(a : Int64, b : Int64) -> ink<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_mul_checked(a, b))

~~ | Safely divide two integers.
~~ Returns Squirt(DivByZero) if the denominator is zero.
~~ Returns Squirt(Overflow) for INT64_MIN / -1.
~~ Delegates to proven_math_div in libproven.
grasp fn safe_div(a : Int64, b : Int64) -> ink<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_div(a, b))

~~ | Safe modulo operation.
~~ Returns Squirt(DivByZero) if the denominator is zero.
~~ Delegates to proven_math_mod in libproven.
grasp fn safe_mod(a : Int64, b : Int64) -> ink<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_mod(a, b))

~~ | Safe absolute value.
~~ Returns Squirt(Overflow) for INT64_MIN (cannot be represented as positive Int64).
~~ Delegates to proven_math_abs_safe in libproven.
grasp fn safe_abs(n : Int64) -> ink<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_abs_safe(n))

~~ | Safe negation. Equivalent to safe_sub(0, n).
~~ Returns Squirt(Overflow) if negation of INT64_MIN.
~~ Delegates to proven_math_sub_checked in libproven.
grasp fn safe_negate(n : Int64) -> ink<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_sub_checked(0, n))

~~ | Clamp a value to [lo, hi] range.
~~ This operation cannot fail -- the tentacle always catches it.
~~ Delegates to proven_math_clamp in libproven.
grasp fn clamp(lo : Int64, hi : Int64, value : Int64) -> Int64 =
  FFI.proven_math_clamp(lo, hi, value)

~~ | Safe integer exponentiation with overflow checking.
~~ Returns Squirt(Overflow) if the result would exceed Int64 range.
~~ Delegates to proven_math_pow_checked in libproven.
grasp fn safe_pow(base : Int64, exp : UInt32) -> ink<Int64, ProvenError> =
  int_result_to_proven(FFI.proven_math_pow_checked(base, exp))

~~ | Check if a value falls within [lo, hi].
~~ This is a convenience function built on clamp.
grasp fn in_range(value : Int64, lo : Int64, hi : Int64) -> Bool =
  value == clamp(lo, hi, value)
