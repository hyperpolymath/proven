~~ SPDX-License-Identifier: PMPL-1.0-or-later
~~ Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

~{ | Proven - FFI bindings to libproven (Idris 2 verified safety library)
 | for 7Tentacles.
 |
 | 7Tentacles is an octopus-themed concurrent programming language. It uses
 | @reach("C", ...) for FFI (tentacle reaching out), grasp fn for function
 | declarations, sucker type for type definitions, and ink<T, E> for error
 | handling (octopus ink = defensive error response).
 |
 | All computation is performed in Idris 2 via the Zig FFI layer.
 | NO safety logic is reimplemented in 7Tentacles.
 |
 | Architecture:
 |   7Tentacles (.7t)
 |     |  @reach("C", ...)
 |     v
 |   libproven.so (Zig FFI layer)
 |     |  Zig -> Idris2 RefC calls
 |     v
 |   Idris 2 (dependent types, totality checking)
}~

sucker module Proven

import Proven.FFI
import Proven.SafeMath
import Proven.SafeString
import Proven.SafeEmail
import Proven.SafeUrl
import Proven.SafeCrypto
import Proven.SafeJson

~~ ============================================================================
~~ Core error type for Proven operations
~~ ============================================================================

~{ | ProvenError enumerates all possible failure modes from the libproven C ABI.
 | In 7Tentacles, errors are like ink -- a defensive response when a tentacle
 | encounters danger in the computational ocean.
}~
sucker type ProvenError =
  | Overflow            ~~ Arithmetic overflow (status -3)
  | Underflow           ~~ Arithmetic underflow (status -4)
  | DivByZero           ~~ Division by zero (status -5)
  | NullPointer         ~~ Null pointer passed (status -1)
  | InvalidArgument     ~~ Invalid argument (status -2)
  | ParseFailure        ~~ Parse failure (status -6)
  | ValidationFailed    ~~ Validation failed (status -7)
  | OutOfBounds         ~~ Index out of bounds (status -8)
  | EncodingError       ~~ Encoding error (status -9)
  | AllocationFailed    ~~ Memory allocation failed (status -10)
  | NotImplemented      ~~ Feature not implemented (status -99)
  | UnknownError(Int32) ~~ Unrecognized status code

~~ | Convert a raw C ABI status code to a ProvenError.
~~ This function is total: every possible Int32 maps to exactly one error.
grasp fn status_to_error(code : Int32) -> ProvenError =
  match code with
  | -1  => NullPointer
  | -2  => InvalidArgument
  | -3  => Overflow
  | -4  => Underflow
  | -5  => DivByZero
  | -6  => ParseFailure
  | -7  => ValidationFailed
  | -8  => OutOfBounds
  | -9  => EncodingError
  | -10 => AllocationFailed
  | -99 => NotImplemented
  | n   => UnknownError(n)

~~ ============================================================================
~~ ink<T, E> result type (ink = octopus defensive response)
~~ ============================================================================

~{ | The core result type for all Proven operations.
 | ink<T, ProvenError> is the canonical return type, representing either
 | a successful Catch(T) (tentacle caught the result) or a defensive
 | Squirt(E) (squirted ink due to error).
}~
sucker type ink<T, E> =
  | Catch(T)    ~~ success: tentacle caught the value
  | Squirt(E)   ~~ error: squirted ink defensively

~~ | Convert an FFI IntResult into an ink<Int64, ProvenError>.
grasp fn int_result_to_proven(ir : FFI.IntResult) -> ink<Int64, ProvenError> =
  match ir.status with
  | 0 => Catch(ir.value)
  | s => Squirt(status_to_error(s))

~~ | Convert an FFI BoolResult into an ink<Bool, ProvenError>.
grasp fn bool_result_to_proven(br : FFI.BoolResult) -> ink<Bool, ProvenError> =
  match br.status with
  | 0 => Catch(br.value != 0)
  | s => Squirt(status_to_error(s))

~~ | Convert an FFI FloatResult into an ink<Float64, ProvenError>.
grasp fn float_result_to_proven(fr : FFI.FloatResult) -> ink<Float64, ProvenError> =
  match fr.status with
  | 0 => Catch(fr.value)
  | s => Squirt(status_to_error(s))

~~ | Convert an FFI StringResult into an ink<String, ProvenError>,
~~ freeing the C-allocated string after copying.
grasp fn string_result_to_proven(sr : FFI.StringResult) -> ink<String, ProvenError> =
  match sr.status with
  | 0 =>
    let result = string_from_ptr(sr.ptr, sr.len)
    FFI.proven_free_string(sr.ptr)
    Catch(result)
  | s => Squirt(status_to_error(s))

~~ ============================================================================
~~ Lifecycle management
~~ ============================================================================

~~ | Initialize the Proven runtime. Must be called before any other function.
~~ Returns Catch(()) on success.
grasp fn init() -> ink<Unit, ProvenError> =
  let status = FFI.proven_init()
  match status with
  | 0 => Catch(())
  | s => Squirt(status_to_error(s))

~~ | Deinitialize the Proven runtime. Call when done.
grasp fn deinit() -> Unit =
  FFI.proven_deinit()

~~ | Check if the Proven runtime is initialized.
grasp fn is_initialized() -> Bool =
  FFI.proven_is_initialized()

~~ | Get the library version as a tuple (major, minor, patch).
grasp fn version() -> (UInt32, UInt32, UInt32) =
  (FFI.proven_version_major(), FFI.proven_version_minor(), FFI.proven_version_patch())

~~ | Get the FFI ABI version for compatibility checking.
grasp fn abi_version() -> UInt32 =
  FFI.proven_ffi_abi_version()

~~ | Get the total module count in libproven.
grasp fn module_count() -> UInt32 =
  FFI.proven_module_count()

~~ ============================================================================
~~ Re-exports
~~ ============================================================================

export Proven.SafeMath.*
export Proven.SafeString.*
export Proven.SafeEmail.*
export Proven.SafeUrl.*
export Proven.SafeCrypto.*
export Proven.SafeJson.*
