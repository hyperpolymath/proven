// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";

function make(rows, cols) {
  if (rows <= 0 || cols <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  }
  if (rows > 4096 || cols > 4096) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  }
  var totalSize = Math.imul(rows, cols);
  if (Caml_int32.div(totalSize, rows) !== cols) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              data: Belt_Array.make(totalSize, 0.0),
              rows: rows,
              cols: cols
            }
          };
  }
}

function fromArray(values) {
  var numRows = values.length;
  if (numRows === 0) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  }
  var firstRow = values[0];
  var numCols = firstRow.length;
  if (numCols === 0) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  }
  var validShape = Belt_Array.every(values, (function (row) {
          return row.length === numCols;
        }));
  if (!validShape) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var e = make(numRows, numCols);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var matrix = e._0;
  Belt_Array.forEachWithIndex(values, (function (rowIdx, row) {
          Belt_Array.forEachWithIndex(row, (function (colIdx, val_) {
                  matrix.data[Math.imul(rowIdx, numCols) + colIdx | 0] = val_;
                }));
        }));
  return {
          TAG: "Ok",
          _0: matrix
        };
}

function identity(size) {
  var e = make(size, size);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var matrix = e._0;
  for(var i = 0; i < size; ++i){
    matrix.data[Math.imul(i, size) + i | 0] = 1.0;
  }
  return {
          TAG: "Ok",
          _0: matrix
        };
}

function diagonal(values) {
  var size = values.length;
  if (size === 0) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  }
  var e = make(size, size);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var matrix = e._0;
  Belt_Array.forEachWithIndex(values, (function (i, val_) {
          matrix.data[Math.imul(i, size) + i | 0] = val_;
        }));
  return {
          TAG: "Ok",
          _0: matrix
        };
}

function clone(m) {
  return {
          data: m.data.slice(0),
          rows: m.rows,
          cols: m.cols
        };
}

function get(m, row, col) {
  if (row < 0 || row >= m.rows || col < 0 || col >= m.cols) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  } else {
    return {
            TAG: "Ok",
            _0: m.data[Math.imul(row, m.cols) + col | 0]
          };
  }
}

function set(m, row, col, value) {
  if (row < 0 || row >= m.rows || col < 0 || col >= m.cols) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  } else {
    m.data[Math.imul(row, m.cols) + col | 0] = value;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function shape(m) {
  return [
          m.rows,
          m.cols
        ];
}

function isSquare(m) {
  return m.rows === m.cols;
}

function hasSameShape(a, b) {
  if (a.rows === b.rows) {
    return a.cols === b.cols;
  } else {
    return false;
  }
}

function canMultiplyWith(a, b) {
  return a.cols === b.rows;
}

function add(a, b) {
  if (!hasSameShape(a, b)) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var e = make(a.rows, a.cols);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = e._0;
  Belt_Array.forEachWithIndex(a.data, (function (i, val_) {
          result.data[i] = val_ + b.data[i];
        }));
  return {
          TAG: "Ok",
          _0: result
        };
}

function sub(a, b) {
  if (!hasSameShape(a, b)) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var e = make(a.rows, a.cols);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = e._0;
  Belt_Array.forEachWithIndex(a.data, (function (i, val_) {
          result.data[i] = val_ - b.data[i];
        }));
  return {
          TAG: "Ok",
          _0: result
        };
}

function mul(a, b) {
  if (!canMultiplyWith(a, b)) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var e = make(a.rows, b.cols);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = e._0;
  for(var i = 0 ,i_finish = a.rows; i < i_finish; ++i){
    for(var j = 0 ,j_finish = b.cols; j < j_finish; ++j){
      var sum = 0.0;
      for(var k = 0 ,k_finish = a.cols; k < k_finish; ++k){
        sum = sum + a.data[Math.imul(i, a.cols) + k | 0] * b.data[Math.imul(k, b.cols) + j | 0];
      }
      result.data[Math.imul(i, b.cols) + j | 0] = sum;
    }
  }
  return {
          TAG: "Ok",
          _0: result
        };
}

function scale(m, scalar) {
  return {
          data: Belt_Array.map(m.data, (function (v) {
                  return v * scalar;
                })),
          rows: m.rows,
          cols: m.cols
        };
}

function transpose(m) {
  var e = make(m.cols, m.rows);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = e._0;
  for(var i = 0 ,i_finish = m.rows; i < i_finish; ++i){
    for(var j = 0 ,j_finish = m.cols; j < j_finish; ++j){
      result.data[Math.imul(j, m.rows) + i | 0] = m.data[Math.imul(i, m.cols) + j | 0];
    }
  }
  return {
          TAG: "Ok",
          _0: result
        };
}

function trace(m) {
  if (!isSquare(m)) {
    return {
            TAG: "Error",
            _0: "NotSquare"
          };
  }
  var sum = 0.0;
  for(var i = 0 ,i_finish = m.rows; i < i_finish; ++i){
    sum = sum + m.data[Math.imul(i, m.cols) + i | 0];
  }
  return {
          TAG: "Ok",
          _0: sum
        };
}

function frobeniusNormSquared(m) {
  return Belt_Array.reduce(m.data, 0.0, (function (acc, v) {
                return acc + v * v;
              }));
}

function frobeniusNorm(m) {
  return Math.sqrt(frobeniusNormSquared(m));
}

function getRow(m, row) {
  if (row < 0 || row >= m.rows) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var start = Math.imul(row, m.cols);
  return {
          TAG: "Ok",
          _0: Belt_Array.slice(m.data, start, m.cols)
        };
}

function getColumn(m, col) {
  if (col < 0 || col >= m.cols) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var column = Belt_Array.make(m.rows, 0.0);
  for(var i = 0 ,i_finish = m.rows; i < i_finish; ++i){
    column[i] = m.data[Math.imul(i, m.cols) + col | 0];
  }
  return {
          TAG: "Ok",
          _0: column
        };
}

function submatrix(m, rowStart, colStart, numRows, numCols) {
  if ((rowStart + numRows | 0) > m.rows || (colStart + numCols | 0) > m.cols) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  if (numRows <= 0 || numCols <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  }
  var e = make(numRows, numCols);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = e._0;
  for(var i = 0; i < numRows; ++i){
    for(var j = 0; j < numCols; ++j){
      result.data[Math.imul(i, numCols) + j | 0] = m.data[Math.imul(rowStart + i | 0, m.cols) + (colStart + j | 0) | 0];
    }
  }
  return {
          TAG: "Ok",
          _0: result
        };
}

function hadamard(a, b) {
  if (!hasSameShape(a, b)) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var e = make(a.rows, a.cols);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = e._0;
  Belt_Array.forEachWithIndex(a.data, (function (i, val_) {
          result.data[i] = val_ * b.data[i];
        }));
  return {
          TAG: "Ok",
          _0: result
        };
}

function isSymmetric(m) {
  if (!isSquare(m)) {
    return false;
  }
  var symmetric = true;
  for(var i = 0 ,i_finish = m.rows; i < i_finish; ++i){
    for(var j = i + 1 | 0 ,j_finish = m.cols; j < j_finish; ++j){
      if (m.data[Math.imul(i, m.cols) + j | 0] !== m.data[Math.imul(j, m.cols) + i | 0]) {
        symmetric = false;
      }
      
    }
  }
  return symmetric;
}

function isDiagonal(m) {
  if (!isSquare(m)) {
    return false;
  }
  var diagonal_ = true;
  for(var i = 0 ,i_finish = m.rows; i < i_finish; ++i){
    for(var j = 0 ,j_finish = m.cols; j < j_finish; ++j){
      if (i !== j && m.data[Math.imul(i, m.cols) + j | 0] !== 0.0) {
        diagonal_ = false;
      }
      
    }
  }
  return diagonal_;
}

function isIdentity(m) {
  if (!isSquare(m)) {
    return false;
  }
  var isIdent = true;
  for(var i = 0 ,i_finish = m.rows; i < i_finish; ++i){
    for(var j = 0 ,j_finish = m.cols; j < j_finish; ++j){
      var expected = i === j ? 1.0 : 0.0;
      if (m.data[Math.imul(i, m.cols) + j | 0] !== expected) {
        isIdent = false;
      }
      
    }
  }
  return isIdent;
}

function sum(m) {
  return Belt_Array.reduce(m.data, 0.0, (function (acc, v) {
                return acc + v;
              }));
}

function max(m) {
  if (m.data.length === 0) {
    return ;
  }
  var maxVal = {
    contents: m.data[0]
  };
  Belt_Array.forEach(m.data, (function (v) {
          if (v > maxVal.contents) {
            maxVal.contents = v;
            return ;
          }
          
        }));
  return maxVal.contents;
}

function min(m) {
  if (m.data.length === 0) {
    return ;
  }
  var minVal = {
    contents: m.data[0]
  };
  Belt_Array.forEach(m.data, (function (v) {
          if (v < minVal.contents) {
            minVal.contents = v;
            return ;
          }
          
        }));
  return minVal.contents;
}

function validateAddition(rowsA, colsA, rowsB, colsB) {
  if (rowsA !== rowsB || colsA !== colsB) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function validateMultiplication(_rowsA, colsA, rowsB, _colsB) {
  if (colsA !== rowsB) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function validateSquare(rows, cols) {
  if (rows !== cols) {
    return {
            TAG: "Error",
            _0: "NotSquare"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function multiplicationResultShape(rowsA, colsA, rowsB, colsB) {
  var e = validateMultiplication(rowsA, colsA, rowsB, colsB);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: [
              rowsA,
              colsB
            ]
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function toArray(m) {
  return Belt_Array.makeBy(m.rows, (function (i) {
                return Belt_Array.makeBy(m.cols, (function (j) {
                              return m.data[Math.imul(i, m.cols) + j | 0];
                            }));
              }));
}

function fill(m, value) {
  Belt_Array.fill(m.data, 0, m.data.length, value);
}

function ones(rows, cols) {
  var e = make(rows, cols);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var m = e._0;
  fill(m, 1.0);
  return {
          TAG: "Ok",
          _0: m
        };
}

function map(m, f) {
  return {
          data: Belt_Array.map(m.data, f),
          rows: m.rows,
          cols: m.cols
        };
}

function approxEqual(a, b, epsilon) {
  if (!hasSameShape(a, b)) {
    return false;
  }
  var result = {
    contents: true
  };
  Belt_Array.forEachWithIndex(a.data, (function (i, v) {
          if (result.contents && Math.abs(v - b.data[i]) > epsilon) {
            result.contents = false;
            return ;
          }
          
        }));
  return result.contents;
}

function dotProduct(a, b) {
  if (a.length !== b.length) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var sum = {
    contents: 0.0
  };
  Belt_Array.forEachWithIndex(a, (function (i, v) {
          sum.contents = sum.contents + v * b[i];
        }));
  return {
          TAG: "Ok",
          _0: sum.contents
        };
}

var maxDimension = 4096;

export {
  maxDimension ,
  make ,
  fromArray ,
  identity ,
  diagonal ,
  clone ,
  get ,
  set ,
  shape ,
  isSquare ,
  hasSameShape ,
  canMultiplyWith ,
  add ,
  sub ,
  mul ,
  scale ,
  transpose ,
  trace ,
  frobeniusNormSquared ,
  frobeniusNorm ,
  getRow ,
  getColumn ,
  submatrix ,
  hadamard ,
  isSymmetric ,
  isDiagonal ,
  isIdentity ,
  sum ,
  max ,
  min ,
  validateAddition ,
  validateMultiplication ,
  validateSquare ,
  multiplicationResultShape ,
  toArray ,
  fill ,
  ones ,
  map ,
  approxEqual ,
  dotProduct ,
}
/* No side effect */
