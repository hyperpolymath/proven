// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function errorToString(error) {
  switch (error) {
    case "OutOfBounds" :
        return "Index out of bounds";
    case "BufferFull" :
        return "Buffer is full";
    case "BufferEmpty" :
        return "Buffer is empty";
    case "AllocationFailed" :
        return "Memory allocation failed";
    
  }
}

function makeBoundedBuffer(capacity) {
  if (capacity <= 0) {
    return {
            TAG: "Error",
            _0: "AllocationFailed"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              data: Belt_Array.make(capacity, undefined),
              length: 0,
              capacity: capacity
            }
          };
  }
}

function length(buffer) {
  return buffer.length;
}

function isEmpty(buffer) {
  return buffer.length === 0;
}

function isFull(buffer) {
  return buffer.length >= buffer.capacity;
}

function remaining(buffer) {
  return buffer.capacity - buffer.length | 0;
}

function getCapacity(buffer) {
  return buffer.capacity;
}

function push(buffer, value) {
  if (isFull(buffer)) {
    return {
            TAG: "Error",
            _0: "BufferFull"
          };
  } else {
    buffer.data[buffer.length] = Caml_option.some(value);
    buffer.length = buffer.length + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function pop(buffer) {
  if (buffer.length === 0) {
    return {
            TAG: "Error",
            _0: "BufferEmpty"
          };
  }
  buffer.length = buffer.length - 1 | 0;
  var value = buffer.data[buffer.length];
  if (value !== undefined) {
    buffer.data[buffer.length] = undefined;
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(value)
          };
  } else {
    return {
            TAG: "Error",
            _0: "BufferEmpty"
          };
  }
}

function get(buffer, index) {
  if (index < 0 || index >= buffer.length) {
    return {
            TAG: "Error",
            _0: "OutOfBounds"
          };
  }
  var value = buffer.data[index];
  if (value !== undefined) {
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(value)
          };
  } else {
    return {
            TAG: "Error",
            _0: "OutOfBounds"
          };
  }
}

function set(buffer, index, value) {
  if (index < 0 || index >= buffer.length) {
    return {
            TAG: "Error",
            _0: "OutOfBounds"
          };
  } else {
    buffer.data[index] = Caml_option.some(value);
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function clear(buffer) {
  for(var i = 0 ,i_finish = buffer.length; i < i_finish; ++i){
    buffer.data[i] = undefined;
  }
  buffer.length = 0;
}

function peekLast(buffer) {
  if (buffer.length === 0) {
    return ;
  } else {
    return buffer.data[buffer.length - 1 | 0];
  }
}

function peekFirst(buffer) {
  if (buffer.length === 0) {
    return ;
  } else {
    return buffer.data[0];
  }
}

function toArray(buffer) {
  var result = [];
  for(var i = 0 ,i_finish = buffer.length; i < i_finish; ++i){
    var value = buffer.data[i];
    if (value !== undefined) {
      result.push(Caml_option.valFromOption(value));
    }
    
  }
  return result;
}

function fromArray(arr, capacity) {
  var arrLen = arr.length;
  if (arrLen > capacity) {
    return {
            TAG: "Error",
            _0: "BufferFull"
          };
  }
  var e = makeBoundedBuffer(capacity);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var buffer = e._0;
  Belt_Array.forEachWithIndex(arr, (function (i, value) {
          buffer.data[i] = Caml_option.some(value);
        }));
  buffer.length = arrLen;
  return {
          TAG: "Ok",
          _0: buffer
        };
}

function makeRingBuffer(capacity) {
  if (capacity <= 0) {
    return {
            TAG: "Error",
            _0: "AllocationFailed"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              data: Belt_Array.make(capacity, undefined),
              head: 0,
              tail: 0,
              length: 0,
              capacity: capacity
            }
          };
  }
}

function ringLength(buffer) {
  return buffer.length;
}

function ringIsEmpty(buffer) {
  return buffer.length === 0;
}

function ringIsFull(buffer) {
  return buffer.length >= buffer.capacity;
}

function ringRemaining(buffer) {
  return buffer.capacity - buffer.length | 0;
}

function enqueue(buffer, value) {
  if (ringIsFull(buffer)) {
    return {
            TAG: "Error",
            _0: "BufferFull"
          };
  } else {
    buffer.data[buffer.tail] = Caml_option.some(value);
    buffer.tail = Caml_int32.mod_(buffer.tail + 1 | 0, buffer.capacity);
    buffer.length = buffer.length + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function enqueueDropOldest(buffer, value) {
  if (ringIsFull(buffer)) {
    buffer.head = Caml_int32.mod_(buffer.head + 1 | 0, buffer.capacity);
    buffer.length = buffer.length - 1 | 0;
  }
  buffer.data[buffer.tail] = Caml_option.some(value);
  buffer.tail = Caml_int32.mod_(buffer.tail + 1 | 0, buffer.capacity);
  buffer.length = buffer.length + 1 | 0;
}

function dequeue(buffer) {
  if (buffer.length === 0) {
    return {
            TAG: "Error",
            _0: "BufferEmpty"
          };
  }
  var value = buffer.data[buffer.head];
  if (value !== undefined) {
    buffer.data[buffer.head] = undefined;
    buffer.head = Caml_int32.mod_(buffer.head + 1 | 0, buffer.capacity);
    buffer.length = buffer.length - 1 | 0;
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(value)
          };
  } else {
    return {
            TAG: "Error",
            _0: "BufferEmpty"
          };
  }
}

function ringPeek(buffer) {
  if (buffer.length === 0) {
    return ;
  } else {
    return buffer.data[buffer.head];
  }
}

function ringPeekBack(buffer) {
  if (buffer.length === 0) {
    return ;
  }
  var backIndex = Caml_int32.mod_((buffer.tail - 1 | 0) + buffer.capacity | 0, buffer.capacity);
  return buffer.data[backIndex];
}

function ringClear(buffer) {
  for(var i = 0 ,i_finish = buffer.capacity; i < i_finish; ++i){
    buffer.data[i] = undefined;
  }
  buffer.head = 0;
  buffer.tail = 0;
  buffer.length = 0;
}

function ringToArray(buffer) {
  var result = [];
  var i = buffer.head;
  var count = 0;
  while(count < buffer.length) {
    var value = buffer.data[i];
    if (value !== undefined) {
      result.push(Caml_option.valFromOption(value));
    }
    i = Caml_int32.mod_(i + 1 | 0, buffer.capacity);
    count = count + 1 | 0;
  };
  return result;
}

export {
  errorToString ,
  makeBoundedBuffer ,
  length ,
  isEmpty ,
  isFull ,
  remaining ,
  getCapacity ,
  push ,
  pop ,
  get ,
  set ,
  clear ,
  peekLast ,
  peekFirst ,
  toArray ,
  fromArray ,
  makeRingBuffer ,
  ringLength ,
  ringIsEmpty ,
  ringIsFull ,
  ringRemaining ,
  enqueue ,
  enqueueDropOldest ,
  dequeue ,
  ringPeek ,
  ringPeekBack ,
  ringClear ,
  ringToArray ,
}
/* No side effect */
