// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

var hexChars = "0123456789abcdef";

var hexCharsUpper = "0123456789ABCDEF";

function hexCharToInt($$char) {
  var code = $$char.charCodeAt(0) | 0;
  if (code >= 48 && code <= 57) {
    return code - 48 | 0;
  } else if (code >= 65 && code <= 70) {
    return code - 55 | 0;
  } else if (code >= 97 && code <= 102) {
    return code - 87 | 0;
  } else {
    return ;
  }
}

function intToHexChar(value) {
  if (value >= 0 && value <= 15) {
    return hexChars.charAt(value);
  }
  
}

function encode(bytes) {
  if (bytes.length === 0) {
    return {
            TAG: "Ok",
            _0: ""
          };
  }
  var result = {
    contents: ""
  };
  var valid = {
    contents: true
  };
  Belt_Array.forEach(bytes, (function ($$byte) {
          if (!(valid.contents && $$byte >= 0 && $$byte <= 255)) {
            valid.contents = false;
            return ;
          }
          var high = ($$byte >>> 4);
          var low = $$byte & 15;
          result.contents = result.contents + hexChars.charAt(high) + hexChars.charAt(low);
        }));
  if (valid.contents) {
    return {
            TAG: "Ok",
            _0: result.contents
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCharacter"
          };
  }
}

function encodeUppercase(bytes) {
  if (bytes.length === 0) {
    return {
            TAG: "Ok",
            _0: ""
          };
  }
  var result = {
    contents: ""
  };
  var valid = {
    contents: true
  };
  Belt_Array.forEach(bytes, (function ($$byte) {
          if (!(valid.contents && $$byte >= 0 && $$byte <= 255)) {
            valid.contents = false;
            return ;
          }
          var high = ($$byte >>> 4);
          var low = $$byte & 15;
          result.contents = result.contents + hexCharsUpper.charAt(high) + hexCharsUpper.charAt(low);
        }));
  if (valid.contents) {
    return {
            TAG: "Ok",
            _0: result.contents
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCharacter"
          };
  }
}

function encodeString(input) {
  var result = "";
  for(var i = 0 ,i_finish = input.length; i < i_finish; ++i){
    var code = input.charCodeAt(i) | 0;
    if (code <= 255) {
      var high = (code >>> 4);
      var low = code & 15;
      result = result + hexChars.charAt(high) + hexChars.charAt(low);
    } else {
      var highByte = (code >>> 8);
      var highHigh = (highByte >>> 4);
      var highLow = highByte & 15;
      result = result + hexChars.charAt(highHigh) + hexChars.charAt(highLow);
      var lowByte = code & 255;
      var lowHigh = (lowByte >>> 4);
      var lowLow = lowByte & 15;
      result = result + hexChars.charAt(lowHigh) + hexChars.charAt(lowLow);
    }
  }
  return result;
}

function decode(hexStr) {
  var normalized = hexStr.trim().toLowerCase();
  var length = normalized.length;
  if (length === 0) {
    return {
            TAG: "Ok",
            _0: []
          };
  }
  if (length % 2 !== 0) {
    return {
            TAG: "Error",
            _0: "InvalidLength"
          };
  }
  var numBytes = length / 2 | 0;
  var bytes = Belt_Array.make(numBytes, 0);
  var valid = true;
  var errorType = "InvalidCharacter";
  for(var i = 0; i < numBytes; ++i){
    if (valid) {
      var highChar = normalized.charAt((i << 1));
      var lowChar = normalized.charAt((i << 1) + 1 | 0);
      var match = hexCharToInt(highChar);
      var match$1 = hexCharToInt(lowChar);
      if (match !== undefined && match$1 !== undefined) {
        bytes[i] = (match << 4) + match$1 | 0;
      } else {
        valid = false;
        errorType = "InvalidCharacter";
      }
    }
    
  }
  if (valid) {
    return {
            TAG: "Ok",
            _0: bytes
          };
  } else {
    return {
            TAG: "Error",
            _0: errorType
          };
  }
}

function decodeToString(hexStr) {
  var e = decode(hexStr);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = {
    contents: ""
  };
  Belt_Array.forEach(e._0, (function ($$byte) {
          result.contents = result.contents + String.fromCharCode($$byte);
        }));
  return {
          TAG: "Ok",
          _0: result.contents
        };
}

function isValidHex(hexStr) {
  var trimmed = hexStr.trim();
  var length = trimmed.length;
  if (length === 0 || length % 2 !== 0) {
    return false;
  } else {
    return /^[0-9a-fA-F]+$/.test(trimmed);
  }
}

function constantTimeEqual(hexA, hexB) {
  var normalizedA = hexA.trim().toLowerCase();
  var normalizedB = hexB.trim().toLowerCase();
  var lengthA = normalizedA.length;
  var lengthB = normalizedB.length;
  var lengthMatch = lengthA === lengthB;
  var maxLength = lengthA > lengthB ? lengthA : lengthB;
  var diff = 0;
  for(var i = 0; i < maxLength; ++i){
    var charA = i < lengthA ? normalizedA.charCodeAt(i) | 0 : 0;
    var charB = i < lengthB ? normalizedB.charCodeAt(i) | 0 : 0;
    diff = diff | charA ^ charB;
  }
  if (lengthMatch) {
    return diff === 0;
  } else {
    return false;
  }
}

function constantTimeEqualBytes(bytesA, bytesB) {
  var lengthA = bytesA.length;
  var lengthB = bytesB.length;
  var lengthMatch = lengthA === lengthB;
  var maxLength = lengthA > lengthB ? lengthA : lengthB;
  var diff = 0;
  for(var i = 0; i < maxLength; ++i){
    var byteA = i < lengthA ? bytesA[i] : 0;
    var byteB = i < lengthB ? bytesB[i] : 0;
    diff = diff | byteA ^ byteB;
  }
  if (lengthMatch) {
    return diff === 0;
  } else {
    return false;
  }
}

function toLowercase(hexStr) {
  if (!isValidHex(hexStr) && hexStr.trim().length > 0) {
    return {
            TAG: "Error",
            _0: "InvalidCharacter"
          };
  } else {
    return {
            TAG: "Ok",
            _0: hexStr.trim().toLowerCase()
          };
  }
}

function toUppercase(hexStr) {
  if (!isValidHex(hexStr) && hexStr.trim().length > 0) {
    return {
            TAG: "Error",
            _0: "InvalidCharacter"
          };
  } else {
    return {
            TAG: "Ok",
            _0: hexStr.trim().toUpperCase()
          };
  }
}

function byteLength(hexStr) {
  var trimmed = hexStr.trim();
  var length = trimmed.length;
  if (length === 0) {
    return {
            TAG: "Ok",
            _0: 0
          };
  } else if (length % 2 !== 0) {
    return {
            TAG: "Error",
            _0: "InvalidLength"
          };
  } else if (isValidHex(trimmed)) {
    return {
            TAG: "Ok",
            _0: length / 2 | 0
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCharacter"
          };
  }
}

function padToByteLength(hexStr, targetByteLength) {
  if (targetByteLength < 0) {
    return {
            TAG: "Error",
            _0: "InvalidLength"
          };
  }
  var e = decode(hexStr);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var bytes = e._0;
  var currentLength = bytes.length;
  if (currentLength > targetByteLength) {
    return {
            TAG: "Error",
            _0: "InvalidLength"
          };
  }
  var padding = Belt_Array.make(targetByteLength - currentLength | 0, 0);
  var paddedBytes = Belt_Array.concat(padding, bytes);
  return encode(paddedBytes);
}

function xorHex(hexA, hexB) {
  var match = decode(hexA);
  var match$1 = decode(hexB);
  if (match.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
  var bytesA = match._0;
  if (match$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match$1._0
          };
  }
  var bytesB = match$1._0;
  if (bytesA.length !== bytesB.length) {
    return {
            TAG: "Error",
            _0: "InvalidLength"
          };
  }
  var result = Belt_Array.mapWithIndex(bytesA, (function (i, byteA) {
          var byteB = bytesB[i];
          return byteA ^ byteB;
        }));
  return encode(result);
}

function encodeSpaced(bytes) {
  if (bytes.length === 0) {
    return {
            TAG: "Ok",
            _0: ""
          };
  }
  var parts = {
    contents: []
  };
  var valid = {
    contents: true
  };
  Belt_Array.forEach(bytes, (function ($$byte) {
          if (!(valid.contents && $$byte >= 0 && $$byte <= 255)) {
            valid.contents = false;
            return ;
          }
          var high = ($$byte >>> 4);
          var low = $$byte & 15;
          var hex = hexChars.charAt(high) + hexChars.charAt(low);
          parts.contents = Belt_Array.concat(parts.contents, [hex]);
        }));
  if (valid.contents) {
    return {
            TAG: "Ok",
            _0: parts.contents.join(" ")
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCharacter"
          };
  }
}

function encodeSpacedUppercase(bytes) {
  if (bytes.length === 0) {
    return {
            TAG: "Ok",
            _0: ""
          };
  }
  var parts = {
    contents: []
  };
  var valid = {
    contents: true
  };
  Belt_Array.forEach(bytes, (function ($$byte) {
          if (!(valid.contents && $$byte >= 0 && $$byte <= 255)) {
            valid.contents = false;
            return ;
          }
          var high = ($$byte >>> 4);
          var low = $$byte & 15;
          var hex = hexCharsUpper.charAt(high) + hexCharsUpper.charAt(low);
          parts.contents = Belt_Array.concat(parts.contents, [hex]);
        }));
  if (valid.contents) {
    return {
            TAG: "Ok",
            _0: parts.contents.join(" ")
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCharacter"
          };
  }
}

export {
  hexChars ,
  hexCharsUpper ,
  hexCharToInt ,
  intToHexChar ,
  encode ,
  encodeUppercase ,
  encodeString ,
  decode ,
  decodeToString ,
  isValidHex ,
  constantTimeEqual ,
  constantTimeEqualBytes ,
  toLowercase ,
  toUppercase ,
  byteLength ,
  padToByteLength ,
  xorHex ,
  encodeSpaced ,
  encodeSpacedUppercase ,
}
/* No side effect */
