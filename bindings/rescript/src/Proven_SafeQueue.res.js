// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function errorToString(error) {
  switch (error) {
    case "QueueFull" :
        return "Queue is full";
    case "QueueEmpty" :
        return "Queue is empty";
    case "InvalidCapacity" :
        return "Invalid capacity specified";
    
  }
}

function make(capacity) {
  if (capacity <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidCapacity"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              data: Belt_Array.make(capacity, undefined),
              head: 0,
              tail: 0,
              length: 0,
              capacity: capacity
            }
          };
  }
}

function length(queue) {
  return queue.length;
}

function isEmpty(queue) {
  return queue.length === 0;
}

function isFull(queue) {
  return queue.length >= queue.capacity;
}

function remaining(queue) {
  return queue.capacity - queue.length | 0;
}

function getCapacity(queue) {
  return queue.capacity;
}

function enqueue(queue, value) {
  if (isFull(queue)) {
    return {
            TAG: "Error",
            _0: "QueueFull"
          };
  } else {
    queue.data[queue.tail] = Caml_option.some(value);
    queue.tail = Caml_int32.mod_(queue.tail + 1 | 0, queue.capacity);
    queue.length = queue.length + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function enqueueDropOldest(queue, value) {
  var dropped;
  if (isFull(queue)) {
    var oldValue = queue.data[queue.head];
    queue.head = Caml_int32.mod_(queue.head + 1 | 0, queue.capacity);
    queue.length = queue.length - 1 | 0;
    dropped = oldValue;
  } else {
    dropped = undefined;
  }
  queue.data[queue.tail] = Caml_option.some(value);
  queue.tail = Caml_int32.mod_(queue.tail + 1 | 0, queue.capacity);
  queue.length = queue.length + 1 | 0;
  return dropped;
}

function dequeue(queue) {
  if (queue.length === 0) {
    return {
            TAG: "Error",
            _0: "QueueEmpty"
          };
  }
  var value = queue.data[queue.head];
  if (value !== undefined) {
    queue.data[queue.head] = undefined;
    queue.head = Caml_int32.mod_(queue.head + 1 | 0, queue.capacity);
    queue.length = queue.length - 1 | 0;
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(value)
          };
  } else {
    return {
            TAG: "Error",
            _0: "QueueEmpty"
          };
  }
}

function peek(queue) {
  if (queue.length === 0) {
    return ;
  } else {
    return queue.data[queue.head];
  }
}

function peekBack(queue) {
  if (queue.length === 0) {
    return ;
  }
  var backIndex = Caml_int32.mod_((queue.tail - 1 | 0) + queue.capacity | 0, queue.capacity);
  return queue.data[backIndex];
}

function clear(queue) {
  for(var i = 0 ,i_finish = queue.capacity; i < i_finish; ++i){
    queue.data[i] = undefined;
  }
  queue.head = 0;
  queue.tail = 0;
  queue.length = 0;
}

function toArray(queue) {
  var result = [];
  var i = queue.head;
  var count = 0;
  while(count < queue.length) {
    var value = queue.data[i];
    if (value !== undefined) {
      result.push(Caml_option.valFromOption(value));
    }
    i = Caml_int32.mod_(i + 1 | 0, queue.capacity);
    count = count + 1 | 0;
  };
  return result;
}

function fromArray(arr, capacity) {
  var arrLen = arr.length;
  if (arrLen > capacity) {
    return {
            TAG: "Error",
            _0: "QueueFull"
          };
  }
  var e = make(capacity);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var queue = e._0;
  Belt_Array.forEach(arr, (function (value) {
          enqueue(queue, value);
        }));
  return {
          TAG: "Ok",
          _0: queue
        };
}

function forEach(queue, fn) {
  var i = queue.head;
  var count = 0;
  while(count < queue.length) {
    var value = queue.data[i];
    if (value !== undefined) {
      fn(Caml_option.valFromOption(value));
    }
    i = Caml_int32.mod_(i + 1 | 0, queue.capacity);
    count = count + 1 | 0;
  };
}

function fillRatio(queue) {
  return queue.length / queue.capacity;
}

function makePriorityQueue(capacity, compare) {
  if (capacity <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidCapacity"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              data: Belt_Array.make(capacity, undefined),
              length: 0,
              capacity: capacity,
              compare: compare
            }
          };
  }
}

function makeMinQueue(capacity) {
  return makePriorityQueue(capacity, (function (a, b) {
                return a - b | 0;
              }));
}

function makeMaxQueue(capacity) {
  return makePriorityQueue(capacity, (function (a, b) {
                return b - a | 0;
              }));
}

function pqLength(pq) {
  return pq.length;
}

function pqIsEmpty(pq) {
  return pq.length === 0;
}

function pqIsFull(pq) {
  return pq.length >= pq.capacity;
}

function siftUp(pq, _index) {
  while(true) {
    var index = _index;
    if (index <= 0) {
      return ;
    }
    var parentIndex = (index - 1 | 0) / 2 | 0;
    var match = pq.data[index];
    var match$1 = pq.data[parentIndex];
    if (match === undefined) {
      return ;
    }
    if (match$1 === undefined) {
      return ;
    }
    var parent = Caml_option.valFromOption(match$1);
    var current = Caml_option.valFromOption(match);
    if (pq.compare(current, parent) >= 0) {
      return ;
    }
    pq.data[index] = Caml_option.some(parent);
    pq.data[parentIndex] = Caml_option.some(current);
    _index = parentIndex;
    continue ;
  };
}

function siftDown(pq, _index) {
  while(true) {
    var index = _index;
    var leftChild = (index << 1) + 1 | 0;
    var rightChild = (index << 1) + 2 | 0;
    var smallestIndex = index;
    if (leftChild < pq.length) {
      var match = pq.data[leftChild];
      var match$1 = pq.data[smallestIndex];
      if (match !== undefined && match$1 !== undefined && pq.compare(Caml_option.valFromOption(match), Caml_option.valFromOption(match$1)) < 0) {
        smallestIndex = leftChild;
      }
      
    }
    if (rightChild < pq.length) {
      var match$2 = pq.data[rightChild];
      var match$3 = pq.data[smallestIndex];
      if (match$2 !== undefined && match$3 !== undefined && pq.compare(Caml_option.valFromOption(match$2), Caml_option.valFromOption(match$3)) < 0) {
        smallestIndex = rightChild;
      }
      
    }
    if (smallestIndex === index) {
      return ;
    }
    var match$4 = pq.data[index];
    var match$5 = pq.data[smallestIndex];
    if (match$4 === undefined) {
      return ;
    }
    if (match$5 === undefined) {
      return ;
    }
    pq.data[index] = Caml_option.some(Caml_option.valFromOption(match$5));
    pq.data[smallestIndex] = Caml_option.some(Caml_option.valFromOption(match$4));
    _index = smallestIndex;
    continue ;
  };
}

function pqPush(pq, value) {
  if (pqIsFull(pq)) {
    return {
            TAG: "Error",
            _0: "QueueFull"
          };
  } else {
    pq.data[pq.length] = Caml_option.some(value);
    pq.length = pq.length + 1 | 0;
    siftUp(pq, pq.length - 1 | 0);
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function pqPop(pq) {
  if (pq.length === 0) {
    return {
            TAG: "Error",
            _0: "QueueEmpty"
          };
  }
  var result = pq.data[0];
  if (result !== undefined) {
    pq.length = pq.length - 1 | 0;
    if (pq.length > 0) {
      pq.data[0] = pq.data[pq.length];
      pq.data[pq.length] = undefined;
      siftDown(pq, 0);
    } else {
      pq.data[0] = undefined;
    }
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(result)
          };
  } else {
    return {
            TAG: "Error",
            _0: "QueueEmpty"
          };
  }
}

function pqPeek(pq) {
  if (pq.length === 0) {
    return ;
  } else {
    return pq.data[0];
  }
}

function pqClear(pq) {
  for(var i = 0 ,i_finish = pq.length; i < i_finish; ++i){
    pq.data[i] = undefined;
  }
  pq.length = 0;
}

export {
  errorToString ,
  make ,
  length ,
  isEmpty ,
  isFull ,
  remaining ,
  getCapacity ,
  enqueue ,
  enqueueDropOldest ,
  dequeue ,
  peek ,
  peekBack ,
  clear ,
  toArray ,
  fromArray ,
  forEach ,
  fillRatio ,
  makePriorityQueue ,
  makeMinQueue ,
  makeMaxQueue ,
  pqLength ,
  pqIsEmpty ,
  pqIsFull ,
  siftUp ,
  siftDown ,
  pqPush ,
  pqPop ,
  pqPeek ,
  pqClear ,
}
/* No side effect */
