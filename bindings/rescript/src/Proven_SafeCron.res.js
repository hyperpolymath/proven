// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Proven_Bitwise from "./Proven_Bitwise.res.js";

var minuteRange = {
  min: 0,
  max: 59
};

var hourRange = {
  min: 0,
  max: 23
};

var dayOfMonthRange = {
  min: 1,
  max: 31
};

var monthRange = {
  min: 1,
  max: 12
};

var dayOfWeekRange = {
  min: 0,
  max: 6
};

var dayNames = [
  "sun",
  "mon",
  "tue",
  "wed",
  "thu",
  "fri",
  "sat"
];

var monthNames = [
  "jan",
  "feb",
  "mar",
  "apr",
  "may",
  "jun",
  "jul",
  "aug",
  "sep",
  "oct",
  "nov",
  "dec"
];

function matches(cronExpr, minute, hour, day, month, dayOfWeek) {
  if (minute < 0 || minute > 59) {
    return false;
  }
  if (hour < 0 || hour > 23) {
    return false;
  }
  if (day < 1 || day > 31) {
    return false;
  }
  if (month < 1 || month > 12) {
    return false;
  }
  if (dayOfWeek < 0 || dayOfWeek > 6) {
    return false;
  }
  var minuteBit = Math.pow(2.0, minute);
  var minuteMatch = (cronExpr.minutes / minuteBit | 0) % 2 === 1;
  var hourMask = Proven_Bitwise.lsl(1, hour);
  var hourMatch = Proven_Bitwise.land(cronExpr.hours, hourMask) !== 0;
  var dayMask = Proven_Bitwise.lsl(1, day);
  var dayMatch = Proven_Bitwise.land(cronExpr.daysOfMonth, dayMask) !== 0;
  var monthMask = Proven_Bitwise.lsl(1, month);
  var monthMatch = Proven_Bitwise.land(cronExpr.months, monthMask) !== 0;
  var dowMask = Proven_Bitwise.lsl(1, dayOfWeek);
  var dowMatch = Proven_Bitwise.land(cronExpr.daysOfWeek, dowMask) !== 0;
  if (minuteMatch && hourMatch && dayMatch && monthMatch) {
    return dowMatch;
  } else {
    return false;
  }
}

function isEveryMinute(cronExpr) {
  var allMinutes = Math.pow(2.0, 60.0) - 1.0;
  var allHours = Proven_Bitwise.lsl(1, 24) - 1 | 0;
  var allDays = Proven_Bitwise.lsl(1, 32) - 2 | 0;
  var allMonths = Proven_Bitwise.lsl(1, 13) - 2 | 0;
  var allDaysOfWeek = Proven_Bitwise.lsl(1, 7) - 1 | 0;
  if (cronExpr.minutes === allMinutes && cronExpr.hours === allHours && cronExpr.daysOfMonth === allDays && cronExpr.months === allMonths) {
    return cronExpr.daysOfWeek === allDaysOfWeek;
  } else {
    return false;
  }
}

function popCount(n) {
  var count = 0;
  var value = n;
  while(value > 0) {
    count = count + Proven_Bitwise.land(value, 1) | 0;
    value = Proven_Bitwise.lsr(value, 1);
  };
  return count;
}

function popCountFloat(n) {
  var count = 0;
  var value = n;
  while(value > 0.0) {
    if ((value | 0) % 2 === 1) {
      count = count + 1 | 0;
    }
    value = Math.floor(value / 2.0);
  };
  return count;
}

function countMinutes(cronExpr) {
  return popCountFloat(cronExpr.minutes);
}

function countHours(cronExpr) {
  return popCount(cronExpr.hours);
}

function parseValue(value, range, names) {
  var num = Belt_Int.fromString(value);
  if (num !== undefined) {
    if (num < range.min || num > range.max) {
      return {
              TAG: "Error",
              _0: "ValueOutOfRange"
            };
    } else {
      return {
              TAG: "Ok",
              _0: num
            };
    }
  }
  if (names === undefined) {
    return {
            TAG: "Error",
            _0: "MalformedField"
          };
  }
  var lower = value.toLowerCase();
  var shortName = lower.length >= 3 ? lower.slice(0, 3) : lower;
  var index = Belt_Array.getIndexBy(names, (function (name) {
          return name === shortName;
        }));
  if (index === undefined) {
    if (range.min === 1) {
      return {
              TAG: "Error",
              _0: "InvalidMonthName"
            };
    } else {
      return {
              TAG: "Error",
              _0: "InvalidDayName"
            };
    }
  }
  var resultValue = range.min === 1 ? index + 1 | 0 : index;
  return {
          TAG: "Ok",
          _0: resultValue
        };
}

function parseFieldItem(item, range, names) {
  if (item.length === 0) {
    return {
            TAG: "Error",
            _0: "MalformedField"
          };
  }
  var slashPos = item.indexOf("/");
  var match;
  if (slashPos !== -1) {
    var stepPart = item.slice(slashPos + 1 | 0);
    var s = Belt_Int.fromString(stepPart);
    match = s !== undefined && s !== 0 ? [
        item.slice(0, slashPos),
        s
      ] : [
        item,
        0
      ];
  } else {
    match = [
      item,
      1
    ];
  }
  var step = match[1];
  if (step === 0) {
    return {
            TAG: "Error",
            _0: "InvalidStep"
          };
  }
  var mainPart = match[0];
  var match$1;
  if (mainPart === "*") {
    match$1 = [
      range.min,
      range.max
    ];
  } else {
    var dashPos = mainPart.indexOf("-");
    if (dashPos !== -1) {
      var startPart = mainPart.slice(0, dashPos);
      var endPart = mainPart.slice(dashPos + 1 | 0);
      var match$2 = parseValue(startPart, range, names);
      var match$3 = parseValue(endPart, range, names);
      match$1 = match$2.TAG === "Ok" && match$3.TAG === "Ok" ? [
          match$2._0,
          match$3._0
        ] : [
          -1,
          -1
        ];
    } else {
      var v = parseValue(mainPart, range, names);
      if (v.TAG === "Ok") {
        var v$1 = v._0;
        match$1 = [
          v$1,
          v$1
        ];
      } else {
        match$1 = [
          -1,
          -1
        ];
      }
    }
  }
  var rangeStart = match$1[0];
  if (rangeStart === -1) {
    return {
            TAG: "Error",
            _0: "MalformedField"
          };
  }
  var rangeEnd = match$1[1];
  if (rangeStart > rangeEnd) {
    return {
            TAG: "Error",
            _0: "InvalidRange"
          };
  }
  var values = [];
  var current = rangeStart;
  while(current <= rangeEnd) {
    values = Belt_Array.concat(values, [current]);
    current = current + step | 0;
  };
  return {
          TAG: "Ok",
          _0: values
        };
}

function parseField(field, range, names) {
  var items = field.split(",");
  var allValues = {
    contents: []
  };
  var error = {
    contents: undefined
  };
  Belt_Array.forEach(items, (function (item) {
          if (error.contents !== undefined) {
            return ;
          }
          var values = parseFieldItem(item, range, names);
          if (values.TAG === "Ok") {
            allValues.contents = Belt_Array.concat(allValues.contents, values._0);
          } else {
            error.contents = values._0;
          }
        }));
  var e = error.contents;
  if (e !== undefined) {
    return {
            TAG: "Error",
            _0: e
          };
  } else {
    return {
            TAG: "Ok",
            _0: allValues.contents
          };
  }
}

function valuesToBitmaskFloat(values) {
  return Belt_Array.reduce(values, 0.0, (function (acc, v) {
                return acc + Math.pow(2.0, v);
              }));
}

function valuesToBitmask(values) {
  return Belt_Array.reduce(values, 0, (function (acc, v) {
                return Proven_Bitwise.lor(acc, Proven_Bitwise.lsl(1, v));
              }));
}

function parse(expression) {
  var parts = expression.split(" ");
  var fields = Belt_Array.keep(parts, (function (part) {
          return part.length > 0;
        }));
  if (fields.length !== 5) {
    return {
            TAG: "Error",
            _0: "InvalidFieldCount"
          };
  }
  var minuteField = Belt_Array.getExn(fields, 0);
  var hourField = Belt_Array.getExn(fields, 1);
  var dayField = Belt_Array.getExn(fields, 2);
  var monthField = Belt_Array.getExn(fields, 3);
  var dowField = Belt_Array.getExn(fields, 4);
  var e = parseField(minuteField, minuteRange, undefined);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var e$1 = parseField(hourField, hourRange, undefined);
  if (e$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
  var e$2 = parseField(dayField, dayOfMonthRange, undefined);
  if (e$2.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e$2._0
          };
  }
  var e$3 = parseField(monthField, monthRange, monthNames);
  if (e$3.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e$3._0
          };
  }
  var e$4 = parseField(dowField, dayOfWeekRange, dayNames);
  if (e$4.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: {
              minutes: valuesToBitmaskFloat(e._0),
              hours: valuesToBitmask(e$1._0),
              daysOfMonth: valuesToBitmask(e$2._0),
              months: valuesToBitmask(e$3._0),
              daysOfWeek: valuesToBitmask(e$4._0)
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: e$4._0
          };
  }
}

function isValid(expression) {
  var match = parse(expression);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

var hourly = "0 * * * *";

var daily = "0 0 * * *";

var weekly = "0 0 * * 0";

var monthly = "0 0 1 * *";

var yearly = "0 0 1 1 *";

var Presets = {
  everyMinute: "* * * * *",
  hourly: hourly,
  daily: daily,
  weekly: weekly,
  monthly: monthly,
  yearly: yearly
};

function parseOrPreset(expression) {
  if (!(expression.length > 0 && expression.charAt(0) === "@")) {
    return parse(expression);
  }
  var preset = expression.slice(1);
  switch (preset) {
    case "hourly" :
        return parse(hourly);
    case "daily" :
    case "midnight" :
        return parse(daily);
    case "monthly" :
        return parse(monthly);
    case "weekly" :
        return parse(weekly);
    case "annually" :
    case "yearly" :
        return parse(yearly);
    default:
      return {
              TAG: "Error",
              _0: "MalformedField"
            };
  }
}

function describe(cronExpr) {
  if (isEveryMinute(cronExpr)) {
    return "every minute";
  }
  var minuteCount = popCountFloat(cronExpr.minutes);
  var hourCount = popCount(cronExpr.hours);
  if (minuteCount === 1 && hourCount === 24) {
    return "once per hour";
  } else if (minuteCount === 1 && hourCount === 1) {
    return "once per day";
  } else {
    return "custom schedule";
  }
}

function everyHourAt(minute) {
  if (minute < 0 || minute > 59) {
    return {
            TAG: "Error",
            _0: "ValueOutOfRange"
          };
  } else {
    return parse(String(minute) + " * * * *");
  }
}

function everyDayAt(hour, minute) {
  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {
    return {
            TAG: "Error",
            _0: "ValueOutOfRange"
          };
  } else {
    return parse(String(minute) + " " + String(hour) + " * * *");
  }
}

function everyNMinutes(n) {
  if (n < 1 || n > 59) {
    return {
            TAG: "Error",
            _0: "InvalidStep"
          };
  } else {
    return parse("*/" + String(n) + " * * * *");
  }
}

function everyNHours(n) {
  if (n < 1 || n > 23) {
    return {
            TAG: "Error",
            _0: "InvalidStep"
          };
  } else {
    return parse("0 */" + String(n) + " * * *");
  }
}

function onDaysOfWeek(days, hour, minute) {
  if (hour < 0 || hour > 23) {
    return {
            TAG: "Error",
            _0: "ValueOutOfRange"
          };
  }
  if (minute < 0 || minute > 59) {
    return {
            TAG: "Error",
            _0: "ValueOutOfRange"
          };
  }
  if (days.length === 0) {
    return {
            TAG: "Error",
            _0: "MalformedField"
          };
  }
  var invalidDay = Belt_Array.getBy(days, (function (d) {
          if (d < 0) {
            return true;
          } else {
            return d > 6;
          }
        }));
  if (invalidDay !== undefined) {
    return {
            TAG: "Error",
            _0: "ValueOutOfRange"
          };
  }
  var dayList = Belt_Array.map(days, (function (prim) {
            return String(prim);
          })).join(",");
  return parse(String(minute) + " " + String(hour) + " * * " + dayList);
}

function matchesDate(cronExpr, date) {
  var minute = date.getMinutes() | 0;
  var hour = date.getHours() | 0;
  var day = date.getDate() | 0;
  var month = (date.getMonth() | 0) + 1 | 0;
  var dayOfWeek = date.getDay() | 0;
  return matches(cronExpr, minute, hour, day, month, dayOfWeek);
}

export {
  minuteRange ,
  hourRange ,
  dayOfMonthRange ,
  monthRange ,
  dayOfWeekRange ,
  dayNames ,
  monthNames ,
  matches ,
  isEveryMinute ,
  popCount ,
  popCountFloat ,
  countMinutes ,
  countHours ,
  parseValue ,
  parseFieldItem ,
  parseField ,
  valuesToBitmaskFloat ,
  valuesToBitmask ,
  parse ,
  isValid ,
  Presets ,
  parseOrPreset ,
  describe ,
  everyHourAt ,
  everyDayAt ,
  everyNMinutes ,
  everyNHours ,
  onDaysOfWeek ,
  matchesDate ,
}
/* No side effect */
