// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function entryTypeFromString(str) {
  var lower = str.toLowerCase();
  switch (lower) {
    case "article" :
        return "Article";
    case "book" :
        return "Book";
    case "booklet" :
        return "Booklet";
    case "conference" :
        return "Conference";
    case "dataset" :
        return "Dataset";
    case "inbook" :
        return "Inbook";
    case "incollection" :
        return "Incollection";
    case "inproceedings" :
        return "Inproceedings";
    case "manual" :
        return "Manual";
    case "mastersthesis" :
        return "Mastersthesis";
    case "misc" :
        return "Misc";
    case "online" :
        return "Online";
    case "phdthesis" :
        return "Phdthesis";
    case "proceedings" :
        return "Proceedings";
    case "software" :
        return "Software";
    case "techreport" :
        return "Techreport";
    case "unpublished" :
        return "Unpublished";
    default:
      return "Unknown";
  }
}

function entryTypeToString(entryType) {
  switch (entryType) {
    case "Article" :
        return "article";
    case "Book" :
        return "book";
    case "Booklet" :
        return "booklet";
    case "Conference" :
        return "conference";
    case "Inbook" :
        return "inbook";
    case "Incollection" :
        return "incollection";
    case "Inproceedings" :
        return "inproceedings";
    case "Manual" :
        return "manual";
    case "Mastersthesis" :
        return "mastersthesis";
    case "Misc" :
        return "misc";
    case "Phdthesis" :
        return "phdthesis";
    case "Proceedings" :
        return "proceedings";
    case "Techreport" :
        return "techreport";
    case "Unpublished" :
        return "unpublished";
    case "Online" :
        return "online";
    case "Software" :
        return "software";
    case "Dataset" :
        return "dataset";
    case "Unknown" :
        return "unknown";
    
  }
}

function getField(entry, key) {
  var lowerKey = key.toLowerCase();
  return Belt_Option.map(Belt_Array.getBy(entry.fields, (function (field) {
                    return field.key.toLowerCase() === lowerKey;
                  })), (function (field) {
                return field.value;
              }));
}

function hasField(entry, key) {
  return Belt_Option.isSome(getField(entry, key));
}

function getAuthor(entry) {
  return getField(entry, "author");
}

function getTitle(entry) {
  return getField(entry, "title");
}

function getYear(entry) {
  return getField(entry, "year");
}

function getJournal(entry) {
  return getField(entry, "journal");
}

function getDoi(entry) {
  return getField(entry, "doi");
}

function getUrl(entry) {
  return getField(entry, "url");
}

function requiredFieldsForType(entryType) {
  switch (entryType) {
    case "Article" :
        return [
                "author",
                "title",
                "journal",
                "year"
              ];
    case "Book" :
        return [
                "author",
                "title",
                "publisher",
                "year"
              ];
    case "Inproceedings" :
        return [
                "author",
                "title",
                "booktitle",
                "year"
              ];
    case "Mastersthesis" :
    case "Phdthesis" :
        return [
                "author",
                "title",
                "school",
                "year"
              ];
    case "Techreport" :
        return [
                "author",
                "title",
                "institution",
                "year"
              ];
    default:
      return [];
  }
}

function isValidCiteKey(key) {
  var length = key.length;
  if (length === 0 || length > 256) {
    return false;
  }
  var firstCode = key.charCodeAt(0) | 0;
  var firstIsAlphanumeric = firstCode >= 48 && firstCode <= 57 || firstCode >= 65 && firstCode <= 90 || firstCode >= 97 && firstCode <= 122;
  if (!firstIsAlphanumeric) {
    return false;
  }
  var valid = true;
  for(var index = 0; index < length; ++index){
    if (valid) {
      var charCode = key.charCodeAt(index) | 0;
      var isValidChar = charCode >= 48 && charCode <= 57 || charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || charCode === 95 || charCode === 45 || charCode === 58 || charCode === 46;
      if (!isValidChar) {
        valid = false;
      }
      
    }
    
  }
  return valid;
}

function validateRequiredFields(entry) {
  var requiredFields = requiredFieldsForType(entry.entryType);
  var missingField = Belt_Array.getBy(requiredFields, (function (fieldName) {
          return !hasField(entry, fieldName);
        }));
  if (missingField !== undefined) {
    return {
            TAG: "Error",
            _0: "MissingField"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function parseFieldValue(input, position) {
  while(position.contents < input.length) {
    var currentChar = input.charAt(position.contents);
    if (currentChar === " " || currentChar === "\t" || currentChar === "\n" || currentChar === "\r") {
      position.contents = position.contents + 1 | 0;
    } else {
      position.contents = input.length + 1 | 0;
    }
  };
  var length = input.length;
  var findStart = 0;
  while(findStart < length) {
    var currentChar$1 = input.charAt(findStart);
    findStart = currentChar$1 === " " || currentChar$1 === "\t" || currentChar$1 === "\n" || currentChar$1 === "\r" ? findStart + 1 | 0 : length + 1 | 0;
  };
  if (position.contents >= length) {
    return {
            TAG: "Error",
            _0: "MalformedEntry"
          };
  }
  var firstChar = input.charAt(position.contents);
  if (firstChar === "{") {
    position.contents = position.contents + 1 | 0;
    var valueStart = position.contents;
    var braceDepth = 1;
    while(position.contents < length && braceDepth > 0) {
      var currentChar$2 = input.charAt(position.contents);
      if (currentChar$2 === "{") {
        braceDepth = braceDepth + 1 | 0;
        position.contents = position.contents + 1 | 0;
      } else if (currentChar$2 === "}") {
        braceDepth = braceDepth - 1 | 0;
        if (braceDepth > 0) {
          position.contents = position.contents + 1 | 0;
        }
        
      } else {
        position.contents = position.contents + 1 | 0;
      }
    };
    if (braceDepth !== 0) {
      return {
              TAG: "Error",
              _0: "UnterminatedBrace"
            };
    }
    var value = input.slice(valueStart, position.contents);
    position.contents = position.contents + 1 | 0;
    return {
            TAG: "Ok",
            _0: value
          };
  }
  if (firstChar === "\"") {
    position.contents = position.contents + 1 | 0;
    var valueStart$1 = position.contents;
    while(position.contents < length && input.charAt(position.contents) !== "\"") {
      var currentChar$3 = input.charAt(position.contents);
      if (currentChar$3 === "\\" && (position.contents + 1 | 0) < length) {
        position.contents = position.contents + 2 | 0;
      } else {
        position.contents = position.contents + 1 | 0;
      }
    };
    if (position.contents >= length) {
      return {
              TAG: "Error",
              _0: "UnterminatedString"
            };
    }
    var value$1 = input.slice(valueStart$1, position.contents);
    position.contents = position.contents + 1 | 0;
    return {
            TAG: "Ok",
            _0: value$1
          };
  }
  var valueStart$2 = position.contents;
  while(position.contents < length) {
    var charCode = input.charCodeAt(position.contents) | 0;
    var isAlphanumeric = charCode >= 48 && charCode <= 57 || charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122;
    if (isAlphanumeric) {
      position.contents = position.contents + 1 | 0;
    } else {
      position.contents = length + 1 | 0;
    }
  };
  var findEnd = valueStart$2;
  while(findEnd < length) {
    var charCode$1 = input.charCodeAt(findEnd) | 0;
    var isAlphanumeric$1 = charCode$1 >= 48 && charCode$1 <= 57 || charCode$1 >= 65 && charCode$1 <= 90 || charCode$1 >= 97 && charCode$1 <= 122;
    findEnd = isAlphanumeric$1 ? findEnd + 1 | 0 : length + 1 | 0;
  };
  if (findEnd === valueStart$2) {
    return {
            TAG: "Error",
            _0: "MalformedEntry"
          };
  }
  var end = valueStart$2;
  while(end < length) {
    var charCode$2 = input.charCodeAt(end) | 0;
    var isAlphanumeric$2 = charCode$2 >= 48 && charCode$2 <= 57 || charCode$2 >= 65 && charCode$2 <= 90 || charCode$2 >= 97 && charCode$2 <= 122;
    end = isAlphanumeric$2 ? end + 1 | 0 : length + 1 | 0;
  };
  var actualEnd = end;
  position.contents = actualEnd;
  return {
          TAG: "Ok",
          _0: input.slice(valueStart$2, actualEnd)
        };
}

function parseEntry(input) {
  if (input.length === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var cursor = 0;
  var length = input.length;
  while(cursor < length) {
    var currentChar = input.charAt(cursor);
    cursor = currentChar === " " || currentChar === "\t" || currentChar === "\n" || currentChar === "\r" ? cursor + 1 | 0 : length + 1 | 0;
  };
  cursor = 0;
  while(cursor < length && (input.charAt(cursor) === " " || input.charAt(cursor) === "\t" || input.charAt(cursor) === "\n" || input.charAt(cursor) === "\r")) {
    cursor = cursor + 1 | 0;
  };
  if (cursor >= length || input.charAt(cursor) !== "@") {
    return {
            TAG: "Error",
            _0: "MalformedEntry"
          };
  }
  cursor = cursor + 1 | 0;
  var entryTypeStart = cursor;
  while(cursor < length) {
    var charCode = input.charCodeAt(cursor) | 0;
    var isAlpha = charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122;
    cursor = isAlpha ? cursor + 1 | 0 : length + 1 | 0;
  };
  var end = entryTypeStart;
  while(end < length) {
    var charCode$1 = input.charCodeAt(end) | 0;
    var isAlpha$1 = charCode$1 >= 65 && charCode$1 <= 90 || charCode$1 >= 97 && charCode$1 <= 122;
    end = isAlpha$1 ? end + 1 | 0 : length + 1 | 0;
  };
  var entryTypeEnd = end;
  if (entryTypeEnd === entryTypeStart) {
    return {
            TAG: "Error",
            _0: "InvalidEntryType"
          };
  }
  var entryTypeStr = input.slice(entryTypeStart, entryTypeEnd);
  var entryType = entryTypeFromString(entryTypeStr);
  cursor = entryTypeEnd;
  while(cursor < length && (input.charAt(cursor) === " " || input.charAt(cursor) === "\t" || input.charAt(cursor) === "\n" || input.charAt(cursor) === "\r")) {
    cursor = cursor + 1 | 0;
  };
  if (cursor >= length) {
    return {
            TAG: "Error",
            _0: "MalformedEntry"
          };
  }
  var openingChar = input.charAt(cursor);
  if (openingChar !== "{" && openingChar !== "(") {
    return {
            TAG: "Error",
            _0: "MalformedEntry"
          };
  }
  var closingChar = openingChar === "{" ? "}" : ")";
  cursor = cursor + 1 | 0;
  while(cursor < length && (input.charAt(cursor) === " " || input.charAt(cursor) === "\t" || input.charAt(cursor) === "\n" || input.charAt(cursor) === "\r")) {
    cursor = cursor + 1 | 0;
  };
  var citeKeyStart = cursor;
  while(cursor < length && input.charAt(cursor) !== "," && input.charAt(cursor) !== " " && input.charAt(cursor) !== "\t") {
    cursor = cursor + 1 | 0;
  };
  if (cursor === citeKeyStart) {
    return {
            TAG: "Error",
            _0: "InvalidCiteKey"
          };
  }
  var citeKey = input.slice(citeKeyStart, cursor);
  if (!isValidCiteKey(citeKey)) {
    return {
            TAG: "Error",
            _0: "InvalidCiteKey"
          };
  }
  while(cursor < length && input.charAt(cursor) !== "," && input.charAt(cursor) !== closingChar) {
    cursor = cursor + 1 | 0;
  };
  if (cursor < length && input.charAt(cursor) === ",") {
    cursor = cursor + 1 | 0;
  }
  var fields = [];
  while(cursor < length && input.charAt(cursor) !== closingChar) {
    cursor = cursor + 1 | 0;
  };
  return {
          TAG: "Ok",
          _0: {
            entryType: entryType,
            citeKey: citeKey,
            fields: fields
          }
        };
}

function isValidEntry(input) {
  var match = parseEntry(input);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function formatEntry(entry) {
  var result = {
    contents: "@" + entryTypeToString(entry.entryType) + "{" + entry.citeKey + ",\n"
  };
  Belt_Array.forEachWithIndex(entry.fields, (function (index, field) {
          result.contents = result.contents + ("  " + field.key + " = {" + field.value + "}");
          if (index < (entry.fields.length - 1 | 0)) {
            result.contents = result.contents + ",";
          }
          result.contents = result.contents + "\n";
        }));
  return result.contents + "}\n";
}

function escapeString(input) {
  return input.replace(/\\/g, "\\textbackslash{}").replace(/{/g, "\\{").replace(/}/g, "\\}").replace(/&/g, "\\&").replace(/%/g, "\\%").replace(/\\$/g, "\\$").replace(/#/g, "\\#").replace(/_/g, "\\_").replace(/~/g, "\\textasciitilde{}").replace(/\\^/g, "\\textasciicircum{}");
}

function createEntry(entryType, citeKey, fields) {
  if (isValidCiteKey(citeKey)) {
    return {
            TAG: "Ok",
            _0: {
              entryType: entryType,
              citeKey: citeKey,
              fields: fields
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCiteKey"
          };
  }
}

function addField(entry, key, value) {
  return {
          entryType: entry.entryType,
          citeKey: entry.citeKey,
          fields: Belt_Array.concat(entry.fields, [{
                  key: key,
                  value: value
                }])
        };
}

function removeField(entry, key) {
  var lowerKey = key.toLowerCase();
  return {
          entryType: entry.entryType,
          citeKey: entry.citeKey,
          fields: Belt_Array.keep(entry.fields, (function (field) {
                  return field.key.toLowerCase() !== lowerKey;
                }))
        };
}

function updateField(entry, key, value) {
  var lowerKey = key.toLowerCase();
  var fieldExists = Belt_Array.some(entry.fields, (function (field) {
          return field.key.toLowerCase() === lowerKey;
        }));
  if (fieldExists) {
    return {
            entryType: entry.entryType,
            citeKey: entry.citeKey,
            fields: Belt_Array.map(entry.fields, (function (field) {
                    if (field.key.toLowerCase() === lowerKey) {
                      return {
                              key: field.key,
                              value: value
                            };
                    } else {
                      return field;
                    }
                  }))
          };
  } else {
    return addField(entry, key, value);
  }
}

export {
  entryTypeFromString ,
  entryTypeToString ,
  getField ,
  hasField ,
  getAuthor ,
  getTitle ,
  getYear ,
  getJournal ,
  getDoi ,
  getUrl ,
  requiredFieldsForType ,
  isValidCiteKey ,
  validateRequiredFields ,
  parseFieldValue ,
  parseEntry ,
  isValidEntry ,
  formatEntry ,
  escapeString ,
  createEntry ,
  addField ,
  removeField ,
  updateField ,
}
/* No side effect */
