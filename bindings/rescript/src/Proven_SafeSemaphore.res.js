// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";

function createCountingSemaphore(maxPermits, initialPermits) {
  var initial = initialPermits < maxPermits ? initialPermits : maxPermits;
  return {
          available: 0 > initial ? 0 : initial,
          max: 0 > maxPermits ? 0 : maxPermits,
          totalAcquired: 0,
          totalReleased: 0
        };
}

function createFull(maxPermits) {
  return createCountingSemaphore(maxPermits, maxPermits);
}

function createEmpty(maxPermits) {
  return createCountingSemaphore(maxPermits, 0);
}

function availablePermits(sem) {
  return sem.available;
}

function maxPermits(sem) {
  return sem.max;
}

function hasAvailable(sem) {
  return sem.available > 0;
}

function isFull(sem) {
  return sem.available === sem.max;
}

function isEmpty(sem) {
  return sem.available === 0;
}

function heldPermits(sem) {
  return sem.max - sem.available | 0;
}

function tryAcquire(sem) {
  if (sem.available < 1) {
    return {
            TAG: "Error",
            _0: "NoPermitsAvailable"
          };
  } else {
    sem.available = sem.available - 1 | 0;
    sem.totalAcquired = sem.totalAcquired + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function tryAcquireMany(sem, count) {
  if (count <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidPermitCount"
          };
  } else if (count > sem.max) {
    return {
            TAG: "Error",
            _0: "TooManyPermits"
          };
  } else if (sem.available < count) {
    return {
            TAG: "Error",
            _0: "NoPermitsAvailable"
          };
  } else {
    sem.available = sem.available - count | 0;
    sem.totalAcquired = sem.totalAcquired + count | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function tryAcquireResult(sem) {
  if (sem.available < 1) {
    return {
            TAG: "Unavailable",
            _0: 1
          };
  } else {
    sem.available = sem.available - 1 | 0;
    sem.totalAcquired = sem.totalAcquired + 1 | 0;
    return "Acquired";
  }
}

function tryAcquireManyResult(sem, count) {
  if (count <= 0 || count > sem.max) {
    return {
            TAG: "Unavailable",
            _0: count
          };
  } else if (sem.available < count) {
    return {
            TAG: "Unavailable",
            _0: count - sem.available | 0
          };
  } else {
    sem.available = sem.available - count | 0;
    sem.totalAcquired = sem.totalAcquired + count | 0;
    return "Acquired";
  }
}

function release(sem) {
  if (sem.available >= sem.max) {
    return {
            TAG: "Error",
            _0: "WouldOverflow"
          };
  } else {
    sem.available = sem.available + 1 | 0;
    sem.totalReleased = sem.totalReleased + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function releaseMany(sem, count) {
  if (count <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidPermitCount"
          };
  } else if ((sem.available + count | 0) > sem.max) {
    return {
            TAG: "Error",
            _0: "WouldOverflow"
          };
  } else {
    sem.available = sem.available + count | 0;
    sem.totalReleased = sem.totalReleased + count | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function releaseSaturating(sem, count) {
  var newAvailable = sem.available + count | 0;
  var actualRelease = Caml.int_min(count, sem.max - sem.available | 0);
  sem.available = newAvailable < sem.max ? newAvailable : sem.max;
  sem.totalReleased = sem.totalReleased + actualRelease | 0;
}

function drainAll(sem) {
  var drained = sem.available;
  sem.totalAcquired = sem.totalAcquired + drained | 0;
  sem.available = 0;
  return drained;
}

function reset(sem, permits) {
  sem.available = Caml.int_min(0 > permits ? 0 : permits, sem.max);
  sem.totalAcquired = 0;
  sem.totalReleased = 0;
}

function stats(sem) {
  return {
          available: sem.available,
          max: sem.max,
          held: sem.max - sem.available | 0,
          totalAcquired: sem.totalAcquired,
          totalReleased: sem.totalReleased
        };
}

function utilizationPercent(s) {
  if (s.max === 0) {
    return 0.0;
  } else {
    return s.held / s.max * 100.0;
  }
}

function createBinarySemaphore() {
  return {
          locked: false,
          lockCount: 0,
          unlockCount: 0
        };
}

function createBinarySemaphoreLocked() {
  return {
          locked: true,
          lockCount: 0,
          unlockCount: 0
        };
}

function isLocked(sem) {
  return sem.locked;
}

function isUnlocked(sem) {
  return !sem.locked;
}

function tryLock(sem) {
  if (sem.locked) {
    return {
            TAG: "Error",
            _0: "NoPermitsAvailable"
          };
  } else {
    sem.locked = true;
    sem.lockCount = sem.lockCount + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function tryLockResult(sem) {
  if (sem.locked) {
    return false;
  } else {
    sem.locked = true;
    sem.lockCount = sem.lockCount + 1 | 0;
    return true;
  }
}

function unlock(sem) {
  if (sem.locked) {
    sem.locked = false;
    sem.unlockCount = sem.unlockCount + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: "AlreadyReleased"
          };
  }
}

function forceUnlock(sem) {
  if (sem.locked) {
    sem.locked = false;
    sem.unlockCount = sem.unlockCount + 1 | 0;
    return ;
  }
  
}

function resetBinary(sem) {
  sem.locked = false;
  sem.lockCount = 0;
  sem.unlockCount = 0;
}

function createWeightedSemaphore(maxWeight, initialWeight) {
  var mw = 0 > maxWeight ? 0 : maxWeight;
  return {
          availableWeight: Caml.int_min(0 > initialWeight ? 0 : initialWeight, mw),
          maxWeight: mw
        };
}

function createWeightedSemaphoreFull(maxWeight) {
  return createWeightedSemaphore(maxWeight, maxWeight);
}

function tryAcquireWeight(sem, weight) {
  if (weight <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidPermitCount"
          };
  } else if (weight > sem.maxWeight) {
    return {
            TAG: "Error",
            _0: "TooManyPermits"
          };
  } else if (sem.availableWeight < weight) {
    return {
            TAG: "Error",
            _0: "NoPermitsAvailable"
          };
  } else {
    sem.availableWeight = sem.availableWeight - weight | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function releaseWeight(sem, weight) {
  if (weight <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidPermitCount"
          };
  } else if ((sem.availableWeight + weight | 0) > sem.maxWeight) {
    return {
            TAG: "Error",
            _0: "WouldOverflow"
          };
  } else {
    sem.availableWeight = sem.availableWeight + weight | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function getAvailableWeight(sem) {
  return sem.availableWeight;
}

function canAcquireWeight(sem, weight) {
  return weight <= sem.availableWeight;
}

export {
  createCountingSemaphore ,
  createFull ,
  createEmpty ,
  availablePermits ,
  maxPermits ,
  hasAvailable ,
  isFull ,
  isEmpty ,
  heldPermits ,
  tryAcquire ,
  tryAcquireMany ,
  tryAcquireResult ,
  tryAcquireManyResult ,
  release ,
  releaseMany ,
  releaseSaturating ,
  drainAll ,
  reset ,
  stats ,
  utilizationPercent ,
  createBinarySemaphore ,
  createBinarySemaphoreLocked ,
  isLocked ,
  isUnlocked ,
  tryLock ,
  tryLockResult ,
  unlock ,
  forceUnlock ,
  resetBinary ,
  createWeightedSemaphore ,
  createWeightedSemaphoreFull ,
  tryAcquireWeight ,
  releaseWeight ,
  getAvailableWeight ,
  canAcquireWeight ,
}
/* No side effect */
