// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Float from "rescript/lib/es6/belt_Float.js";

function toRadians(degrees) {
  return degrees * Math.PI / 180.0;
}

function toDegrees(radians) {
  return radians * 180.0 / Math.PI;
}

function isValidLatitude(lat) {
  if (lat >= -90.0) {
    return lat <= 90.0;
  } else {
    return false;
  }
}

function isValidLongitude(lon) {
  if (lon >= -180.0) {
    return lon <= 180.0;
  } else {
    return false;
  }
}

function makeCoordinate(lat, lon) {
  if (isValidLatitude(lat)) {
    if (isValidLongitude(lon)) {
      return {
              TAG: "Ok",
              _0: {
                lat: lat,
                lon: lon
              }
            };
    } else {
      return {
              TAG: "Error",
              _0: "InvalidLongitude"
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: "InvalidLatitude"
          };
  }
}

function makeCoordinateClamped(lat, lon) {
  var clampedLat = Math.max(-90.0, Math.min(90.0, lat));
  var clampedLon = Math.max(-180.0, Math.min(180.0, lon));
  return {
          lat: clampedLat,
          lon: clampedLon
        };
}

function makeCoordinateUnsafe(lat, lon) {
  return {
          lat: lat,
          lon: lon
        };
}

function distanceMeters(coord1, coord2) {
  var lat1 = toRadians(coord1.lat);
  var lat2 = toRadians(coord2.lat);
  var deltaLat = toRadians(coord2.lat - coord1.lat);
  var deltaLon = toRadians(coord2.lon - coord1.lon);
  var a = Math.sin(deltaLat / 2.0) * Math.sin(deltaLat / 2.0) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2.0) * Math.sin(deltaLon / 2.0);
  var c = 2.0 * Math.atan2(Math.sqrt(a), Math.sqrt(1.0 - a));
  return 6371000.0 * c;
}

function distanceKm(coord1, coord2) {
  return distanceMeters(coord1, coord2) / 1000.0;
}

function distanceMiles(coord1, coord2) {
  return distanceMeters(coord1, coord2) / 1609.344;
}

function bearingTo(coord1, coord2) {
  var lat1 = toRadians(coord1.lat);
  var lat2 = toRadians(coord2.lat);
  var deltaLon = toRadians(coord2.lon - coord1.lon);
  var y = Math.sin(deltaLon) * Math.cos(lat2);
  var x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLon);
  var bearing = toDegrees(Math.atan2(y, x));
  return (bearing + 360.0) % 360.0;
}

function midpoint(coord1, coord2) {
  return {
          lat: (coord1.lat + coord2.lat) / 2.0,
          lon: (coord1.lon + coord2.lon) / 2.0
        };
}

function destination(start, bearing, distanceM) {
  var lat1 = toRadians(start.lat);
  var lon1 = toRadians(start.lon);
  var brng = toRadians(bearing);
  var angularDistance = distanceM / 6371000.0;
  var lat2 = Math.asin(Math.sin(lat1) * Math.cos(angularDistance) + Math.cos(lat1) * Math.sin(angularDistance) * Math.cos(brng));
  var lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(angularDistance) * Math.cos(lat1), Math.cos(angularDistance) - Math.sin(lat1) * Math.sin(lat2));
  var normalizedLon = (toDegrees(lon2) + 540.0) % 360.0 - 180.0;
  return {
          lat: toDegrees(lat2),
          lon: normalizedLon
        };
}

function makeBoundingBox(minLat, minLon, maxLat, maxLon) {
  if (!isValidLatitude(minLat) || !isValidLatitude(maxLat)) {
    return {
            TAG: "Error",
            _0: "InvalidLatitude"
          };
  } else if (!isValidLongitude(minLon) || !isValidLongitude(maxLon)) {
    return {
            TAG: "Error",
            _0: "InvalidLongitude"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              minLat: minLat,
              minLon: minLon,
              maxLat: maxLat,
              maxLon: maxLon
            }
          };
  }
}

function boundingBoxFromCoordinates(coord1, coord2) {
  return {
          minLat: Math.min(coord1.lat, coord2.lat),
          minLon: Math.min(coord1.lon, coord2.lon),
          maxLat: Math.max(coord1.lat, coord2.lat),
          maxLon: Math.max(coord1.lon, coord2.lon)
        };
}

function containsCoordinate(bbox, coord) {
  if (coord.lat >= bbox.minLat && coord.lat <= bbox.maxLat && coord.lon >= bbox.minLon) {
    return coord.lon <= bbox.maxLon;
  } else {
    return false;
  }
}

function boundingBoxCenter(bbox) {
  return {
          lat: (bbox.minLat + bbox.maxLat) / 2.0,
          lon: (bbox.minLon + bbox.maxLon) / 2.0
        };
}

function southwestCorner(bbox) {
  return {
          lat: bbox.minLat,
          lon: bbox.minLon
        };
}

function northeastCorner(bbox) {
  return {
          lat: bbox.maxLat,
          lon: bbox.maxLon
        };
}

function boundingBoxesOverlap(bbox1, bbox2) {
  return !(bbox1.maxLat < bbox2.minLat || bbox1.minLat > bbox2.maxLat || bbox1.maxLon < bbox2.minLon || bbox1.minLon > bbox2.maxLon);
}

function expandBoundingBox(bbox, marginDegrees) {
  return {
          minLat: Math.max(-90.0, bbox.minLat - marginDegrees),
          minLon: Math.max(-180.0, bbox.minLon - marginDegrees),
          maxLat: Math.min(90.0, bbox.maxLat + marginDegrees),
          maxLon: Math.min(180.0, bbox.maxLon + marginDegrees)
        };
}

function boundingBoxFromCoordinateList(coords) {
  if (coords.length === 0) {
    return ;
  }
  var first = coords[0];
  var minLat = {
    contents: first.lat
  };
  var maxLat = {
    contents: first.lat
  };
  var minLon = {
    contents: first.lon
  };
  var maxLon = {
    contents: first.lon
  };
  Belt_Array.forEach(coords, (function (coord) {
          if (coord.lat < minLat.contents) {
            minLat.contents = coord.lat;
          }
          if (coord.lat > maxLat.contents) {
            maxLat.contents = coord.lat;
          }
          if (coord.lon < minLon.contents) {
            minLon.contents = coord.lon;
          }
          if (coord.lon > maxLon.contents) {
            maxLon.contents = coord.lon;
            return ;
          }
          
        }));
  return {
          minLat: minLat.contents,
          minLon: minLon.contents,
          maxLat: maxLat.contents,
          maxLon: maxLon.contents
        };
}

function coordinateToString(coord) {
  var latDir = coord.lat >= 0.0 ? "N" : "S";
  var lonDir = coord.lon >= 0.0 ? "E" : "W";
  var latAbs = Math.abs(coord.lat);
  var lonAbs = Math.abs(coord.lon);
  return String(latAbs) + latDir + ", " + String(lonAbs) + lonDir;
}

function parseCoordinate(str) {
  var parts = str.split(",");
  if (parts.length !== 2) {
    return {
            TAG: "Error",
            _0: "InvalidCoordinate"
          };
  }
  var latStr = parts[0].trim();
  var lonStr = parts[1].trim();
  var match = Belt_Float.fromString(latStr);
  var match$1 = Belt_Float.fromString(lonStr);
  if (match !== undefined && match$1 !== undefined) {
    return makeCoordinate(match, match$1);
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCoordinate"
          };
  }
}

function isOnEquator(coord) {
  return Math.abs(coord.lat) < 0.0001;
}

function isOnPrimeMeridian(coord) {
  return Math.abs(coord.lon) < 0.0001;
}

function isNorthernHemisphere(coord) {
  return coord.lat > 0.0;
}

function isSouthernHemisphere(coord) {
  return coord.lat < 0.0;
}

function isEasternHemisphere(coord) {
  return coord.lon > 0.0;
}

function isWesternHemisphere(coord) {
  return coord.lon < 0.0;
}

function errorToString(error) {
  switch (error) {
    case "InvalidLatitude" :
        return "Invalid latitude (must be between -90 and 90)";
    case "InvalidLongitude" :
        return "Invalid longitude (must be between -180 and 180)";
    case "InvalidCoordinate" :
        return "Invalid coordinate format";
    
  }
}

var earthRadiusMeters = 6371000.0;

var earthRadiusKm = 6371.0;

export {
  earthRadiusMeters ,
  earthRadiusKm ,
  toRadians ,
  toDegrees ,
  isValidLatitude ,
  isValidLongitude ,
  makeCoordinate ,
  makeCoordinateClamped ,
  makeCoordinateUnsafe ,
  distanceMeters ,
  distanceKm ,
  distanceMiles ,
  bearingTo ,
  midpoint ,
  destination ,
  makeBoundingBox ,
  boundingBoxFromCoordinates ,
  containsCoordinate ,
  boundingBoxCenter ,
  southwestCorner ,
  northeastCorner ,
  boundingBoxesOverlap ,
  expandBoundingBox ,
  boundingBoxFromCoordinateList ,
  coordinateToString ,
  parseCoordinate ,
  isOnEquator ,
  isOnPrimeMeridian ,
  isNorthernHemisphere ,
  isSouthernHemisphere ,
  isEasternHemisphere ,
  isWesternHemisphere ,
  errorToString ,
}
/* No side effect */
