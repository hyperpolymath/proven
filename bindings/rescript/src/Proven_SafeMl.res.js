// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

function relu(x) {
  return Math.max(0.0, x);
}

function sigmoid(x) {
  return 1.0 / (1.0 + Math.exp(- x));
}

function tanh(x) {
  return Math.tanh(x);
}

function leakyRelu(x, alphaOpt, param) {
  var alpha = alphaOpt !== undefined ? alphaOpt : 0.01;
  if (x > 0.0) {
    return x;
  } else {
    return alpha * x;
  }
}

function applyActivation(activation, x) {
  switch (activation) {
    case "Relu" :
        return Math.max(0.0, x);
    case "Sigmoid" :
        return sigmoid(x);
    case "Tanh" :
        return Math.tanh(x);
    case "LeakyRelu" :
        return leakyRelu(x, undefined, undefined);
    case "Softmax" :
        return x;
    
  }
}

function reluDerivative(x) {
  if (x > 0.0) {
    return 1.0;
  } else {
    return 0.0;
  }
}

function sigmoidDerivative(x) {
  var s = sigmoid(x);
  return s * (1.0 - s);
}

function tanhDerivative(x) {
  var t = Math.tanh(x);
  return 1.0 - t * t;
}

function leakyReluDerivative(x, alphaOpt, param) {
  var alpha = alphaOpt !== undefined ? alphaOpt : 0.01;
  if (x > 0.0) {
    return 1.0;
  } else {
    return alpha;
  }
}

function activationDerivative(activation, x) {
  switch (activation) {
    case "Relu" :
        return reluDerivative(x);
    case "Sigmoid" :
        return sigmoidDerivative(x);
    case "Tanh" :
        return tanhDerivative(x);
    case "LeakyRelu" :
        return leakyReluDerivative(x, undefined, undefined);
    case "Softmax" :
        return 1.0;
    
  }
}

function softmax(input) {
  var len = input.length;
  if (len === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var maxVal = {
    contents: input[0]
  };
  Belt_Array.forEach(input, (function (v) {
          if (v > maxVal.contents) {
            maxVal.contents = v;
            return ;
          }
          
        }));
  var expValues = Belt_Array.map(input, (function (v) {
          return Math.exp(v - maxVal.contents);
        }));
  var sum = {
    contents: 0.0
  };
  Belt_Array.forEach(expValues, (function (v) {
          sum.contents = sum.contents + v;
        }));
  if (sum.contents === 0.0) {
    return {
            TAG: "Error",
            _0: "NumericalInstability"
          };
  }
  var result = Belt_Array.map(expValues, (function (v) {
          return v / sum.contents;
        }));
  return {
          TAG: "Ok",
          _0: result
        };
}

function normalize(data) {
  var len = data.length;
  if (len === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var minVal = {
    contents: data[0]
  };
  var maxVal = {
    contents: data[0]
  };
  Belt_Array.forEach(data, (function (v) {
          if (v < minVal.contents) {
            minVal.contents = v;
          }
          if (v > maxVal.contents) {
            maxVal.contents = v;
            return ;
          }
          
        }));
  var range = maxVal.contents - minVal.contents;
  if (range === 0.0) {
    return {
            TAG: "Ok",
            _0: Belt_Array.make(len, 0.5)
          };
  }
  var result = Belt_Array.map(data, (function (v) {
          return (v - minVal.contents) / range;
        }));
  return {
          TAG: "Ok",
          _0: result
        };
}

function standardize(data) {
  var len = data.length;
  if (len === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var sum = {
    contents: 0.0
  };
  Belt_Array.forEach(data, (function (v) {
          sum.contents = sum.contents + v;
        }));
  var mean = sum.contents / len;
  var variance = {
    contents: 0.0
  };
  Belt_Array.forEach(data, (function (v) {
          var diff = v - mean;
          variance.contents = variance.contents + diff * diff;
        }));
  variance.contents = variance.contents / len;
  var stdDev = Math.sqrt(variance.contents);
  if (stdDev === 0.0) {
    return {
            TAG: "Ok",
            _0: Belt_Array.make(len, 0.0)
          };
  }
  var result = Belt_Array.map(data, (function (v) {
          return (v - mean) / stdDev;
        }));
  return {
          TAG: "Ok",
          _0: result
        };
}

function clip(data, minVal, maxVal) {
  return Belt_Array.map(data, (function (v) {
                return Math.max(minVal, Math.min(maxVal, v));
              }));
}

function crossEntropyLoss(predictions, targets) {
  var predLen = predictions.length;
  var targetLen = targets.length;
  if (predLen !== targetLen) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  if (predLen === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var loss = 0.0;
  for(var i = 0; i < predLen; ++i){
    var p = predictions[i];
    var t = targets[i];
    var clipped = Math.max(1e-15, Math.min(1.0 - 1e-15, p));
    loss = loss - t * Math.log(clipped);
  }
  return {
          TAG: "Ok",
          _0: loss / predLen
        };
}

function mseLoss(predictions, targets) {
  var predLen = predictions.length;
  var targetLen = targets.length;
  if (predLen !== targetLen) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  if (predLen === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var sum = 0.0;
  for(var i = 0; i < predLen; ++i){
    var p = predictions[i];
    var t = targets[i];
    var diff = p - t;
    sum = sum + diff * diff;
  }
  return {
          TAG: "Ok",
          _0: sum / predLen
        };
}

function maeLoss(predictions, targets) {
  var predLen = predictions.length;
  var targetLen = targets.length;
  if (predLen !== targetLen) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  if (predLen === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var sum = 0.0;
  for(var i = 0; i < predLen; ++i){
    var p = predictions[i];
    var t = targets[i];
    sum = sum + Math.abs(p - t);
  }
  return {
          TAG: "Ok",
          _0: sum / predLen
        };
}

function binaryAccuracy(predictions, targets, thresholdOpt, param) {
  var threshold = thresholdOpt !== undefined ? thresholdOpt : 0.5;
  var predLen = predictions.length;
  var targetLen = targets.length;
  if (predLen !== targetLen) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  if (predLen === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var correct = 0;
  for(var i = 0; i < predLen; ++i){
    var p = predictions[i];
    var t = targets[i];
    var predictedClass = p >= threshold ? 1.0 : 0.0;
    if (predictedClass === t) {
      correct = correct + 1 | 0;
    }
    
  }
  return {
          TAG: "Ok",
          _0: correct / predLen
        };
}

function dot(a, b) {
  if (a.length !== b.length) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var sum = 0.0;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    var va = a[i];
    var vb = b[i];
    sum = sum + va * vb;
  }
  return {
          TAG: "Ok",
          _0: sum
        };
}

function l2Norm(data) {
  var sum = {
    contents: 0.0
  };
  Belt_Array.forEach(data, (function (v) {
          sum.contents = sum.contents + v * v;
        }));
  return Math.sqrt(sum.contents);
}

function l1Norm(data) {
  var sum = {
    contents: 0.0
  };
  Belt_Array.forEach(data, (function (v) {
          sum.contents = sum.contents + Math.abs(v);
        }));
  return sum.contents;
}

function cosineSimilarity(a, b) {
  if (a.length !== b.length) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var e = dot(a, b);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var normA = l2Norm(a);
  var normB = l2Norm(b);
  if (normA === 0.0 || normB === 0.0) {
    return {
            TAG: "Error",
            _0: "NumericalInstability"
          };
  } else {
    return {
            TAG: "Ok",
            _0: e._0 / (normA * normB)
          };
  }
}

function oneHot(index, numClasses) {
  if (index < 0 || index >= numClasses) {
    return {
            TAG: "Error",
            _0: "InvalidInput"
          };
  }
  var result = Belt_Array.make(numClasses, 0.0);
  result[index] = 1.0;
  return {
          TAG: "Ok",
          _0: result
        };
}

function argmax(data) {
  var len = data.length;
  if (len === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var maxIdx = 0;
  var maxVal = data[0];
  for(var i = 1; i < len; ++i){
    var v = data[i];
    if (v > maxVal) {
      maxVal = v;
      maxIdx = i;
    }
    
  }
  return {
          TAG: "Ok",
          _0: maxIdx
        };
}

function argmin(data) {
  var len = data.length;
  if (len === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var minIdx = 0;
  var minVal = data[0];
  for(var i = 1; i < len; ++i){
    var v = data[i];
    if (v < minVal) {
      minVal = v;
      minIdx = i;
    }
    
  }
  return {
          TAG: "Ok",
          _0: minIdx
        };
}

function mean(data) {
  var len = data.length;
  if (len === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var sum = {
    contents: 0.0
  };
  Belt_Array.forEach(data, (function (v) {
          sum.contents = sum.contents + v;
        }));
  return {
          TAG: "Ok",
          _0: sum.contents / len
        };
}

function variance(data) {
  var len = data.length;
  if (len === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var e = mean(data);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var meanVal = e._0;
  var sum = {
    contents: 0.0
  };
  Belt_Array.forEach(data, (function (v) {
          var diff = v - meanVal;
          sum.contents = sum.contents + diff * diff;
        }));
  return {
          TAG: "Ok",
          _0: sum.contents / len
        };
}

function stdDev(data) {
  var e = variance(data);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: Math.sqrt(e._0)
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function errorToString(err) {
  switch (err) {
    case "DimensionMismatch" :
        return "Dimension mismatch";
    case "InvalidInput" :
        return "Invalid input";
    case "EmptyInput" :
        return "Empty input";
    case "NumericalInstability" :
        return "Numerical instability";
    
  }
}

export {
  relu ,
  sigmoid ,
  tanh ,
  leakyRelu ,
  applyActivation ,
  reluDerivative ,
  sigmoidDerivative ,
  tanhDerivative ,
  leakyReluDerivative ,
  activationDerivative ,
  softmax ,
  normalize ,
  standardize ,
  clip ,
  crossEntropyLoss ,
  mseLoss ,
  maeLoss ,
  binaryAccuracy ,
  dot ,
  l2Norm ,
  l1Norm ,
  cosineSimilarity ,
  oneHot ,
  argmax ,
  argmin ,
  mean ,
  variance ,
  stdDev ,
  errorToString ,
}
/* No side effect */
