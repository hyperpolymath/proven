// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function makeMin(capacity) {
  return {
          data: [],
          length: 0,
          capacity: capacity,
          order: "Min"
        };
}

function makeMax(capacity) {
  return {
          data: [],
          length: 0,
          capacity: capacity,
          order: "Max"
        };
}

function length(heap) {
  return heap.length;
}

function isEmpty(heap) {
  return heap.length === 0;
}

function isFull(heap) {
  return heap.length >= heap.capacity;
}

function remaining(heap) {
  return heap.capacity - heap.length | 0;
}

function getCapacity(heap) {
  return heap.capacity;
}

function compare(order, a, b) {
  if (order === "Min") {
    return Caml_obj.lessthan(a, b);
  } else {
    return Caml_obj.greaterthan(a, b);
  }
}

function siftUp(heap, _index) {
  while(true) {
    var index = _index;
    if (index <= 0) {
      return ;
    }
    var parentIndex = (index - 1 | 0) / 2 | 0;
    var current = heap.data[index];
    var parent = heap.data[parentIndex];
    if (!compare(heap.order, current, parent)) {
      return ;
    }
    heap.data[index] = parent;
    heap.data[parentIndex] = current;
    _index = parentIndex;
    continue ;
  };
}

function siftDown(heap, _index) {
  while(true) {
    var index = _index;
    var leftIndex = (index << 1) + 1 | 0;
    var rightIndex = (index << 1) + 2 | 0;
    var targetIndex = index;
    if (leftIndex < heap.length) {
      var target = heap.data[targetIndex];
      var left = heap.data[leftIndex];
      if (compare(heap.order, left, target)) {
        targetIndex = leftIndex;
      }
      
    }
    if (rightIndex < heap.length) {
      var target$1 = heap.data[targetIndex];
      var right = heap.data[rightIndex];
      if (compare(heap.order, right, target$1)) {
        targetIndex = rightIndex;
      }
      
    }
    if (targetIndex === index) {
      return ;
    }
    var current = heap.data[index];
    var target$2 = heap.data[targetIndex];
    heap.data[index] = target$2;
    heap.data[targetIndex] = current;
    _index = targetIndex;
    continue ;
  };
}

function push(heap, value) {
  if (isFull(heap)) {
    return {
            TAG: "Error",
            _0: "HeapFull"
          };
  } else {
    if (heap.length >= heap.data.length) {
      heap.data = Belt_Array.concat(heap.data, [value]);
    } else {
      heap.data[heap.length] = value;
    }
    heap.length = heap.length + 1 | 0;
    siftUp(heap, heap.length - 1 | 0);
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function pushBounded(heap, value) {
  if (isFull(heap)) {
    if (heap.length <= 0) {
      return ;
    }
    var root = heap.data[0];
    var match = heap.order;
    var shouldReplace;
    shouldReplace = match === "Min" ? Caml_obj.greaterthan(value, root) : Caml_obj.lessthan(value, root);
    if (shouldReplace) {
      heap.data[0] = value;
      return siftDown(heap, 0);
    } else {
      return ;
    }
  }
  push(heap, value);
}

function pop(heap) {
  if (heap.length === 0) {
    return {
            TAG: "Error",
            _0: "HeapEmpty"
          };
  }
  var result = heap.data[0];
  heap.length = heap.length - 1 | 0;
  if (heap.length > 0) {
    var last = heap.data[heap.length];
    heap.data[0] = last;
    siftDown(heap, 0);
  }
  return {
          TAG: "Ok",
          _0: result
        };
}

function peek(heap) {
  if (heap.length === 0) {
    return {
            TAG: "Error",
            _0: "HeapEmpty"
          };
  } else {
    return {
            TAG: "Ok",
            _0: heap.data[0]
          };
  }
}

function peekAt(heap, index) {
  if (index < 0 || index >= heap.length) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  } else {
    return {
            TAG: "Ok",
            _0: heap.data[index]
          };
  }
}

function replace(heap, value) {
  if (heap.length === 0) {
    return {
            TAG: "Error",
            _0: "HeapEmpty"
          };
  }
  var result = heap.data[0];
  heap.data[0] = value;
  siftDown(heap, 0);
  return {
          TAG: "Ok",
          _0: result
        };
}

function clear(heap) {
  heap.length = 0;
  heap.data = [];
}

function items(heap) {
  return Belt_Array.slice(heap.data, 0, heap.length);
}

function toSortedArray(heap) {
  var result = [];
  var resultRef = result;
  while(heap.length !== 0) {
    var value = pop(heap);
    if (value.TAG === "Ok") {
      resultRef = Belt_Array.concat(resultRef, [value._0]);
    }
    
  };
  return resultRef;
}

function isValid(heap) {
  if (heap.length <= 1) {
    return true;
  }
  var valid = true;
  var parentCount = ((heap.length - 1 | 0) / 2 | 0) + 1 | 0;
  for(var i = 0; i < parentCount; ++i){
    if (valid) {
      var leftIndex = (i << 1) + 1 | 0;
      var rightIndex = (i << 1) + 2 | 0;
      var parent = heap.data[i];
      if (leftIndex < heap.length) {
        var left = heap.data[leftIndex];
        if (compare(heap.order, left, parent)) {
          valid = false;
        }
        
      }
      if (valid && rightIndex < heap.length) {
        var right = heap.data[rightIndex];
        if (compare(heap.order, right, parent)) {
          valid = false;
        }
        
      }
      
    }
    
  }
  return valid;
}

function make(k) {
  return {
          heap: makeMin(k),
          k: k
        };
}

function add(tracker, value) {
  pushBounded(tracker.heap, value);
}

function getTopK(tracker) {
  return items(tracker.heap);
}

function threshold(tracker) {
  var v = peek(tracker.heap);
  if (v.TAG === "Ok") {
    return Caml_option.some(v._0);
  }
  
}

function wouldInclude(tracker, value) {
  if (!isFull(tracker.heap)) {
    return true;
  }
  var minValue = peek(tracker.heap);
  if (minValue.TAG === "Ok") {
    return Caml_obj.greaterthan(value, minValue._0);
  } else {
    return true;
  }
}

function count(tracker) {
  return tracker.heap.length;
}

function clear$1(tracker) {
  clear(tracker.heap);
}

var TopK = {
  make: make,
  add: add,
  getTopK: getTopK,
  threshold: threshold,
  wouldInclude: wouldInclude,
  count: count,
  clear: clear$1
};

function make$1(capacity) {
  return makeMin(capacity);
}

function enqueue(queue, priority, value) {
  return push(queue, {
              priority: priority,
              value: value
            });
}

function dequeue(queue) {
  var item = pop(queue);
  if (item.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: item._0.value
          };
  } else {
    return {
            TAG: "Error",
            _0: item._0
          };
  }
}

function peekValue(queue) {
  var item = peek(queue);
  if (item.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: item._0.value
          };
  } else {
    return {
            TAG: "Error",
            _0: item._0
          };
  }
}

function peekPriority(queue) {
  var item = peek(queue);
  if (item.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: item._0.priority
          };
  } else {
    return {
            TAG: "Error",
            _0: item._0
          };
  }
}

function isEmpty$1(queue) {
  return queue.length === 0;
}

function length$1(queue) {
  return queue.length;
}

var PriorityQueue = {
  make: make$1,
  enqueue: enqueue,
  dequeue: dequeue,
  peekValue: peekValue,
  peekPriority: peekPriority,
  isEmpty: isEmpty$1,
  length: length$1
};

export {
  makeMin ,
  makeMax ,
  length ,
  isEmpty ,
  isFull ,
  remaining ,
  getCapacity ,
  compare ,
  siftUp ,
  siftDown ,
  push ,
  pushBounded ,
  pop ,
  peek ,
  peekAt ,
  replace ,
  clear ,
  items ,
  toSortedArray ,
  isValid ,
  TopK ,
  PriorityQueue ,
}
/* No side effect */
