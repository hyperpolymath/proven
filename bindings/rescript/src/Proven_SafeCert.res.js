// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function isValidAtTime(validity, currentTime) {
  if (currentTime >= validity.notBefore) {
    return currentTime <= validity.notAfter;
  } else {
    return false;
  }
}

function isExpiredAtTime(validity, currentTime) {
  return currentTime > validity.notAfter;
}

function isNotYetValidAtTime(validity, currentTime) {
  return currentTime < validity.notBefore;
}

function getRemainingSeconds(validity, currentTime) {
  return validity.notAfter - currentTime;
}

function isPemEncoded(data) {
  return data.startsWith("-----BEGIN ");
}

function isDerEncoded(data) {
  if (data.length >= 2) {
    return data.charCodeAt(0) === 48.0;
  } else {
    return false;
  }
}

function validatePemFormat(pem) {
  var beginMarker = "-----BEGIN CERTIFICATE-----";
  var beginPos = pem.indexOf(beginMarker);
  if (beginPos === -1) {
    return {
            TAG: "Error",
            _0: "InvalidPem"
          };
  }
  var endPos = pem.indexOf("-----END CERTIFICATE-----");
  if (endPos === -1) {
    return {
            TAG: "Error",
            _0: "InvalidPem"
          };
  }
  if (beginPos >= endPos) {
    return {
            TAG: "Error",
            _0: "InvalidPem"
          };
  }
  var contentStart = beginPos + beginMarker.length | 0;
  if (contentStart >= endPos) {
    return {
            TAG: "Error",
            _0: "InvalidPem"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function extractPemContent(pem) {
  var beginMarker = "-----BEGIN CERTIFICATE-----";
  var beginPos = pem.indexOf(beginMarker);
  if (beginPos === -1) {
    return {
            TAG: "Error",
            _0: "InvalidPem"
          };
  }
  var endPos = pem.indexOf("-----END CERTIFICATE-----");
  if (endPos === -1) {
    return {
            TAG: "Error",
            _0: "InvalidPem"
          };
  }
  var contentStart = beginPos + beginMarker.length | 0;
  if (contentStart >= endPos) {
    return {
            TAG: "Error",
            _0: "InvalidPem"
          };
  }
  var content = pem.slice(contentStart, endPos);
  var cleaned = content.replace(/\\n/g, "").replace(/\\r/g, "").replace(/ /g, "").replace(/\\t/g, "");
  return {
          TAG: "Ok",
          _0: cleaned
        };
}

function validateValidityPeriod(validity, currentTime) {
  if (currentTime < validity.notBefore) {
    return {
            TAG: "Error",
            _0: "NotYetValid"
          };
  } else if (currentTime > validity.notAfter) {
    return {
            TAG: "Error",
            _0: "ExpiredCertificate"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function validateChainDepth(depth, maxDepth) {
  if (depth > maxDepth) {
    return {
            TAG: "Error",
            _0: "ChainValidationFailed"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function validateBasicConstraints(constraints, isCaExpected) {
  if (isCaExpected) {
    if (constraints !== undefined) {
      if (constraints.isCa) {
        return {
                TAG: "Ok",
                _0: undefined
              };
      } else {
        return {
                TAG: "Error",
                _0: "ChainValidationFailed"
              };
      }
    } else {
      return {
              TAG: "Error",
              _0: "MissingRequiredField"
            };
    }
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function optionalStrEquals(a, b) {
  if (a !== undefined) {
    if (b !== undefined) {
      return a === b;
    } else {
      return false;
    }
  } else {
    return b === undefined;
  }
}

function dnEquals(a, b) {
  if (optionalStrEquals(a.commonName, b.commonName) && optionalStrEquals(a.organization, b.organization) && optionalStrEquals(a.organizationalUnit, b.organizationalUnit) && optionalStrEquals(a.country, b.country) && optionalStrEquals(a.state, b.state)) {
    return optionalStrEquals(a.locality, b.locality);
  } else {
    return false;
  }
}

function isSelfSigned(issuer, subject) {
  return dnEquals(issuer, subject);
}

function validateNotSelfSigned(issuer, subject) {
  if (dnEquals(issuer, subject)) {
    return {
            TAG: "Error",
            _0: "SelfSignedNotAllowed"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function countCertificatesInBundle(pemBundle) {
  var marker = "-----BEGIN CERTIFICATE-----";
  var _pos = 0;
  var _count = 0;
  while(true) {
    var count = _count;
    var pos = _pos;
    var idx = pemBundle.indexOf(marker, pos);
    if (idx === -1) {
      return count;
    }
    _count = count + 1 | 0;
    _pos = idx + marker.length | 0;
    continue ;
  };
}

function validateVersion(version) {
  if (version < 1 || version > 3) {
    return {
            TAG: "Error",
            _0: "UnsupportedVersion"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function dnFromCommonName(cn) {
  return {
          commonName: cn,
          organization: undefined,
          organizationalUnit: undefined,
          country: undefined,
          state: undefined,
          locality: undefined
        };
}

function formatDn(dn) {
  var parts = [];
  var cn = dn.commonName;
  var parts$1 = cn !== undefined ? parts.concat(["CN=" + cn]) : parts;
  var o = dn.organization;
  var parts$2 = o !== undefined ? parts$1.concat(["O=" + o]) : parts$1;
  var ou = dn.organizationalUnit;
  var parts$3 = ou !== undefined ? parts$2.concat(["OU=" + ou]) : parts$2;
  var c = dn.country;
  var parts$4 = c !== undefined ? parts$3.concat(["C=" + c]) : parts$3;
  var st = dn.state;
  var parts$5 = st !== undefined ? parts$4.concat(["ST=" + st]) : parts$4;
  var l = dn.locality;
  var parts$6 = l !== undefined ? parts$5.concat(["L=" + l]) : parts$5;
  return parts$6.join(", ");
}

function isValidCa(info) {
  var bc = info.basicConstraints;
  if (bc !== undefined) {
    return bc.isCa;
  } else {
    return false;
  }
}

function getPathLenConstraint(info) {
  var bc = info.basicConstraints;
  if (bc !== undefined) {
    return bc.pathLenConstraint;
  }
  
}

function validateChainStructure(chain, currentTime) {
  if (chain.length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidFormat"
          };
  }
  var validityResults = chain.map(function (cert) {
        return validateValidityPeriod(cert.validity, currentTime);
      });
  var hasValidityError = validityResults.some(function (r) {
        if (r.TAG === "Ok") {
          return false;
        } else {
          return true;
        }
      });
  if (hasValidityError) {
    return Belt_Option.getWithDefault(Caml_option.undefined_to_opt(validityResults.find(function (r) {
                        if (r.TAG === "Ok") {
                          return false;
                        } else {
                          return true;
                        }
                      })), {
                TAG: "Ok",
                _0: undefined
              });
  } else {
    return validateChainDepth(chain.length, 10);
  }
}

var expiryWarningThreshold = 30.0 * 24.0 * 60.0 * 60.0;

function isExpiringSoon(validity, currentTime) {
  var remaining = validity.notAfter - currentTime;
  if (remaining > 0.0) {
    return remaining < expiryWarningThreshold;
  } else {
    return false;
  }
}

function getValidityStatus(validity, currentTime) {
  if (currentTime < validity.notBefore) {
    return "not_yet_valid";
  } else if (currentTime > validity.notAfter) {
    return "expired";
  } else if (isExpiringSoon(validity, currentTime)) {
    return "expiring_soon";
  } else {
    return "valid";
  }
}

var emptyDn = {
  commonName: undefined,
  organization: undefined,
  organizationalUnit: undefined,
  country: undefined,
  state: undefined,
  locality: undefined
};

export {
  isValidAtTime ,
  isExpiredAtTime ,
  isNotYetValidAtTime ,
  getRemainingSeconds ,
  isPemEncoded ,
  isDerEncoded ,
  validatePemFormat ,
  extractPemContent ,
  validateValidityPeriod ,
  validateChainDepth ,
  validateBasicConstraints ,
  optionalStrEquals ,
  dnEquals ,
  isSelfSigned ,
  validateNotSelfSigned ,
  countCertificatesInBundle ,
  validateVersion ,
  emptyDn ,
  dnFromCommonName ,
  formatDn ,
  isValidCa ,
  getPathLenConstraint ,
  validateChainStructure ,
  expiryWarningThreshold ,
  isExpiringSoon ,
  getValidityStatus ,
}
/* No side effect */
