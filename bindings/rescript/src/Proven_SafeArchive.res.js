// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Proven_Bitwise from "./Proven_Bitwise.res.js";

function formatExtension(format) {
  switch (format) {
    case "Zip" :
        return ".zip";
    case "Tar" :
        return ".tar";
    case "Gzip" :
        return ".gz";
    case "Bzip2" :
        return ".bz2";
    case "Xz" :
        return ".xz";
    case "SevenZip" :
        return ".7z";
    case "Rar" :
        return ".rar";
    case "Zstd" :
        return ".zst";
    
  }
}

function formatMimeType(format) {
  switch (format) {
    case "Zip" :
        return "application/zip";
    case "Tar" :
        return "application/x-tar";
    case "Gzip" :
        return "application/gzip";
    case "Bzip2" :
        return "application/x-bzip2";
    case "Xz" :
        return "application/x-xz";
    case "SevenZip" :
        return "application/x-7z-compressed";
    case "Rar" :
        return "application/vnd.rar";
    case "Zstd" :
        return "application/zstd";
    
  }
}

function formatDisplayName(format) {
  switch (format) {
    case "Zip" :
        return "ZIP";
    case "Tar" :
        return "TAR";
    case "Gzip" :
        return "GZIP";
    case "Bzip2" :
        return "BZIP2";
    case "Xz" :
        return "XZ";
    case "SevenZip" :
        return "7-Zip";
    case "Rar" :
        return "RAR";
    case "Zstd" :
        return "Zstandard";
    
  }
}

function minBytesForFormat(format) {
  switch (format) {
    case "Tar" :
        return 262;
    case "Gzip" :
        return 2;
    case "Bzip2" :
        return 3;
    case "Xz" :
    case "SevenZip" :
        return 6;
    case "Rar" :
        return 8;
    case "Zip" :
    case "Zstd" :
        return 4;
    
  }
}

function formatToString(format) {
  switch (format) {
    case "Zip" :
        return "zip";
    case "Tar" :
        return "tar";
    case "Gzip" :
        return "gzip";
    case "Bzip2" :
        return "bzip2";
    case "Xz" :
        return "xz";
    case "SevenZip" :
        return "7z";
    case "Rar" :
        return "rar";
    case "Zstd" :
        return "zstd";
    
  }
}

function matchesMagic(data, magic, offset) {
  var dataLen = data.length;
  var magicLen = magic.length;
  if (dataLen < (offset + magicLen | 0)) {
    return false;
  }
  var matches = true;
  for(var i = 0; i < magicLen; ++i){
    if (matches) {
      var dataByte = data[offset + i | 0];
      var magicByte = magic[i];
      if (dataByte !== magicByte) {
        matches = false;
      }
      
    }
    
  }
  return matches;
}

var zipMagic = [
  80,
  75,
  3,
  4
];

var zipEmptyMagic = [
  80,
  75,
  5,
  6
];

var gzipMagic = [
  31,
  139
];

var bzip2Magic = [
  66,
  90,
  104
];

var xzMagic = [
  253,
  55,
  122,
  88,
  90,
  0
];

var sevenZipMagic = [
  55,
  122,
  188,
  175,
  39,
  28
];

var rar5Magic = [
  82,
  97,
  114,
  33,
  26,
  7,
  1,
  0
];

var rar4Magic = [
  82,
  97,
  114,
  33,
  26,
  7,
  0
];

var zstdMagic = [
  40,
  181,
  47,
  253
];

var ustarMagic = [
  117,
  115,
  116,
  97,
  114
];

function isTarArchive(data) {
  return matchesMagic(data, ustarMagic, 257);
}

function detectFormat(data) {
  if (matchesMagic(data, zipMagic, 0) || matchesMagic(data, zipEmptyMagic, 0)) {
    return "Zip";
  } else if (matchesMagic(data, gzipMagic, 0)) {
    return "Gzip";
  } else if (matchesMagic(data, bzip2Magic, 0)) {
    return "Bzip2";
  } else if (matchesMagic(data, xzMagic, 0)) {
    return "Xz";
  } else if (matchesMagic(data, sevenZipMagic, 0)) {
    return "SevenZip";
  } else if (matchesMagic(data, rar5Magic, 0) || matchesMagic(data, rar4Magic, 0)) {
    return "Rar";
  } else if (matchesMagic(data, zstdMagic, 0)) {
    return "Zstd";
  } else if (isTarArchive(data)) {
    return "Tar";
  } else {
    return ;
  }
}

function isValidArchive(data) {
  return Belt_Option.isSome(detectFormat(data));
}

function detectFormatWithConfidence(data) {
  var format = detectFormat(data);
  if (format !== undefined) {
    return {
            format: format,
            confidence: "High",
            reason: "Magic bytes match"
          };
  } else if (data.length < 512) {
    return {
            format: undefined,
            confidence: "Low",
            reason: "Insufficient data for reliable detection"
          };
  } else {
    return {
            format: undefined,
            confidence: "None",
            reason: "No known archive format detected"
          };
  }
}

function readUint16Le(data, offset) {
  if (data.length < (offset + 2 | 0)) {
    return ;
  }
  var low = data[offset];
  var high = data[offset + 1 | 0];
  return low + Proven_Bitwise.lsl(high, 8) | 0;
}

function readUint32Le(data, offset) {
  if (data.length < (offset + 4 | 0)) {
    return ;
  }
  var b0 = data[offset];
  var b1 = data[offset + 1 | 0];
  var b2 = data[offset + 2 | 0];
  var b3 = data[offset + 3 | 0];
  return ((b0 + Proven_Bitwise.lsl(b1, 8) | 0) + Proven_Bitwise.lsl(b2, 16) | 0) + Proven_Bitwise.lsl(b3, 24) | 0;
}

function validateZipHeader(data) {
  if (data.length < 30) {
    return {
            TAG: "Error",
            _0: "BufferTooSmall"
          };
  }
  if (!matchesMagic(data, zipMagic, 0)) {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
  var match = readUint16Le(data, 4);
  var match$1 = readUint16Le(data, 6);
  var match$2 = readUint16Le(data, 8);
  var match$3 = readUint16Le(data, 26);
  var match$4 = readUint16Le(data, 28);
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
  if (match$1 === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
  if (match$2 === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
  if (match$3 === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
  if (match$4 === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
  var headerSize = (30 + match$3 | 0) + match$4 | 0;
  if (data.length < headerSize) {
    return {
            TAG: "Error",
            _0: "BufferTooSmall"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              versionNeeded: match,
              flags: match$1,
              compressionMethod: match$2,
              filenameLen: match$3,
              extraLen: match$4,
              headerSize: headerSize
            }
          };
  }
}

function isZipEncrypted(info) {
  return Proven_Bitwise.land(info.flags, 1) !== 0;
}

function zipCompressionName(method) {
  if (method >= 15) {
    switch (method) {
      case 93 :
          return "zstd";
      case 95 :
          return "xz";
      default:
        return "unknown";
    }
  } else {
    if (method < 0) {
      return "unknown";
    }
    switch (method) {
      case 0 :
          return "stored";
      case 1 :
          return "shrunk";
      case 6 :
          return "imploded";
      case 8 :
          return "deflated";
      case 9 :
          return "deflate64";
      case 12 :
          return "bzip2";
      case 2 :
      case 3 :
      case 4 :
      case 5 :
      case 7 :
      case 10 :
      case 11 :
      case 13 :
          return "unknown";
      case 14 :
          return "lzma";
      
    }
  }
}

function validateGzipHeader(data) {
  if (data.length < 10) {
    return {
            TAG: "Error",
            _0: "BufferTooSmall"
          };
  }
  var b0 = data[0];
  var b1 = data[1];
  if (b0 !== 31 || b1 !== 139) {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
  var compressionMethod = data[2];
  var flags = data[3];
  var extraFlags = data[8];
  var os = data[9];
  if (compressionMethod !== 8) {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
  var mtime = readUint32Le(data, 4);
  if (mtime === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
  var headerSize = 10;
  if (Proven_Bitwise.land(flags, 4) !== 0) {
    var xlen = readUint16Le(data, headerSize);
    if (xlen !== undefined) {
      headerSize = (headerSize + 2 | 0) + xlen | 0;
    }
    
  }
  if (Proven_Bitwise.land(flags, 8) !== 0) {
    var i = headerSize;
    while(i < data.length && data[i] !== 0) {
      i = i + 1 | 0;
    };
    if (i < data.length) {
      headerSize = i + 1 | 0;
    }
    
  }
  if (Proven_Bitwise.land(flags, 16) !== 0) {
    var i$1 = headerSize;
    while(i$1 < data.length && data[i$1] !== 0) {
      i$1 = i$1 + 1 | 0;
    };
    if (i$1 < data.length) {
      headerSize = i$1 + 1 | 0;
    }
    
  }
  if (Proven_Bitwise.land(flags, 2) !== 0) {
    headerSize = headerSize + 2 | 0;
  }
  if (data.length < headerSize) {
    return {
            TAG: "Error",
            _0: "BufferTooSmall"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              compressionMethod: compressionMethod,
              flags: flags,
              mtime: mtime,
              extraFlags: extraFlags,
              os: os,
              headerSize: headerSize
            }
          };
  }
}

function gzipHasFilename(info) {
  return Proven_Bitwise.land(info.flags, 8) !== 0;
}

function gzipHasComment(info) {
  return Proven_Bitwise.land(info.flags, 16) !== 0;
}

function gzipOsName(os) {
  switch (os) {
    case 0 :
        return "FAT filesystem";
    case 1 :
        return "Amiga";
    case 2 :
        return "VMS";
    case 3 :
        return "Unix";
    case 4 :
        return "VM/CMS";
    case 5 :
        return "Atari TOS";
    case 6 :
        return "HPFS filesystem";
    case 7 :
        return "Macintosh";
    case 8 :
        return "Z-System";
    case 9 :
        return "CP/M";
    case 10 :
        return "TOPS-20";
    case 11 :
        return "NTFS filesystem";
    case 12 :
        return "QDOS";
    case 13 :
        return "Acorn RISCOS";
    default:
      return "unknown";
  }
}

function tarTypeName(typeflag) {
  if (typeflag >= 56) {
    if (typeflag !== 103) {
      if (typeflag !== 120) {
        return "unknown";
      } else {
        return "extended header";
      }
    } else {
      return "global extended header";
    }
  }
  if (typeflag === 0) {
    return "regular file";
  }
  if (typeflag < 48) {
    return "unknown";
  }
  switch (typeflag) {
    case 48 :
        return "regular file";
    case 49 :
        return "hard link";
    case 50 :
        return "symbolic link";
    case 51 :
        return "character device";
    case 52 :
        return "block device";
    case 53 :
        return "directory";
    case 54 :
        return "FIFO";
    case 55 :
        return "contiguous file";
    
  }
}

function tarIsRegularFile(info) {
  if (info.typeflag === 0) {
    return true;
  } else {
    return info.typeflag === 48;
  }
}

function tarIsDirectory(info) {
  return info.typeflag === 53;
}

function archiveErrorToString(error) {
  switch (error) {
    case "UnknownFormat" :
        return "Unknown archive format";
    case "BufferTooSmall" :
        return "Buffer is too small";
    case "InvalidHeader" :
        return "Invalid archive header";
    case "CorruptedArchive" :
        return "Archive is corrupted";
    
  }
}

function confidenceToString(conf) {
  switch (conf) {
    case "High" :
        return "high";
    case "Medium" :
        return "medium";
    case "Low" :
        return "low";
    case "None" :
        return "none";
    
  }
}

var tarBlockSize = 512;

var minDetectionBytes = 512;

export {
  tarBlockSize ,
  minDetectionBytes ,
  formatExtension ,
  formatMimeType ,
  formatDisplayName ,
  minBytesForFormat ,
  formatToString ,
  matchesMagic ,
  zipMagic ,
  zipEmptyMagic ,
  gzipMagic ,
  bzip2Magic ,
  xzMagic ,
  sevenZipMagic ,
  rar5Magic ,
  rar4Magic ,
  zstdMagic ,
  ustarMagic ,
  isTarArchive ,
  detectFormat ,
  isValidArchive ,
  detectFormatWithConfidence ,
  readUint16Le ,
  readUint32Le ,
  validateZipHeader ,
  isZipEncrypted ,
  zipCompressionName ,
  validateGzipHeader ,
  gzipHasFilename ,
  gzipHasComment ,
  gzipOsName ,
  tarTypeName ,
  tarIsRegularFile ,
  tarIsDirectory ,
  archiveErrorToString ,
  confidenceToString ,
}
/* No side effect */
