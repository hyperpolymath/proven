// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\$&");
}

var defaultParseOptions = {
  delimiter: ",",
  quote: "\"",
  trimWhitespace: false,
  maxFields: 0,
  maxFieldLength: 0,
  skipEmptyRows: false
};

var defaultWriteOptions = {
  delimiter: ",",
  quote: "\"",
  lineEnding: "Lf",
  alwaysQuote: false
};

var getField = Belt_Array.get;

function fieldCount(row) {
  return row.length;
}

function needsQuoting(field, optionsOpt, param) {
  var options = optionsOpt !== undefined ? optionsOpt : defaultWriteOptions;
  if (options.alwaysQuote || field.includes(options.delimiter) || field.includes(options.quote) || field.includes("\n")) {
    return true;
  } else {
    return field.includes("\r");
  }
}

function escapeField(field, optionsOpt, param) {
  var options = optionsOpt !== undefined ? optionsOpt : defaultWriteOptions;
  if (!needsQuoting(field, options, undefined)) {
    return field;
  }
  var escaped = field.replace(new RegExp(escapeRegex(options.quote), "g"), options.quote + options.quote);
  return options.quote + escaped + options.quote;
}

function lineEndingToString(ending) {
  switch (ending) {
    case "Lf" :
        return "\n";
    case "Crlf" :
        return "\r\n";
    case "Cr" :
        return "\r";
    
  }
}

function writeRow(fields, optionsOpt, param) {
  var options = optionsOpt !== undefined ? optionsOpt : defaultWriteOptions;
  var escapedFields = Belt_Array.map(fields, (function (field) {
          if (!needsQuoting(field, options, undefined)) {
            return field;
          }
          var escaped = field.replace(new RegExp(escapeRegex(options.quote), "g"), options.quote + options.quote);
          return options.quote + escaped + options.quote;
        }));
  return escapedFields.join(options.delimiter) + lineEndingToString(options.lineEnding);
}

function parseRow(line, optionsOpt, param) {
  var options = optionsOpt !== undefined ? optionsOpt : defaultParseOptions;
  if (line.length === 0) {
    return {
            TAG: "Ok",
            _0: []
          };
  }
  var fields = [];
  var currentField = "";
  var inQuotes = false;
  var position = 0;
  var error;
  var length = line.length;
  while(position < length && error === undefined) {
    var currentChar = line.charAt(position);
    if (inQuotes) {
      if (currentChar === options.quote) {
        if ((position + 1 | 0) < length && line.charAt(position + 1 | 0) === options.quote) {
          currentField = currentField + options.quote;
          position = position + 2 | 0;
        } else {
          inQuotes = false;
          position = position + 1 | 0;
        }
      } else {
        currentField = currentField + currentChar;
        position = position + 1 | 0;
      }
    } else if (currentChar === options.quote) {
      inQuotes = true;
      position = position + 1 | 0;
    } else if (currentChar === options.delimiter) {
      if (options.maxFields > 0 && fields.length >= options.maxFields) {
        error = "MaxFieldsExceeded";
      } else {
        var fieldValue = options.trimWhitespace ? currentField.trim() : currentField;
        fields = Belt_Array.concat(fields, [fieldValue]);
        currentField = "";
        position = position + 1 | 0;
      }
    } else if (currentChar === "\n" || currentChar === "\r") {
      position = length;
    } else {
      currentField = currentField + currentChar;
      position = position + 1 | 0;
    }
    if (options.maxFieldLength > 0 && currentField.length > options.maxFieldLength) {
      error = "FieldTooLong";
    }
    
  };
  var err = error;
  if (err !== undefined) {
    return {
            TAG: "Error",
            _0: err
          };
  }
  var fieldValue$1 = options.trimWhitespace ? currentField.trim() : currentField;
  fields = Belt_Array.concat(fields, [fieldValue$1]);
  if (inQuotes) {
    return {
            TAG: "Error",
            _0: "UnterminatedQuote"
          };
  } else {
    return {
            TAG: "Ok",
            _0: fields
          };
  }
}

function parseAll(input, optionsOpt, param) {
  var options = optionsOpt !== undefined ? optionsOpt : defaultParseOptions;
  if (input.length === 0) {
    return {
            TAG: "Error",
            _0: "EmptyInput"
          };
  }
  var normalizedInput = input.replace(/\r\n/g, "\n");
  var normalizedInput$1 = normalizedInput.replace(/\r/g, "\n");
  var lines = normalizedInput$1.split("\n");
  var rows = {
    contents: []
  };
  var error = {
    contents: undefined
  };
  var expectedColumnCount = {
    contents: undefined
  };
  Belt_Array.forEach(lines, (function (line) {
          if (error.contents !== undefined) {
            return ;
          }
          if (line.trim().length === 0 && options.skipEmptyRows) {
            return ;
          }
          if (line.length <= 0) {
            return ;
          }
          var row = parseRow(line, options, undefined);
          if (row.TAG !== "Ok") {
            error.contents = row._0;
            return ;
          }
          var row$1 = row._0;
          var expected = expectedColumnCount.contents;
          if (expected !== undefined) {
            if (row$1.length !== expected) {
              error.contents = "InconsistentColumnCount";
            }
            
          } else {
            expectedColumnCount.contents = row$1.length;
          }
          if (error.contents === undefined) {
            rows.contents = Belt_Array.concat(rows.contents, [row$1]);
            return ;
          }
          
        }));
  var err = error.contents;
  if (err !== undefined) {
    return {
            TAG: "Error",
            _0: err
          };
  } else {
    return {
            TAG: "Ok",
            _0: rows.contents
          };
  }
}

function countColumns(input, delimiterOpt, param) {
  var delimiter = delimiterOpt !== undefined ? delimiterOpt : ",";
  if (input.length === 0) {
    return 0;
  }
  var count = 1;
  var inQuotes = false;
  var index = 0;
  var length = input.length;
  while(index < length) {
    var currentChar = input.charAt(index);
    if (currentChar === "\"" && !inQuotes) {
      inQuotes = true;
    } else if (currentChar === "\"" && inQuotes) {
      if ((index + 1 | 0) < length && input.charAt(index + 1 | 0) === "\"") {
        index = index + 1 | 0;
      } else {
        inQuotes = false;
      }
    } else if (!inQuotes) {
      if (currentChar === delimiter) {
        count = count + 1 | 0;
      } else if (currentChar === "\n" || currentChar === "\r") {
        index = length;
      }
      
    }
    index = index + 1 | 0;
  };
  return count;
}

function isValid(input, optionsOpt, param) {
  var options = optionsOpt !== undefined ? optionsOpt : defaultParseOptions;
  var match = parseAll(input, options, undefined);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function createWriter(optionsOpt, param) {
  var options = optionsOpt !== undefined ? optionsOpt : defaultWriteOptions;
  return {
          buffer: "",
          options: options,
          rowCount: 0
        };
}

function writerWriteRow(writer, fields) {
  writer.buffer = writer.buffer + writeRow(fields, writer.options, undefined);
  writer.rowCount = writer.rowCount + 1 | 0;
}

function writerGetContent(writer) {
  return writer.buffer;
}

function writerGetRowCount(writer) {
  return writer.rowCount;
}

function writerClear(writer) {
  writer.buffer = "";
  writer.rowCount = 0;
}

function stringify(data, optionsOpt, param) {
  var options = optionsOpt !== undefined ? optionsOpt : defaultWriteOptions;
  var writer = createWriter(options, undefined);
  Belt_Array.forEach(data, (function (row) {
          writerWriteRow(writer, row);
        }));
  return writer.buffer;
}

function getHeaders(rows) {
  return Belt_Array.get(rows, 0);
}

function getDataRows(rows) {
  return Belt_Array.sliceToEnd(rows, 1);
}

function toObjects(rows) {
  var headers = Belt_Array.get(rows, 0);
  if (headers === undefined) {
    return ;
  }
  var dataRows = Belt_Array.sliceToEnd(rows, 1);
  return Belt_Array.map(dataRows, (function (row) {
                var dict = {};
                Belt_Array.forEachWithIndex(headers, (function (index, header) {
                        var value = Belt_Array.get(row, index);
                        if (value !== undefined) {
                          dict[header] = value;
                          return ;
                        }
                        
                      }));
                return dict;
              }));
}

function fromObjects(objects, headers) {
  var dataRows = Belt_Array.map(objects, (function (obj) {
          return Belt_Array.map(headers, (function (header) {
                        var value = Js_dict.get(obj, header);
                        if (value !== undefined) {
                          return value;
                        } else {
                          return "";
                        }
                      }));
        }));
  return Belt_Array.concat([headers], dataRows);
}

export {
  escapeRegex ,
  defaultParseOptions ,
  defaultWriteOptions ,
  getField ,
  fieldCount ,
  needsQuoting ,
  escapeField ,
  lineEndingToString ,
  writeRow ,
  parseRow ,
  parseAll ,
  countColumns ,
  isValid ,
  createWriter ,
  writerWriteRow ,
  writerGetContent ,
  writerGetRowCount ,
  writerClear ,
  stringify ,
  getHeaders ,
  getDataRows ,
  toObjects ,
  fromObjects ,
}
/* No side effect */
