// Generated by ReScript, PLEASE EDIT WITH CARE

import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function floatIsNaN(value) {
  return value !== value;
}

function isInf(value) {
  if (value === PervasivesU.infinity) {
    return true;
  } else {
    return value === PervasivesU.neg_infinity;
  }
}

function $$isFinite(value) {
  if (value === value) {
    return !isInf(value);
  } else {
    return false;
  }
}

function validateFinite(z) {
  var value = z.real;
  var tmp = true;
  if (value === value) {
    var value$1 = z.imag;
    tmp = value$1 !== value$1;
  }
  if (tmp) {
    return {
            TAG: "Error",
            _0: "NaN"
          };
  } else if (isInf(z.real) || isInf(z.imag)) {
    return {
            TAG: "Error",
            _0: "Infinity"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function make(real, imag) {
  if (real !== real || imag !== imag) {
    return {
            TAG: "Error",
            _0: "NaN"
          };
  } else if (isInf(real) || isInf(imag)) {
    return {
            TAG: "Error",
            _0: "Infinity"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              real: real,
              imag: imag
            }
          };
  }
}

function fromReal(real) {
  return make(real, 0.0);
}

function fromImag(imag) {
  return make(0.0, imag);
}

function fromPolar(r, theta) {
  if (r !== r || theta !== theta) {
    return {
            TAG: "Error",
            _0: "NaN"
          };
  } else if (r < 0.0) {
    return {
            TAG: "Error",
            _0: "InvalidInput"
          };
  } else {
    return make(r * Math.cos(theta), r * Math.sin(theta));
  }
}

var one = {
  real: 1.0,
  imag: 0.0
};

function isValid(z) {
  if ($$isFinite(z.real)) {
    return $$isFinite(z.imag);
  } else {
    return false;
  }
}

function isZero(z) {
  if (z.real === 0.0) {
    return z.imag === 0.0;
  } else {
    return false;
  }
}

function isPurelyReal(z) {
  return z.imag === 0.0;
}

function isPurelyImaginary(z) {
  if (z.real === 0.0) {
    return z.imag !== 0.0;
  } else {
    return false;
  }
}

function conjugate(z) {
  return {
          real: z.real,
          imag: - z.imag
        };
}

function negate(z) {
  return {
          real: - z.real,
          imag: - z.imag
        };
}

function add(a, b) {
  var real = a.real + b.real;
  var imag = a.imag + b.imag;
  var result = {
    real: real,
    imag: imag
  };
  var e = validateFinite(result);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: result
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function sub(a, b) {
  var real = a.real - b.real;
  var imag = a.imag - b.imag;
  var result = {
    real: real,
    imag: imag
  };
  var e = validateFinite(result);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: result
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function mul(a, b) {
  var real = a.real * b.real - a.imag * b.imag;
  var imag = a.real * b.imag + a.imag * b.real;
  var result = {
    real: real,
    imag: imag
  };
  var e = validateFinite(result);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: result
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function div(a, b) {
  var denom = b.real * b.real + b.imag * b.imag;
  if (denom === 0.0) {
    return {
            TAG: "Error",
            _0: "DivisionByZero"
          };
  }
  var real = (a.real * b.real + a.imag * b.imag) / denom;
  var imag = (a.imag * b.real - a.real * b.imag) / denom;
  var result = {
    real: real,
    imag: imag
  };
  var e = validateFinite(result);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: result
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function magnitude(z) {
  var result = Math.sqrt(z.real * z.real + z.imag * z.imag);
  if (result !== result) {
    return {
            TAG: "Error",
            _0: "NaN"
          };
  } else if (isInf(result)) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: result
          };
  }
}

function magnitudeSquared(z) {
  var result = z.real * z.real + z.imag * z.imag;
  if (result !== result) {
    return {
            TAG: "Error",
            _0: "NaN"
          };
  } else if (isInf(result)) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: result
          };
  }
}

function phase(z) {
  var result = Math.atan2(z.imag, z.real);
  if (result !== result) {
    return {
            TAG: "Error",
            _0: "NaN"
          };
  } else {
    return {
            TAG: "Ok",
            _0: result
          };
  }
}

function scale(z, scalar) {
  if (scalar !== scalar) {
    return {
            TAG: "Error",
            _0: "NaN"
          };
  }
  if (isInf(scalar)) {
    return {
            TAG: "Error",
            _0: "Infinity"
          };
  }
  var result_real = z.real * scalar;
  var result_imag = z.imag * scalar;
  var result = {
    real: result_real,
    imag: result_imag
  };
  var e = validateFinite(result);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: result
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function reciprocal(z) {
  return div(one, z);
}

function square(z) {
  return mul(z, z);
}

function sqrt(z) {
  var e = magnitude(z);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var e$1 = phase(z);
  if (e$1.TAG === "Ok") {
    return fromPolar(Math.sqrt(e._0), e$1._0 / 2.0);
  } else {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
}

function approxEqual(a, b, epsilon) {
  if (Math.abs(a.real - b.real) <= epsilon) {
    return Math.abs(a.imag - b.imag) <= epsilon;
  } else {
    return false;
  }
}

function distance(a, b) {
  var e = sub(a, b);
  if (e.TAG === "Ok") {
    return magnitude(e._0);
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function powInt(_z, _n) {
  while(true) {
    var n = _n;
    var z = _z;
    if (n === 0) {
      return {
              TAG: "Ok",
              _0: one
            };
    }
    if (n < 0) {
      var e = div(one, z);
      if (e.TAG !== "Ok") {
        return {
                TAG: "Error",
                _0: e._0
              };
      }
      _n = -n | 0;
      _z = e._0;
      continue ;
    }
    if (n === 1) {
      return {
              TAG: "Ok",
              _0: z
            };
    }
    var e$1 = powInt(z, n / 2 | 0);
    if (e$1.TAG !== "Ok") {
      return {
              TAG: "Error",
              _0: e$1._0
            };
    }
    var half = e$1._0;
    var e$2 = mul(half, half);
    if (e$2.TAG !== "Ok") {
      return {
              TAG: "Error",
              _0: e$2._0
            };
    }
    var squared = e$2._0;
    if (n % 2 === 0) {
      return {
              TAG: "Ok",
              _0: squared
            };
    } else {
      return mul(squared, z);
    }
  };
}

function toString(z) {
  if (z.imag >= 0.0) {
    return String(z.real) + " + " + String(z.imag) + "i";
  } else {
    return String(z.real) + " - " + String(Math.abs(z.imag)) + "i";
  }
}

function toPolarString(z) {
  var match = magnitude(z);
  var match$1 = phase(z);
  if (match.TAG === "Ok") {
    if (match$1.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: String(match._0) + " * e^(" + String(match$1._0) + "i)"
            };
    } else {
      return {
              TAG: "Error",
              _0: match$1._0
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
}

function compareMagnitude(a, b) {
  var match = magnitudeSquared(a);
  var match$1 = magnitudeSquared(b);
  if (match.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
  var magA = match._0;
  if (match$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match$1._0
          };
  }
  var magB = match$1._0;
  if (magA < magB) {
    return {
            TAG: "Ok",
            _0: -1
          };
  } else if (magA > magB) {
    return {
            TAG: "Ok",
            _0: 1
          };
  } else {
    return {
            TAG: "Ok",
            _0: 0
          };
  }
}

function equal(a, b) {
  if (a.real === b.real) {
    return a.imag === b.imag;
  } else {
    return false;
  }
}

function exp(z) {
  var expReal = Math.exp(z.real);
  if (isInf(expReal)) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return make(expReal * Math.cos(z.imag), expReal * Math.sin(z.imag));
  }
}

function log(z) {
  if (isZero(z)) {
    return {
            TAG: "Error",
            _0: "DivisionByZero"
          };
  }
  var match = magnitude(z);
  var match$1 = phase(z);
  if (match.TAG === "Ok") {
    if (match$1.TAG === "Ok") {
      return make(Math.log(match._0), match$1._0);
    } else {
      return {
              TAG: "Error",
              _0: match$1._0
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
}

var pi = 3.14159265358979323846;

var zero = {
  real: 0.0,
  imag: 0.0
};

var i = {
  real: 0.0,
  imag: 1.0
};

export {
  pi ,
  floatIsNaN ,
  isInf ,
  $$isFinite ,
  validateFinite ,
  make ,
  fromReal ,
  fromImag ,
  fromPolar ,
  zero ,
  i ,
  one ,
  isValid ,
  isZero ,
  isPurelyReal ,
  isPurelyImaginary ,
  conjugate ,
  negate ,
  add ,
  sub ,
  mul ,
  div ,
  magnitude ,
  magnitudeSquared ,
  phase ,
  scale ,
  reciprocal ,
  square ,
  sqrt ,
  approxEqual ,
  distance ,
  powInt ,
  toString ,
  toPolarString ,
  compareMagnitude ,
  equal ,
  exp ,
  log ,
}
/* No side effect */
