// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function reverse(ord) {
  switch (ord) {
    case "Less" :
        return "Greater";
    case "Equal" :
        return "Equal";
    case "Greater" :
        return "Less";
    
  }
}

function then_(first, second) {
  if (first === "Equal") {
    return second;
  } else {
    return first;
  }
}

function toInt(ord) {
  switch (ord) {
    case "Less" :
        return -1;
    case "Equal" :
        return 0;
    case "Greater" :
        return 1;
    
  }
}

function fromInt(value) {
  if (value < 0) {
    return "Less";
  } else if (value > 0) {
    return "Greater";
  } else {
    return "Equal";
  }
}

function compareInt(a, b) {
  if (a < b) {
    return "Less";
  } else if (a > b) {
    return "Greater";
  } else {
    return "Equal";
  }
}

function compareFloat(a, b) {
  var aIsNan = Number.isNaN(a);
  var bIsNan = Number.isNaN(b);
  if (aIsNan && bIsNan) {
    return "Equal";
  } else if (aIsNan) {
    return "Greater";
  } else if (bIsNan || a < b) {
    return "Less";
  } else if (a > b) {
    return "Greater";
  } else {
    return "Equal";
  }
}

function compareString(a, b) {
  var result = a.localeCompare(b);
  if (result < 0.0) {
    return "Less";
  } else if (result > 0.0) {
    return "Greater";
  } else {
    return "Equal";
  }
}

function compareStringIgnoreCase(a, b) {
  var aLower = a.toLowerCase();
  var bLower = b.toLowerCase();
  return compareString(aLower, bLower);
}

function compareOption(a, b, cmp) {
  if (a !== undefined) {
    if (b !== undefined) {
      return cmp(Caml_option.valFromOption(a), Caml_option.valFromOption(b));
    } else {
      return "Greater";
    }
  } else if (b !== undefined) {
    return "Less";
  } else {
    return "Equal";
  }
}

function compareOptionInt(a, b) {
  return compareOption(a, b, compareInt);
}

function compareOptionFloat(a, b) {
  return compareOption(a, b, compareFloat);
}

function compareOptionString(a, b) {
  return compareOption(a, b, compareString);
}

function compareArray(a, b, cmp) {
  var aLen = a.length;
  var bLen = b.length;
  var minLen = aLen < bLen ? aLen : bLen;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= minLen) {
      return compareInt(aLen, bLen);
    }
    var av = a[i];
    var bv = b[i];
    var ord = cmp(av, bv);
    if (ord !== "Equal") {
      return ord;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function compareIntArray(a, b) {
  return compareArray(a, b, compareInt);
}

function compareFloatArray(a, b) {
  return compareArray(a, b, compareFloat);
}

function compareStringArray(a, b) {
  return compareArray(a, b, compareString);
}

function minBy(a, b, cmp) {
  if (cmp(a, b) === "Less") {
    return a;
  } else {
    return b;
  }
}

function maxBy(a, b, cmp) {
  if (cmp(a, b) === "Greater") {
    return a;
  } else {
    return b;
  }
}

function minInt(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function maxInt(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function minFloat(a, b) {
  if (Number.isNaN(a) || !(Number.isNaN(b) || a < b)) {
    return b;
  } else {
    return a;
  }
}

function maxFloat(a, b) {
  if (Number.isNaN(a) || !(Number.isNaN(b) || a > b)) {
    return b;
  } else {
    return a;
  }
}

function clampInt(value, lower, upper) {
  return maxInt(lower, minInt(upper, value));
}

function clampFloat(value, lower, upper) {
  return maxFloat(lower, minFloat(upper, value));
}

function inRangeInt(value, lower, upper) {
  if (value >= lower) {
    return value <= upper;
  } else {
    return false;
  }
}

function inRangeFloat(value, lower, upper) {
  if (value >= lower) {
    return value <= upper;
  } else {
    return false;
  }
}

function minArray(arr, cmp) {
  if (arr.length === 0) {
    return ;
  }
  var result = {
    contents: arr[0]
  };
  Belt_Array.forEach(arr, (function (item) {
          if (cmp(item, result.contents) === "Less") {
            result.contents = item;
            return ;
          }
          
        }));
  return Caml_option.some(result.contents);
}

function maxArray(arr, cmp) {
  if (arr.length === 0) {
    return ;
  }
  var result = {
    contents: arr[0]
  };
  Belt_Array.forEach(arr, (function (item) {
          if (cmp(item, result.contents) === "Greater") {
            result.contents = item;
            return ;
          }
          
        }));
  return Caml_option.some(result.contents);
}

function minIntArray(arr) {
  return minArray(arr, compareInt);
}

function maxIntArray(arr) {
  return maxArray(arr, compareInt);
}

function minFloatArray(arr) {
  return minArray(arr, compareFloat);
}

function maxFloatArray(arr) {
  return maxArray(arr, compareFloat);
}

function isSorted(arr, cmp) {
  var len = arr.length;
  if (len <= 1) {
    return true;
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= (len - 1 | 0)) {
      return true;
    }
    var a = arr[i];
    var b = arr[i + 1 | 0];
    if (cmp(a, b) === "Greater") {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function isSortedInt(arr) {
  return isSorted(arr, compareInt);
}

function isSortedFloat(arr) {
  return isSorted(arr, compareFloat);
}

function isSortedString(arr) {
  return isSorted(arr, compareString);
}

function isSortedDescending(arr, cmp) {
  var len = arr.length;
  if (len <= 1) {
    return true;
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= (len - 1 | 0)) {
      return true;
    }
    var a = arr[i];
    var b = arr[i + 1 | 0];
    if (cmp(a, b) === "Less") {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function reverseComparator(cmp) {
  return function (a, b) {
    return reverse(cmp(a, b));
  };
}

function combineComparators(comparators) {
  return function (a, b) {
    var len = comparators.length;
    var _i = 0;
    while(true) {
      var i = _i;
      if (i >= len) {
        return "Equal";
      }
      var cmp = comparators[i];
      var result = cmp(a, b);
      if (result !== "Equal") {
        return result;
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
}

export {
  reverse ,
  then_ ,
  toInt ,
  fromInt ,
  compareInt ,
  compareFloat ,
  compareString ,
  compareStringIgnoreCase ,
  compareOption ,
  compareOptionInt ,
  compareOptionFloat ,
  compareOptionString ,
  compareArray ,
  compareIntArray ,
  compareFloatArray ,
  compareStringArray ,
  minBy ,
  maxBy ,
  minInt ,
  maxInt ,
  minFloat ,
  maxFloat ,
  clampInt ,
  clampFloat ,
  inRangeInt ,
  inRangeFloat ,
  minArray ,
  maxArray ,
  minIntArray ,
  maxIntArray ,
  minFloatArray ,
  maxFloatArray ,
  isSorted ,
  isSortedInt ,
  isSortedFloat ,
  isSortedString ,
  isSortedDescending ,
  reverseComparator ,
  combineComparators ,
}
/* No side effect */
