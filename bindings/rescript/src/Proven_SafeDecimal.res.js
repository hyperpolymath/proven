// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Float from "rescript/lib/es6/belt_Float.js";

function fromInt(value) {
  return {
          mantissa: value,
          scale: 0
        };
}

function fromFloat(value, scale) {
  var actualScale = scale > 18 ? 18 : (
      scale < 0 ? 0 : scale
    );
  var multiplier = Math.pow(10.0, actualScale);
  var mantissa = Math.round(value * multiplier);
  return {
          mantissa: mantissa,
          scale: actualScale
        };
}

function fromParts(mantissa, scale) {
  var actualScale = scale > 18 ? 18 : (
      scale < 0 ? 0 : scale
    );
  return {
          mantissa: mantissa,
          scale: actualScale
        };
}

function parse(input) {
  var trimmed = input.trim();
  if (trimmed.length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidFormat"
          };
  }
  var hasExponent = trimmed.includes("e") || trimmed.includes("E");
  if (hasExponent) {
    var value = Belt_Float.fromString(trimmed);
    if (value === undefined) {
      return {
              TAG: "Error",
              _0: "InvalidFormat"
            };
    }
    var lowerStr = trimmed.toLowerCase();
    var parts = lowerStr.split("e");
    if (parts.length !== 2) {
      return {
              TAG: "Error",
              _0: "InvalidFormat"
            };
    }
    var numPart = parts[0];
    var expPart = parts[1];
    var decimalIdx = numPart.indexOf(".");
    var numDecimals = decimalIdx >= 0 ? (numPart.length - decimalIdx | 0) - 1 | 0 : 0;
    var exp = Belt_Int.fromString(expPart);
    if (exp === undefined) {
      return {
              TAG: "Error",
              _0: "InvalidFormat"
            };
    }
    var scale = numDecimals - exp | 0;
    if (scale < 0) {
      var multiplier = Math.pow(10.0, -scale | 0);
      return {
              TAG: "Ok",
              _0: {
                mantissa: Math.round(value * multiplier),
                scale: 0
              }
            };
    }
    if (scale > 18) {
      return {
              TAG: "Error",
              _0: "Overflow"
            };
    }
    var multiplier$1 = Math.pow(10.0, scale);
    return {
            TAG: "Ok",
            _0: {
              mantissa: Math.round(value * multiplier$1),
              scale: scale
            }
          };
  }
  var decimalIdx$1 = trimmed.indexOf(".");
  if (decimalIdx$1 < 0) {
    var value$1 = Belt_Float.fromString(trimmed);
    if (value$1 !== undefined) {
      return {
              TAG: "Ok",
              _0: {
                mantissa: value$1,
                scale: 0
              }
            };
    } else {
      return {
              TAG: "Error",
              _0: "InvalidFormat"
            };
    }
  }
  var intPart = trimmed.slice(0, decimalIdx$1);
  var fracPart = trimmed.slice(decimalIdx$1 + 1 | 0);
  var cleanInt = intPart.replace(/_/g, "");
  var cleanFrac = fracPart.replace(/_/g, "");
  var scale$1 = cleanFrac.length;
  if (scale$1 > 18) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  }
  var combined = cleanInt + cleanFrac;
  var mantissa = Belt_Float.fromString(combined);
  if (mantissa !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              mantissa: mantissa,
              scale: scale$1
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidFormat"
          };
  }
}

function intPart(d) {
  if (d.scale === 0) {
    return d.mantissa;
  }
  var divisor = Math.pow(10.0, d.scale);
  return Math.trunc(d.mantissa / divisor);
}

function fracPart(d) {
  if (d.scale === 0) {
    return 0.0;
  }
  var divisor = Math.pow(10.0, d.scale);
  return Math.abs(d.mantissa % divisor);
}

function isZero(d) {
  return d.mantissa === 0.0;
}

function isNegative(d) {
  return d.mantissa < 0.0;
}

function isPositive(d) {
  return d.mantissa > 0.0;
}

function abs(d) {
  return {
          mantissa: Math.abs(d.mantissa),
          scale: d.scale
        };
}

function negate(d) {
  return {
          mantissa: - d.mantissa,
          scale: d.scale
        };
}

function rescale(d, newScale) {
  if (newScale === d.scale) {
    return {
            TAG: "Ok",
            _0: d
          };
  }
  if (newScale > d.scale) {
    var diff = newScale - d.scale | 0;
    var multiplier = Math.pow(10.0, diff);
    var newMantissa = d.mantissa * multiplier;
    if (Math.abs(newMantissa) > 9007199254740991.0) {
      return {
              TAG: "Error",
              _0: "Overflow"
            };
    } else {
      return {
              TAG: "Ok",
              _0: {
                mantissa: newMantissa,
                scale: newScale
              }
            };
    }
  }
  var diff$1 = d.scale - newScale | 0;
  var divisor = Math.pow(10.0, diff$1);
  return {
          TAG: "Ok",
          _0: {
            mantissa: Math.trunc(d.mantissa / divisor),
            scale: newScale
          }
        };
}

function add(a, b) {
  var maxScaleVal = a.scale > b.scale ? a.scale : b.scale;
  var match = rescale(a, maxScaleVal);
  var match$1 = rescale(b, maxScaleVal);
  if (match.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
  if (match$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match$1._0
          };
  }
  var result = match._0.mantissa + match$1._0.mantissa;
  if (Math.abs(result) > 9007199254740991.0) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              mantissa: result,
              scale: maxScaleVal
            }
          };
  }
}

function sub(a, b) {
  var maxScaleVal = a.scale > b.scale ? a.scale : b.scale;
  var match = rescale(a, maxScaleVal);
  var match$1 = rescale(b, maxScaleVal);
  if (match.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
  if (match$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match$1._0
          };
  }
  var result = match._0.mantissa - match$1._0.mantissa;
  if (Math.abs(result) > 9007199254740991.0) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              mantissa: result,
              scale: maxScaleVal
            }
          };
  }
}

function mul(a, b) {
  var resultMantissa = a.mantissa * b.mantissa;
  var resultScale = a.scale + b.scale | 0;
  if (resultScale <= 18) {
    return {
            TAG: "Ok",
            _0: {
              mantissa: resultMantissa,
              scale: resultScale
            }
          };
  }
  var reduceBy = resultScale - 18 | 0;
  var divisor = Math.pow(10.0, reduceBy);
  return {
          TAG: "Ok",
          _0: {
            mantissa: Math.trunc(resultMantissa / divisor),
            scale: 18
          }
        };
}

function div(a, b, precision) {
  if (b.mantissa === 0.0) {
    return {
            TAG: "Error",
            _0: "DivisionByZero"
          };
  }
  var targetScale = precision > 18 ? 18 : precision;
  var scaleDiff = (targetScale + b.scale | 0) - a.scale | 0;
  var dividend;
  if (scaleDiff > 0) {
    var multiplier = Math.pow(10.0, scaleDiff);
    dividend = a.mantissa * multiplier;
  } else if (scaleDiff < 0) {
    var divisor = Math.pow(10.0, -scaleDiff | 0);
    dividend = a.mantissa / divisor;
  } else {
    dividend = a.mantissa;
  }
  var result = Math.trunc(dividend / b.mantissa);
  return {
          TAG: "Ok",
          _0: {
            mantissa: result,
            scale: targetScale
          }
        };
}

function round(d, decimalPlaces) {
  if (decimalPlaces >= d.scale) {
    return d;
  }
  var diff = d.scale - decimalPlaces | 0;
  var divisor = Math.pow(10.0, diff);
  var halfDivisor = divisor / 2.0;
  var isNeg = d.mantissa < 0.0;
  var absMantissa = Math.abs(d.mantissa);
  var remainder = absMantissa % divisor;
  var truncated = Math.trunc(absMantissa / divisor);
  var rounded = remainder >= halfDivisor ? truncated + 1.0 : truncated;
  var finalMantissa = isNeg ? - rounded : rounded;
  return {
          mantissa: finalMantissa,
          scale: decimalPlaces
        };
}

function truncate(d, decimalPlaces) {
  if (decimalPlaces >= d.scale) {
    return d;
  }
  var diff = d.scale - decimalPlaces | 0;
  var divisor = Math.pow(10.0, diff);
  return {
          mantissa: Math.trunc(d.mantissa / divisor),
          scale: decimalPlaces
        };
}

function compare(a, b) {
  var maxScaleVal = a.scale > b.scale ? a.scale : b.scale;
  var d = rescale(a, maxScaleVal);
  var aScaled;
  aScaled = d.TAG === "Ok" ? d._0.mantissa : a.mantissa;
  var d$1 = rescale(b, maxScaleVal);
  var bScaled;
  bScaled = d$1.TAG === "Ok" ? d$1._0.mantissa : b.mantissa;
  if (aScaled < bScaled) {
    return -1;
  } else if (aScaled > bScaled) {
    return 1;
  } else {
    return 0;
  }
}

function equal(a, b) {
  return compare(a, b) === 0;
}

function toFloat(d) {
  var divisor = Math.pow(10.0, d.scale);
  return d.mantissa / divisor;
}

function toString(d) {
  if (d.scale === 0) {
    return String(d.mantissa);
  }
  var divisor = Math.pow(10.0, d.scale);
  var intPartVal = Math.trunc(Math.abs(d.mantissa) / divisor);
  var fracPartVal = Math.abs(d.mantissa) % divisor;
  var sign = d.mantissa < 0.0 ? "-" : "";
  var fracStr = String(fracPartVal);
  var paddedFrac;
  if (fracStr.length < d.scale) {
    var padding = "0".repeat(d.scale - fracStr.length | 0);
    paddedFrac = padding + fracStr;
  } else {
    paddedFrac = fracStr;
  }
  return sign + String(intPartVal) + "." + paddedFrac;
}

function isValidDecimal(input) {
  var match = parse(input);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function parsePercent(input) {
  var trimmed = input.trim();
  if (trimmed.length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidFormat"
          };
  }
  var hasPercent = trimmed.endsWith("%");
  var numberStr = hasPercent ? trimmed.slice(0, trimmed.length - 1 | 0) : trimmed;
  var e = parse(numberStr);
  if (e.TAG === "Ok") {
    return div(e._0, {
                mantissa: 100,
                scale: 0
              }, 18);
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function floor(d) {
  if (d.scale === 0) {
    return d;
  }
  var floatVal = toFloat(d);
  return {
          mantissa: Math.floor(floatVal) | 0,
          scale: 0
        };
}

function ceil(d) {
  if (d.scale === 0) {
    return d;
  }
  var floatVal = toFloat(d);
  return {
          mantissa: Math.ceil(floatVal) | 0,
          scale: 0
        };
}

function lessThan(a, b) {
  return compare(a, b) < 0;
}

function greaterThan(a, b) {
  return compare(a, b) > 0;
}

function lessThanOrEqual(a, b) {
  return compare(a, b) <= 0;
}

function greaterThanOrEqual(a, b) {
  return compare(a, b) >= 0;
}

function min(a, b) {
  if (compare(a, b) <= 0) {
    return a;
  } else {
    return b;
  }
}

function max(a, b) {
  if (compare(a, b) >= 0) {
    return a;
  } else {
    return b;
  }
}

function percentOf(d, percent) {
  var e = mul(d, {
        mantissa: percent,
        scale: 0
      });
  if (e.TAG === "Ok") {
    return div(e._0, {
                mantissa: 100,
                scale: 0
              }, d.scale);
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function addPercent(d, percent) {
  var e = percentOf(d, percent);
  if (e.TAG === "Ok") {
    return add(d, e._0);
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function formatCurrency(d, symbol, decimalPlaces) {
  var rounded = round(d, decimalPlaces);
  var formatted = toString(rounded);
  var parts = formatted.split(".");
  var intPartStr = parts[0];
  var fracPartStr = parts.length > 1 ? parts[1] : "";
  var paddedFrac = fracPartStr.length < decimalPlaces ? fracPartStr + "0".repeat(decimalPlaces - fracPartStr.length | 0) : fracPartStr.slice(0, decimalPlaces);
  if (decimalPlaces > 0) {
    return symbol + intPartStr + "." + paddedFrac;
  } else {
    return symbol + intPartStr;
  }
}

var maxPrecision = 38;

var maxScale = 18;

var zero = {
  mantissa: 0.0,
  scale: 0
};

var one = {
  mantissa: 1.0,
  scale: 0
};

var oneHalf = {
  mantissa: 5.0,
  scale: 1
};

var oneQuarter = {
  mantissa: 25.0,
  scale: 2
};

var threeQuarters = {
  mantissa: 75.0,
  scale: 2
};

var oneTenth = {
  mantissa: 1.0,
  scale: 1
};

var oneHundredth = {
  mantissa: 1.0,
  scale: 2
};

export {
  maxPrecision ,
  maxScale ,
  fromInt ,
  fromFloat ,
  fromParts ,
  zero ,
  one ,
  parse ,
  intPart ,
  fracPart ,
  isZero ,
  isNegative ,
  isPositive ,
  abs ,
  negate ,
  rescale ,
  add ,
  sub ,
  mul ,
  div ,
  round ,
  truncate ,
  compare ,
  equal ,
  toFloat ,
  toString ,
  isValidDecimal ,
  parsePercent ,
  floor ,
  ceil ,
  lessThan ,
  greaterThan ,
  lessThanOrEqual ,
  greaterThanOrEqual ,
  min ,
  max ,
  percentOf ,
  addPercent ,
  formatCurrency ,
  oneHalf ,
  oneQuarter ,
  threeQuarters ,
  oneTenth ,
  oneHundredth ,
}
/* No side effect */
