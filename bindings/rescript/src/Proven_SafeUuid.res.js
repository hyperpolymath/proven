// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Proven_Bitwise from "./Proven_Bitwise.res.js";

var uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

function hexCharToInt($$char) {
  var code = $$char.charCodeAt(0) | 0;
  if (code >= 48 && code <= 57) {
    return code - 48 | 0;
  } else if (code >= 65 && code <= 70) {
    return code - 55 | 0;
  } else if (code >= 97 && code <= 102) {
    return code - 87 | 0;
  } else {
    return ;
  }
}

function hexByteToInt(hexByte) {
  if (hexByte.length !== 2) {
    return ;
  }
  var match = hexCharToInt(hexByte.charAt(0));
  var match$1 = hexCharToInt(hexByte.charAt(1));
  if (match !== undefined && match$1 !== undefined) {
    return Proven_Bitwise.lsl(match, 4) + match$1 | 0;
  }
  
}

function getVersion(versionByte) {
  var match = Proven_Bitwise.lsr(versionByte, 4);
  switch (match) {
    case 1 :
        return "V1";
    case 2 :
        return "V2";
    case 3 :
        return "V3";
    case 4 :
        return "V4";
    case 5 :
        return "V5";
    case 6 :
        return "V6";
    case 7 :
        return "V7";
    case 8 :
        return "V8";
    default:
      return "Unknown";
  }
}

function getVariant(variantByte) {
  var highBits = Proven_Bitwise.lsr(variantByte, 4);
  if (Proven_Bitwise.land(highBits, 8) === 0) {
    return "NCS";
  } else if (Proven_Bitwise.land(highBits, 12) === 8) {
    return "RFC4122";
  } else if (Proven_Bitwise.land(highBits, 14) === 12) {
    return "Microsoft";
  } else if (Proven_Bitwise.land(highBits, 14) === 14) {
    return "Future";
  } else {
    return "Unknown";
  }
}

function parse(uuidStr) {
  var trimmed = uuidStr.trim();
  var normalized = trimmed.toLowerCase();
  if (!uuidRegex.test(normalized)) {
    if (normalized.length !== 36) {
      return {
              TAG: "Error",
              _0: "InvalidLength"
            };
    } else {
      return {
              TAG: "Error",
              _0: "InvalidFormat"
            };
    }
  }
  var hexOnly = normalized.replace(/-/g, "");
  var bytes = Belt_Array.makeBy(16, (function (param) {
          return 0;
        }));
  var valid = true;
  for(var i = 0; i <= 15; ++i){
    var hexByte = hexOnly.slice((i << 1), ((i + 1 | 0) << 1));
    var $$byte = hexByteToInt(hexByte);
    if ($$byte !== undefined) {
      bytes[i] = $$byte;
    } else {
      valid = false;
    }
  }
  if (!valid) {
    return {
            TAG: "Error",
            _0: "InvalidHexCharacter"
          };
  }
  var versionByte = bytes[6];
  var variantByte = bytes[8];
  return {
          TAG: "Ok",
          _0: {
            bytes: bytes,
            version: getVersion(versionByte),
            variant: getVariant(variantByte),
            formatted: normalized
          }
        };
}

function isValid(uuidStr) {
  var match = parse(uuidStr);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function format(uuid) {
  return uuid.formatted;
}

function formatUppercase(uuid) {
  return uuid.formatted.toUpperCase();
}

function formatCompact(uuid) {
  return uuid.formatted.replace(/-/g, "");
}

function getVersionFromUuid(uuid) {
  return uuid.version;
}

function getVariantFromUuid(uuid) {
  return uuid.variant;
}

function versionToString(version) {
  switch (version) {
    case "V1" :
        return "1";
    case "V2" :
        return "2";
    case "V3" :
        return "3";
    case "V4" :
        return "4";
    case "V5" :
        return "5";
    case "V6" :
        return "6";
    case "V7" :
        return "7";
    case "V8" :
        return "8";
    case "Unknown" :
        return "unknown";
    
  }
}

function variantToString(variant) {
  switch (variant) {
    case "NCS" :
        return "NCS";
    case "RFC4122" :
        return "RFC4122";
    case "Microsoft" :
        return "Microsoft";
    case "Future" :
        return "Future";
    case "Unknown" :
        return "unknown";
    
  }
}

function nil() {
  return {
          bytes: Belt_Array.make(16, 0),
          version: "Unknown",
          variant: "NCS",
          formatted: "00000000-0000-0000-0000-000000000000"
        };
}

function isNil(uuid) {
  return Belt_Array.every(uuid.bytes, (function ($$byte) {
                return $$byte === 0;
              }));
}

function equal(uuidA, uuidB) {
  return Belt_Array.eq(uuidA.bytes, uuidB.bytes, (function (a, b) {
                return a === b;
              }));
}

function compare(uuidA, uuidB) {
  var _index = 0;
  while(true) {
    var index = _index;
    if (index >= 16) {
      return 0;
    }
    var byteA = uuidA.bytes[index];
    var byteB = uuidB.bytes[index];
    if (byteA < byteB) {
      return -1;
    }
    if (byteA > byteB) {
      return 1;
    }
    _index = index + 1 | 0;
    continue ;
  };
}

export {
  uuidRegex ,
  hexCharToInt ,
  hexByteToInt ,
  getVersion ,
  getVariant ,
  parse ,
  isValid ,
  format ,
  formatUppercase ,
  formatCompact ,
  getVersionFromUuid ,
  getVariantFromUuid ,
  versionToString ,
  variantToString ,
  nil ,
  isNil ,
  equal ,
  compare ,
}
/* No side effect */
