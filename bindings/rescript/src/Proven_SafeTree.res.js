// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function make() {
  return {
          nodes: [],
          nodeCount: 0,
          root: undefined,
          maxNodes: 1024,
          maxDepth: 64
        };
}

function makeWithLimits(maxNodes, maxDepth) {
  return {
          nodes: [],
          nodeCount: 0,
          root: undefined,
          maxNodes: maxNodes,
          maxDepth: maxDepth
        };
}

function length(tree) {
  return tree.nodeCount;
}

function isEmpty(tree) {
  return tree.nodeCount === 0;
}

function getRoot(tree) {
  return tree.root;
}

function setRoot(tree, value) {
  var match = tree.root;
  if (match !== undefined) {
    return {
            TAG: "Error",
            _0: "RootAlreadyExists"
          };
  }
  if (tree.nodeCount >= tree.maxNodes) {
    return {
            TAG: "Error",
            _0: "MaxNodesReached"
          };
  }
  var nodeId = tree.nodeCount;
  var node = {
    value: value,
    parent: -1,
    depth: 0,
    childCount: 0
  };
  tree.nodes = Belt_Array.concat(tree.nodes, [node]);
  tree.nodeCount = tree.nodeCount + 1 | 0;
  tree.root = nodeId;
  return {
          TAG: "Ok",
          _0: nodeId
        };
}

function addChild(tree, parentId, value) {
  if (parentId < 0 || parentId >= tree.nodeCount) {
    return {
            TAG: "Error",
            _0: "InvalidParent"
          };
  }
  var match = Belt_Array.get(tree.nodes, parentId);
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidParent"
          };
  }
  var parentNode = Caml_option.valFromOption(match);
  if (parentNode === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidParent"
          };
  }
  if (tree.nodeCount >= tree.maxNodes) {
    return {
            TAG: "Error",
            _0: "MaxNodesReached"
          };
  }
  var newDepth = parentNode.depth + 1 | 0;
  if (newDepth > tree.maxDepth) {
    return {
            TAG: "Error",
            _0: "MaxDepthExceeded"
          };
  }
  var nodeId = tree.nodeCount;
  var node = {
    value: value,
    parent: parentId,
    depth: newDepth,
    childCount: 0
  };
  tree.nodes = Belt_Array.concat(tree.nodes, [node]);
  tree.nodeCount = tree.nodeCount + 1 | 0;
  parentNode.childCount = parentNode.childCount + 1 | 0;
  return {
          TAG: "Ok",
          _0: nodeId
        };
}

function getValue(tree, nodeId) {
  if (nodeId < 0 || nodeId >= tree.nodeCount) {
    return ;
  }
  var match = Belt_Array.get(tree.nodes, nodeId);
  if (match === undefined) {
    return ;
  }
  var node = Caml_option.valFromOption(match);
  if (node !== undefined) {
    return Caml_option.some(node.value);
  }
  
}

function setValue(tree, nodeId, value) {
  if (nodeId < 0 || nodeId >= tree.nodeCount) {
    return {
            TAG: "Error",
            _0: "NodeNotFound"
          };
  }
  var match = Belt_Array.get(tree.nodes, nodeId);
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: "NodeNotFound"
          };
  }
  var node = Caml_option.valFromOption(match);
  if (node === undefined) {
    return {
            TAG: "Error",
            _0: "NodeNotFound"
          };
  }
  var updatedNode = {
    value: value,
    parent: node.parent,
    depth: node.depth,
    childCount: node.childCount
  };
  tree.nodes[nodeId] = updatedNode;
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function getParent(tree, nodeId) {
  if (nodeId < 0 || nodeId >= tree.nodeCount) {
    return ;
  }
  var match = Belt_Array.get(tree.nodes, nodeId);
  if (match === undefined) {
    return ;
  }
  var node = Caml_option.valFromOption(match);
  if (node !== undefined && node.parent !== -1) {
    return node.parent;
  }
  
}

function getDepth(tree, nodeId) {
  if (nodeId < 0 || nodeId >= tree.nodeCount) {
    return ;
  }
  var match = Belt_Array.get(tree.nodes, nodeId);
  if (match === undefined) {
    return ;
  }
  var node = Caml_option.valFromOption(match);
  if (node !== undefined) {
    return node.depth;
  }
  
}

function isRoot(tree, nodeId) {
  var rootId = tree.root;
  if (rootId !== undefined) {
    return nodeId === rootId;
  } else {
    return false;
  }
}

function isLeaf(tree, nodeId) {
  if (nodeId < 0 || nodeId >= tree.nodeCount) {
    return false;
  }
  var match = Belt_Array.get(tree.nodes, nodeId);
  if (match === undefined) {
    return false;
  }
  var node = Caml_option.valFromOption(match);
  if (node !== undefined) {
    return node.childCount === 0;
  } else {
    return false;
  }
}

function getChildren(tree, parentId) {
  var children = [];
  for(var i = 0 ,i_finish = tree.nodeCount; i < i_finish; ++i){
    var match = Belt_Array.get(tree.nodes, i);
    if (match !== undefined) {
      var node = Caml_option.valFromOption(match);
      if (node !== undefined && node.parent === parentId) {
        children = Belt_Array.concat(children, [i]);
      }
      
    }
    
  }
  return children;
}

function getChildCount(tree, nodeId) {
  if (nodeId < 0 || nodeId >= tree.nodeCount) {
    return 0;
  }
  var match = Belt_Array.get(tree.nodes, nodeId);
  if (match === undefined) {
    return 0;
  }
  var node = Caml_option.valFromOption(match);
  if (node !== undefined) {
    return node.childCount;
  } else {
    return 0;
  }
}

function getPath(tree, nodeId) {
  if (nodeId < 0 || nodeId >= tree.nodeCount) {
    return [];
  }
  var match = Belt_Array.get(tree.nodes, nodeId);
  if (match === undefined) {
    return [];
  }
  if (Caml_option.valFromOption(match) === undefined) {
    return [];
  }
  var path = [];
  var current = nodeId;
  var iterations = 0;
  var $$continue = true;
  while($$continue && iterations <= tree.maxDepth) {
    path = Belt_Array.concat([current], path);
    var match$1 = Belt_Array.get(tree.nodes, current);
    if (match$1 !== undefined) {
      var node = Caml_option.valFromOption(match$1);
      if (node !== undefined && node.parent !== -1) {
        current = node.parent;
      } else {
        $$continue = false;
      }
    } else {
      $$continue = false;
    }
    iterations = iterations + 1 | 0;
  };
  return path;
}

function isAncestor(tree, ancestorId, descendantId) {
  if (ancestorId < 0 || ancestorId >= tree.nodeCount || descendantId < 0 || descendantId >= tree.nodeCount) {
    return false;
  }
  var current = descendantId;
  var found = false;
  var iterations = 0;
  while(!found && iterations <= tree.maxDepth) {
    var match = Belt_Array.get(tree.nodes, current);
    if (match !== undefined) {
      var node = Caml_option.valFromOption(match);
      if (node !== undefined) {
        if (node.parent === ancestorId) {
          found = true;
        } else if (node.parent === -1) {
          iterations = tree.maxDepth + 1 | 0;
        } else {
          current = node.parent;
        }
      } else {
        iterations = tree.maxDepth + 1 | 0;
      }
    } else {
      iterations = tree.maxDepth + 1 | 0;
    }
    iterations = iterations + 1 | 0;
  };
  return found;
}

function lowestCommonAncestor(tree, idA, idB) {
  if (idA < 0 || idA >= tree.nodeCount || idB < 0 || idB >= tree.nodeCount) {
    return ;
  }
  var pathA = getPath(tree, idA);
  var pathB = getPath(tree, idB);
  var lca;
  var minLen = Math.min(pathA.length, pathB.length);
  for(var i = 0; i < minLen; ++i){
    var match = Belt_Array.get(pathA, i);
    var match$1 = Belt_Array.get(pathB, i);
    if (match !== undefined && match$1 !== undefined && match === match$1) {
      lca = match;
    }
    
  }
  return lca;
}

function getMaxDepth(tree) {
  var maxDepthVal = 0;
  for(var i = 0 ,i_finish = tree.nodeCount; i < i_finish; ++i){
    var match = Belt_Array.get(tree.nodes, i);
    if (match !== undefined) {
      var node = Caml_option.valFromOption(match);
      if (node !== undefined && node.depth > maxDepthVal) {
        maxDepthVal = node.depth;
      }
      
    }
    
  }
  return maxDepthVal;
}

function countLeaves(tree) {
  var count = 0;
  for(var i = 0 ,i_finish = tree.nodeCount; i < i_finish; ++i){
    var match = Belt_Array.get(tree.nodes, i);
    if (match !== undefined) {
      var node = Caml_option.valFromOption(match);
      if (node !== undefined && node.childCount === 0) {
        count = count + 1 | 0;
      }
      
    }
    
  }
  return count;
}

function preorderTraversal(tree) {
  var rootId = tree.root;
  if (rootId === undefined) {
    return [];
  }
  var result = [];
  var stack = [rootId];
  while(stack.length !== 0) {
    var lastIdx = stack.length - 1 | 0;
    var current = Belt_Array.get(stack, lastIdx);
    if (current !== undefined) {
      stack = Belt_Array.slice(stack, 0, lastIdx);
      result = Belt_Array.concat(result, [current]);
      var children = getChildren(tree, current);
      var reversedChildren = Belt_Array.reverse(children);
      stack = Belt_Array.concat(stack, reversedChildren);
    }
    
  };
  return result;
}

function levelOrderTraversal(tree) {
  var rootId = tree.root;
  if (rootId === undefined) {
    return [];
  }
  var result = [];
  var queue = [rootId];
  while(queue.length !== 0) {
    var current = Belt_Array.get(queue, 0);
    if (current !== undefined) {
      queue = Belt_Array.sliceToEnd(queue, 1);
      result = Belt_Array.concat(result, [current]);
      var children = getChildren(tree, current);
      queue = Belt_Array.concat(queue, children);
    }
    
  };
  return result;
}

function clear(tree) {
  tree.nodes = [];
  tree.nodeCount = 0;
  tree.root = undefined;
}

function map(tree, f) {
  var newTree = makeWithLimits(tree.maxNodes, tree.maxDepth);
  newTree.nodeCount = tree.nodeCount;
  newTree.root = tree.root;
  newTree.nodes = Belt_Array.map(tree.nodes, (function (nodeOpt) {
          if (nodeOpt !== undefined) {
            return {
                    value: f(nodeOpt.value),
                    parent: nodeOpt.parent,
                    depth: nodeOpt.depth,
                    childCount: nodeOpt.childCount
                  };
          }
          
        }));
  return newTree;
}

function fold(tree, init, f) {
  var order = preorderTraversal(tree);
  return Belt_Array.reduce(order, init, (function (acc, nodeId) {
                var value = getValue(tree, nodeId);
                if (value !== undefined) {
                  return f(acc, Caml_option.valFromOption(value));
                } else {
                  return acc;
                }
              }));
}

function filter(tree, predicate) {
  var result = [];
  for(var i = 0 ,i_finish = tree.nodeCount; i < i_finish; ++i){
    var match = Belt_Array.get(tree.nodes, i);
    if (match !== undefined) {
      var node = Caml_option.valFromOption(match);
      if (node !== undefined && predicate(node.value)) {
        result = Belt_Array.concat(result, [i]);
      }
      
    }
    
  }
  return result;
}

function find(tree, predicate) {
  var result;
  var i = 0;
  while(result === undefined && i < tree.nodeCount) {
    var match = Belt_Array.get(tree.nodes, i);
    if (match !== undefined) {
      var node = Caml_option.valFromOption(match);
      if (node !== undefined && predicate(node.value)) {
        result = i;
      }
      
    }
    i = i + 1 | 0;
  };
  return result;
}

function getValuesAtDepth(tree, depth) {
  var result = [];
  for(var i = 0 ,i_finish = tree.nodeCount; i < i_finish; ++i){
    var match = Belt_Array.get(tree.nodes, i);
    if (match !== undefined) {
      var node = Caml_option.valFromOption(match);
      if (node !== undefined && node.depth === depth) {
        result = Belt_Array.concat(result, [node.value]);
      }
      
    }
    
  }
  return result;
}

function getSubtree(tree, rootId) {
  if (rootId < 0 || rootId >= tree.nodeCount) {
    return [];
  }
  var result = [];
  var stack = [rootId];
  while(stack.length !== 0) {
    var lastIdx = stack.length - 1 | 0;
    var current = Belt_Array.get(stack, lastIdx);
    if (current !== undefined) {
      stack = Belt_Array.slice(stack, 0, lastIdx);
      result = Belt_Array.concat(result, [current]);
      var children = getChildren(tree, current);
      stack = Belt_Array.concat(stack, children);
    }
    
  };
  return result;
}

var defaultMaxDepth = 64;

var defaultMaxNodes = 1024;

var noParent = -1;

export {
  defaultMaxDepth ,
  defaultMaxNodes ,
  noParent ,
  make ,
  makeWithLimits ,
  length ,
  isEmpty ,
  getRoot ,
  setRoot ,
  addChild ,
  getValue ,
  setValue ,
  getParent ,
  getDepth ,
  isRoot ,
  isLeaf ,
  getChildren ,
  getChildCount ,
  getPath ,
  isAncestor ,
  lowestCommonAncestor ,
  getMaxDepth ,
  countLeaves ,
  preorderTraversal ,
  levelOrderTraversal ,
  clear ,
  map ,
  fold ,
  filter ,
  find ,
  getValuesAtDepth ,
  getSubtree ,
}
/* No side effect */
