// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Proven_Bitwise from "./Proven_Bitwise.res.js";

function eventTypeToString(et) {
  switch (et) {
    case "Created" :
        return "created";
    case "Modified" :
        return "modified";
    case "Accessed" :
        return "accessed";
    case "Copied" :
        return "copied";
    case "Transformed" :
        return "transformed";
    case "Validated" :
        return "validated";
    case "Exported" :
        return "exported";
    case "Imported" :
        return "imported";
    case "Deleted" :
        return "deleted";
    case "Restored" :
        return "restored";
    case "Merged" :
        return "merged";
    case "Split" :
        return "split";
    
  }
}

function classificationValue(c) {
  switch (c) {
    case "Public" :
        return 0;
    case "Internal" :
        return 1;
    case "Confidential" :
        return 2;
    case "Restricted" :
        return 3;
    case "TopSecret" :
        return 4;
    
  }
}

function classificationIsAtLeast(self, other) {
  return classificationValue(self) >= classificationValue(other);
}

function classificationMax(a, b) {
  if (classificationValue(a) > classificationValue(b)) {
    return a;
  } else {
    return b;
  }
}

function databaseSource(table) {
  return {
          sourceType: "Database",
          identifier: table,
          version: undefined,
          location: undefined
        };
}

function fileSource(path) {
  return {
          sourceType: "File",
          identifier: path,
          version: undefined,
          location: undefined
        };
}

function apiSource(endpoint) {
  return {
          sourceType: "Api",
          identifier: endpoint,
          version: undefined,
          location: undefined
        };
}

function userInputSource(userId) {
  return {
          sourceType: "UserInput",
          identifier: userId,
          version: undefined,
          location: undefined
        };
}

function derivedSource(from) {
  return {
          sourceType: "Derived",
          identifier: from,
          version: undefined,
          location: undefined
        };
}

function computeHash(entry) {
  var parts = [
    String(entry.timestamp),
    eventTypeToString(entry.eventType),
    entry.actor,
    Belt_Option.getWithDefault(entry.description, "")
  ];
  var h = entry.previousHash;
  if (h !== undefined) {
    parts.push(h);
  }
  var str = parts.join("|");
  var hash = 5381;
  for(var i = 0 ,i_finish = str.length; i < i_finish; ++i){
    var c = str.charCodeAt(i) | 0;
    hash = (Proven_Bitwise.lsl(hash, 5) + hash | 0) + c | 0;
  }
  return String(Proven_Bitwise.land(hash, 2147483647));
}

function createProvenanceChain(dataId, creator, timestamp) {
  var entry_description = "Initial creation";
  var entry = {
    timestamp: timestamp,
    eventType: "Created",
    actor: creator,
    description: entry_description,
    source: undefined,
    previousHash: undefined
  };
  return {
          dataId: dataId,
          classification: "Internal",
          entries: [entry],
          currentHash: computeHash(entry)
        };
}

function getLastTimestamp(chain) {
  if (chain.entries.length === 0) {
    return 0.0;
  } else {
    return chain.entries[chain.entries.length - 1 | 0].timestamp;
  }
}

function getLastEntry(chain) {
  if (chain.entries.length === 0) {
    return ;
  } else {
    return chain.entries[chain.entries.length - 1 | 0];
  }
}

function addEvent(chain, eventType, actor, timestamp, description) {
  if (chain.entries.length >= 1000) {
    return {
            TAG: "Error",
            _0: "MaxEntriesReached"
          };
  }
  if (timestamp < getLastTimestamp(chain)) {
    return {
            TAG: "Error",
            _0: "InvalidTimestamp"
          };
  }
  var entry_previousHash = chain.currentHash;
  var entry = {
    timestamp: timestamp,
    eventType: eventType,
    actor: actor,
    description: description,
    source: undefined,
    previousHash: entry_previousHash
  };
  chain.entries = Belt_Array.concat(chain.entries, [entry]);
  chain.currentHash = computeHash(entry);
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function addEventWithSource(chain, eventType, actor, timestamp, description, source) {
  if (chain.entries.length >= 1000) {
    return {
            TAG: "Error",
            _0: "MaxEntriesReached"
          };
  }
  if (timestamp < getLastTimestamp(chain)) {
    return {
            TAG: "Error",
            _0: "InvalidTimestamp"
          };
  }
  var entry_source = source;
  var entry_previousHash = chain.currentHash;
  var entry = {
    timestamp: timestamp,
    eventType: eventType,
    actor: actor,
    description: description,
    source: entry_source,
    previousHash: entry_previousHash
  };
  chain.entries = Belt_Array.concat(chain.entries, [entry]);
  chain.currentHash = computeHash(entry);
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function verifyIntegrity(chain) {
  if (chain.entries.length === 0) {
    return true;
  }
  var prevHash = {
    contents: undefined
  };
  var valid = {
    contents: true
  };
  Belt_Array.forEach(chain.entries, (function (entry) {
          if (!valid.contents) {
            return ;
          }
          var match = prevHash.contents;
          var match$1 = entry.previousHash;
          if (match !== undefined) {
            if (match$1 !== undefined && match === match$1) {
              
            } else {
              valid.contents = false;
            }
          } else if (match$1 !== undefined) {
            valid.contents = false;
          }
          prevHash.contents = computeHash(entry);
        }));
  if (!valid.contents) {
    return false;
  }
  var match = chain.currentHash;
  var match$1 = prevHash.contents;
  if (match !== undefined && match$1 !== undefined) {
    return match === match$1;
  } else {
    return true;
  }
}

function getEventsByType(chain, eventType) {
  return Belt_Array.keep(chain.entries, (function (entry) {
                return entry.eventType === eventType;
              }));
}

function getActors(chain) {
  var actors = [];
  Belt_Array.forEach(chain.entries, (function (entry) {
          var found = Belt_Array.some(actors, (function (a) {
                  return a === entry.actor;
                }));
          if (!found) {
            actors.push(entry.actor);
            return ;
          }
          
        }));
  return actors;
}

function hasActorAccessed(chain, actor) {
  return Belt_Array.some(chain.entries, (function (entry) {
                return entry.actor === actor;
              }));
}

function getEntryCount(chain) {
  return chain.entries.length;
}

function setClassification(chain, classification) {
  chain.classification = classification;
}

function createLineageNode(dataId, transformation) {
  return {
          dataId: dataId,
          transformation: transformation,
          parentIds: []
        };
}

function addParent(node, parentId) {
  if (node.parentIds.length >= 8) {
    return false;
  } else {
    node.parentIds = Belt_Array.concat(node.parentIds, [parentId]);
    return true;
  }
}

function isDerivedFrom(node, sourceId) {
  return Belt_Array.some(node.parentIds, (function (id) {
                return id === sourceId;
              }));
}

function isRoot(node) {
  return node.parentIds.length === 0;
}

function isComplianceValid(record, currentTime) {
  if (record.status !== "Compliant" && record.status !== "Exempted") {
    return false;
  }
  var exp = record.expiry;
  if (exp !== undefined) {
    return currentTime < exp;
  } else {
    return true;
  }
}

function isTransferAuthorized(transfer) {
  return Belt_Option.isSome(transfer.authorizedBy);
}

function createCustodyTransfer(from, to, timestamp, reason, authorizedBy) {
  return {
          fromCustodian: from,
          toCustodian: to,
          timestamp: timestamp,
          reason: reason,
          authorizedBy: authorizedBy
        };
}

var maxEntries = 1000;

export {
  eventTypeToString ,
  classificationValue ,
  classificationIsAtLeast ,
  classificationMax ,
  databaseSource ,
  fileSource ,
  apiSource ,
  userInputSource ,
  derivedSource ,
  computeHash ,
  maxEntries ,
  createProvenanceChain ,
  getLastTimestamp ,
  getLastEntry ,
  addEvent ,
  addEventWithSource ,
  verifyIntegrity ,
  getEventsByType ,
  getActors ,
  hasActorAccessed ,
  getEntryCount ,
  setClassification ,
  createLineageNode ,
  addParent ,
  isDerivedFrom ,
  isRoot ,
  isComplianceValid ,
  isTransferAuthorized ,
  createCustodyTransfer ,
}
/* No side effect */
