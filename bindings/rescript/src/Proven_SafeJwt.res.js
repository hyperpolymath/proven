// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Float from "rescript/lib/es6/belt_Float.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Proven_ffiJs from "./proven_ffi.js";

function algorithmFromString(algorithmString) {
  switch (algorithmString) {
    case "ES256" :
        return "ES256";
    case "ES384" :
        return "ES384";
    case "ES512" :
        return "ES512";
    case "HS256" :
        return "HS256";
    case "HS384" :
        return "HS384";
    case "HS512" :
        return "HS512";
    case "PS256" :
        return "PS256";
    case "PS384" :
        return "PS384";
    case "PS512" :
        return "PS512";
    case "RS256" :
        return "RS256";
    case "RS384" :
        return "RS384";
    case "RS512" :
        return "RS512";
    case "none" :
        return "None";
    default:
      return {
              TAG: "Unknown",
              _0: algorithmString
            };
  }
}

function algorithmToString(alg) {
  if (typeof alg === "object") {
    return alg._0;
  }
  switch (alg) {
    case "HS256" :
        return "HS256";
    case "HS384" :
        return "HS384";
    case "HS512" :
        return "HS512";
    case "RS256" :
        return "RS256";
    case "RS384" :
        return "RS384";
    case "RS512" :
        return "RS512";
    case "ES256" :
        return "ES256";
    case "ES384" :
        return "ES384";
    case "ES512" :
        return "ES512";
    case "PS256" :
        return "PS256";
    case "PS384" :
        return "PS384";
    case "PS512" :
        return "PS512";
    case "None" :
        return "none";
    
  }
}

function isSymmetricAlgorithm(alg) {
  if (typeof alg === "object") {
    return false;
  }
  switch (alg) {
    case "HS256" :
    case "HS384" :
    case "HS512" :
        return true;
    default:
      return false;
  }
}

function isAsymmetricAlgorithm(alg) {
  if (typeof alg === "object") {
    return false;
  }
  switch (alg) {
    case "HS256" :
    case "HS384" :
    case "HS512" :
    case "None" :
        return false;
    default:
      return true;
  }
}

function isNoneAlgorithm(alg) {
  return alg === "None";
}

function isBase64UrlChar(charCode) {
  if (charCode >= 65.0 && charCode <= 90.0 || charCode >= 97.0 && charCode <= 122.0 || charCode >= 48.0 && charCode <= 57.0 || charCode === 45.0) {
    return true;
  } else {
    return charCode === 95.0;
  }
}

function isValidBase64Url(input) {
  if (input.length === 0) {
    return false;
  }
  var chars = input.split("");
  return chars.every(function ($$char) {
              var code = $$char.charCodeAt(0);
              return isBase64UrlChar(code);
            });
}

function isValidFormat(tokenString) {
  var parts = tokenString.split(".");
  if (parts.length !== 3) {
    return false;
  } else {
    return parts.every(function (part) {
                if (part.length > 0) {
                  return isValidBase64Url(part);
                } else {
                  return false;
                }
              });
  }
}

function base64UrlDecode(prim) {
  return Proven_ffiJs.base64UrlDecode(prim);
}

function decodeBase64Url(input) {
  var base64 = input.replace(/-/g, "+").replace(/_/g, "/");
  var match = base64.length % 4;
  var padded = match !== 2 ? (
      match !== 3 ? base64 : base64 + "="
    ) : base64 + "==";
  try {
    return atob(padded);
  }
  catch (exn){
    return Caml_option.nullable_to_opt(Proven_ffiJs.base64UrlDecode(input));
  }
}

function extractJsonString(json, key) {
  var pattern = "\"" + key + "\"";
  var keyPos = json.indexOf(pattern);
  if (keyPos === -1) {
    return ;
  }
  var afterKey = json.slice(keyPos + pattern.length | 0);
  var colonPos = afterKey.indexOf(":");
  if (colonPos === -1) {
    return ;
  }
  var afterColon = afterKey.slice(colonPos + 1 | 0);
  var trimmed = afterColon.trim();
  if (!trimmed.startsWith("\"")) {
    return ;
  }
  var valueStart = trimmed.slice(1);
  var findEndQuote = function (s, _idx) {
    while(true) {
      var idx = _idx;
      if (idx >= s.length) {
        return ;
      }
      var $$char = s.charAt(idx);
      if ($$char === "\\" && (idx + 1 | 0) < s.length) {
        _idx = idx + 2 | 0;
        continue ;
      }
      if ($$char === "\"") {
        return idx;
      }
      _idx = idx + 1 | 0;
      continue ;
    };
  };
  var endPos = findEndQuote(valueStart, 0);
  if (endPos !== undefined) {
    return valueStart.slice(0, endPos);
  }
  
}

function extractJsonNumber(json, key) {
  var pattern = "\"" + key + "\"";
  var keyPos = json.indexOf(pattern);
  if (keyPos === -1) {
    return ;
  }
  var afterKey = json.slice(keyPos + pattern.length | 0);
  var colonPos = afterKey.indexOf(":");
  if (colonPos === -1) {
    return ;
  }
  var afterColon = afterKey.slice(colonPos + 1 | 0);
  var trimmed = afterColon.trim();
  var extractNumber = function (s, _idx, _acc) {
    while(true) {
      var acc = _acc;
      var idx = _idx;
      if (idx >= s.length) {
        return acc;
      }
      var $$char = s.charAt(idx);
      var code = $$char.charCodeAt(0);
      if (!(code >= 48.0 && code <= 57.0 || idx === 0 && $$char === "-")) {
        return acc;
      }
      _acc = acc + $$char;
      _idx = idx + 1 | 0;
      continue ;
    };
  };
  return Belt_Float.fromString(extractNumber(trimmed, 0, ""));
}

function parseHeader(headerJson) {
  var alg = extractJsonString(headerJson, "alg");
  if (alg === undefined) {
    return ;
  }
  var tokenType = Belt_Option.getWithDefault(extractJsonString(headerJson, "typ"), "JWT");
  var keyId = extractJsonString(headerJson, "kid");
  var contentType = extractJsonString(headerJson, "cty");
  return {
          algorithm: algorithmFromString(alg),
          tokenType: tokenType,
          keyId: keyId,
          contentType: contentType
        };
}

function parseClaims(payloadJson) {
  return {
          issuer: extractJsonString(payloadJson, "iss"),
          subject: extractJsonString(payloadJson, "sub"),
          audience: extractJsonString(payloadJson, "aud"),
          expirationTime: extractJsonNumber(payloadJson, "exp"),
          notBefore: extractJsonNumber(payloadJson, "nbf"),
          issuedAt: extractJsonNumber(payloadJson, "iat"),
          jwtId: extractJsonString(payloadJson, "jti")
        };
}

function parse(tokenString) {
  if (!isValidFormat(tokenString)) {
    return {
            TAG: "Error",
            _0: "InvalidFormat"
          };
  }
  var parts = tokenString.split(".");
  var rawHeader = parts[0];
  var rawPayload = parts[1];
  var rawSignature = parts[2];
  var headerJson = decodeBase64Url(rawHeader);
  if (headerJson === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
  var payloadJson = decodeBase64Url(rawPayload);
  if (payloadJson === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidPayload"
          };
  }
  var header = parseHeader(headerJson);
  if (header !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              rawHeader: rawHeader,
              rawPayload: rawPayload,
              rawSignature: rawSignature,
              headerJson: headerJson,
              payloadJson: payloadJson,
              header: header,
              claims: parseClaims(payloadJson)
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidHeader"
          };
  }
}

function isExpired(claims, currentTimestamp) {
  var exp = claims.expirationTime;
  if (exp !== undefined) {
    return currentTimestamp > exp;
  } else {
    return false;
  }
}

function isValidYet(claims, currentTimestamp) {
  var nbf = claims.notBefore;
  if (nbf !== undefined) {
    return currentTimestamp >= nbf;
  } else {
    return true;
  }
}

function isCurrentlyValid(claims, currentTimestamp) {
  if (isExpired(claims, currentTimestamp)) {
    return false;
  } else {
    return isValidYet(claims, currentTimestamp);
  }
}

function validateTiming(token, currentTimestamp, leewaySeconds) {
  var exp = token.claims.expirationTime;
  if (exp !== undefined && currentTimestamp > exp + leewaySeconds) {
    return {
            TAG: "Error",
            _0: "TokenExpired"
          };
  }
  var nbf = token.claims.notBefore;
  if (nbf !== undefined && currentTimestamp < nbf - leewaySeconds) {
    return {
            TAG: "Error",
            _0: "TokenNotYetValid"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function getSigningInput(token) {
  return token.rawHeader + "." + token.rawPayload;
}

function isStandardJwt(header) {
  return header.tokenType === "JWT";
}

function getRemainingTime(claims, currentTimestamp) {
  var exp = claims.expirationTime;
  if (exp !== undefined) {
    return exp - currentTimestamp;
  }
  
}

function hasIssuer(claims, expectedIssuer) {
  return Caml_obj.equal(claims.issuer, expectedIssuer);
}

function hasAudience(claims, expectedAudience) {
  return Caml_obj.equal(claims.audience, expectedAudience);
}

function hasSubject(claims, expectedSubject) {
  return Caml_obj.equal(claims.subject, expectedSubject);
}

function hasRequiredClaims(claims, issuerOpt, subjectOpt, audienceOpt, expirationOpt) {
  var issuer = issuerOpt !== undefined ? issuerOpt : false;
  var subject = subjectOpt !== undefined ? subjectOpt : false;
  var audience = audienceOpt !== undefined ? audienceOpt : false;
  var expiration = expirationOpt !== undefined ? expirationOpt : false;
  var issuerOk = !issuer || Belt_Option.isSome(claims.issuer);
  var subjectOk = !subject || Belt_Option.isSome(claims.subject);
  var audienceOk = !audience || Belt_Option.isSome(claims.audience);
  var expirationOk = !expiration || Belt_Option.isSome(claims.expirationTime);
  if (issuerOk && subjectOk && audienceOk) {
    return expirationOk;
  } else {
    return false;
  }
}

export {
  algorithmFromString ,
  algorithmToString ,
  isSymmetricAlgorithm ,
  isAsymmetricAlgorithm ,
  isNoneAlgorithm ,
  isBase64UrlChar ,
  isValidBase64Url ,
  isValidFormat ,
  base64UrlDecode ,
  decodeBase64Url ,
  extractJsonString ,
  extractJsonNumber ,
  parseHeader ,
  parseClaims ,
  parse ,
  isExpired ,
  isValidYet ,
  isCurrentlyValid ,
  validateTiming ,
  getSigningInput ,
  isStandardJwt ,
  getRemainingTime ,
  hasIssuer ,
  hasAudience ,
  hasSubject ,
  hasRequiredClaims ,
}
/* ./proven_ffi.js Not a pure module */
