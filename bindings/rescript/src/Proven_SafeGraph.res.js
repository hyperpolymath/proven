// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function errorToString(error) {
  switch (error) {
    case "VertexNotFound" :
        return "Vertex not found";
    case "EdgeExists" :
        return "Edge already exists";
    case "MaxVerticesReached" :
        return "Maximum vertices reached";
    case "MaxEdgesReached" :
        return "Maximum edges reached";
    case "CycleDetected" :
        return "Cycle detected in graph";
    case "InvalidCapacity" :
        return "Invalid capacity specified";
    
  }
}

function make(maxVertices, maxEdges) {
  if (maxVertices <= 0 || maxEdges <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidCapacity"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              vertices: Belt_Array.make(maxVertices, undefined),
              edges: Belt_Array.make(maxEdges, undefined),
              vertexCount: 0,
              edgeCount: 0,
              maxVertices: maxVertices,
              maxEdges: maxEdges
            }
          };
  }
}

function vertexCount(graph) {
  return graph.vertexCount;
}

function edgeCount(graph) {
  return graph.edgeCount;
}

function isEmpty(graph) {
  return graph.vertexCount === 0;
}

function addVertex(graph, value) {
  if (graph.vertexCount >= graph.maxVertices) {
    return {
            TAG: "Error",
            _0: "MaxVerticesReached"
          };
  }
  var index = graph.vertexCount;
  graph.vertices[index] = Caml_option.some(value);
  graph.vertexCount = graph.vertexCount + 1 | 0;
  return {
          TAG: "Ok",
          _0: index
        };
}

function getVertex(graph, index) {
  if (index < 0 || index >= graph.vertexCount) {
    return ;
  } else {
    return graph.vertices[index];
  }
}

function findVertex(graph, value) {
  var found;
  var i = 0;
  while(Belt_Option.isNone(found) && i < graph.vertexCount) {
    var v = graph.vertices[i];
    if (v !== undefined && Caml_obj.equal(Caml_option.valFromOption(v), value)) {
      found = i;
    }
    i = i + 1 | 0;
  };
  return found;
}

function hasVertex(graph, index) {
  if (index >= 0) {
    return index < graph.vertexCount;
  } else {
    return false;
  }
}

function addEdge(graph, source, target, weight) {
  if (source < 0 || source >= graph.vertexCount || target < 0 || target >= graph.vertexCount) {
    return {
            TAG: "Error",
            _0: "VertexNotFound"
          };
  } else if (graph.edgeCount >= graph.maxEdges) {
    return {
            TAG: "Error",
            _0: "MaxEdgesReached"
          };
  } else {
    graph.edges[graph.edgeCount] = {
      source: source,
      target: target,
      weight: weight
    };
    graph.edgeCount = graph.edgeCount + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function addEdgeUnweighted(graph, source, target) {
  return addEdge(graph, source, target, 1.0);
}

function hasEdge(graph, source, target) {
  var found = false;
  var i = 0;
  while(!found && i < graph.edgeCount) {
    var edge = graph.edges[i];
    if (edge !== undefined && edge.source === source && edge.target === target) {
      found = true;
    }
    i = i + 1 | 0;
  };
  return found;
}

function getEdgeWeight(graph, source, target) {
  var found;
  var i = 0;
  while(Belt_Option.isNone(found) && i < graph.edgeCount) {
    var edge = graph.edges[i];
    if (edge !== undefined && edge.source === source && edge.target === target) {
      found = edge.weight;
    }
    i = i + 1 | 0;
  };
  return found;
}

function removeEdge(graph, source, target) {
  var removed = false;
  var i = 0;
  while(!removed && i < graph.edgeCount) {
    var edge = graph.edges[i];
    if (edge !== undefined && edge.source === source && edge.target === target) {
      for(var j = i ,j_finish = graph.edgeCount - 2 | 0; j <= j_finish; ++j){
        graph.edges[j] = graph.edges[j + 1 | 0];
      }
      graph.edges[graph.edgeCount - 1 | 0] = undefined;
      graph.edgeCount = graph.edgeCount - 1 | 0;
      removed = true;
    }
    i = i + 1 | 0;
  };
  return removed;
}

function getNeighbors(graph, vertex) {
  var result = [];
  for(var i = 0 ,i_finish = graph.edgeCount; i < i_finish; ++i){
    var edge = graph.edges[i];
    if (edge !== undefined && edge.source === vertex) {
      result.push(edge.target);
    }
    
  }
  return result;
}

function getPredecessors(graph, vertex) {
  var result = [];
  for(var i = 0 ,i_finish = graph.edgeCount; i < i_finish; ++i){
    var edge = graph.edges[i];
    if (edge !== undefined && edge.target === vertex) {
      result.push(edge.source);
    }
    
  }
  return result;
}

function outDegree(graph, vertex) {
  var count = 0;
  for(var i = 0 ,i_finish = graph.edgeCount; i < i_finish; ++i){
    var edge = graph.edges[i];
    if (edge !== undefined && edge.source === vertex) {
      count = count + 1 | 0;
    }
    
  }
  return count;
}

function inDegree(graph, vertex) {
  var count = 0;
  for(var i = 0 ,i_finish = graph.edgeCount; i < i_finish; ++i){
    var edge = graph.edges[i];
    if (edge !== undefined && edge.target === vertex) {
      count = count + 1 | 0;
    }
    
  }
  return count;
}

function degree(graph, vertex) {
  return inDegree(graph, vertex) + outDegree(graph, vertex) | 0;
}

function hasCycleFromVertex(graph, vertex, visited, stack) {
  if (stack[vertex]) {
    return true;
  }
  if (visited[vertex]) {
    return false;
  }
  visited[vertex] = true;
  stack[vertex] = true;
  var neighbors = getNeighbors(graph, vertex);
  var hasCycle = false;
  var i = 0;
  while(!hasCycle && i < neighbors.length) {
    var neighbor = neighbors[i];
    if (hasCycleFromVertex(graph, neighbor, visited, stack)) {
      hasCycle = true;
    }
    i = i + 1 | 0;
  };
  stack[vertex] = false;
  return hasCycle;
}

function hasCycle(graph) {
  var visited = Belt_Array.make(graph.maxVertices, false);
  var stack = Belt_Array.make(graph.maxVertices, false);
  var hasCycleResult = false;
  var i = 0;
  while(!hasCycleResult && i < graph.vertexCount) {
    if (!visited[i] && hasCycleFromVertex(graph, i, visited, stack)) {
      hasCycleResult = true;
    }
    i = i + 1 | 0;
  };
  return hasCycleResult;
}

function dfs(graph, start) {
  if (start < 0 || start >= graph.vertexCount) {
    return {
            TAG: "Error",
            _0: "VertexNotFound"
          };
  }
  var visited = Belt_Array.make(graph.maxVertices, false);
  var result = [];
  var dfsHelper = function (vertex) {
    if (visited[vertex]) {
      return ;
    }
    visited[vertex] = true;
    result.push(vertex);
    var neighbors = getNeighbors(graph, vertex);
    Belt_Array.forEach(neighbors, (function (neighbor) {
            dfsHelper(neighbor);
          }));
  };
  dfsHelper(start);
  return {
          TAG: "Ok",
          _0: result
        };
}

function bfs(graph, start) {
  if (start < 0 || start >= graph.vertexCount) {
    return {
            TAG: "Error",
            _0: "VertexNotFound"
          };
  }
  var visited = Belt_Array.make(graph.maxVertices, false);
  var result = [];
  var queue = [start];
  visited[start] = true;
  while(queue.length !== 0) {
    var current = queue.shift();
    if (current !== undefined) {
      result.push(current);
      var neighbors = getNeighbors(graph, current);
      Belt_Array.forEach(neighbors, (function (neighbor) {
              if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue.push(neighbor);
                return ;
              }
              
            }));
    }
    
  };
  return {
          TAG: "Ok",
          _0: result
        };
}

function topologicalSort(graph) {
  if (hasCycle(graph)) {
    return {
            TAG: "Error",
            _0: "CycleDetected"
          };
  }
  var visited = Belt_Array.make(graph.maxVertices, false);
  var result = [];
  var visit = function (vertex) {
    if (visited[vertex]) {
      return ;
    }
    visited[vertex] = true;
    var neighbors = getNeighbors(graph, vertex);
    Belt_Array.forEach(neighbors, (function (neighbor) {
            visit(neighbor);
          }));
    result.unshift(vertex);
  };
  for(var i = 0 ,i_finish = graph.vertexCount; i < i_finish; ++i){
    if (!visited[i]) {
      visit(i);
    }
    
  }
  return {
          TAG: "Ok",
          _0: result
        };
}

function hasPath(graph, source, target) {
  if (source < 0 || source >= graph.vertexCount || target < 0 || target >= graph.vertexCount) {
    return {
            TAG: "Error",
            _0: "VertexNotFound"
          };
  }
  if (source === target) {
    return {
            TAG: "Ok",
            _0: true
          };
  }
  var e = bfs(graph, source);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: e._0.includes(target)
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function getAllEdges(graph) {
  var result = [];
  for(var i = 0 ,i_finish = graph.edgeCount; i < i_finish; ++i){
    var edge = graph.edges[i];
    if (edge !== undefined) {
      result.push(edge);
    }
    
  }
  return result;
}

function getAllVertices(graph) {
  var result = [];
  for(var i = 0 ,i_finish = graph.vertexCount; i < i_finish; ++i){
    var v = graph.vertices[i];
    if (v !== undefined) {
      result.push(Caml_option.valFromOption(v));
    }
    
  }
  return result;
}

function clear(graph) {
  for(var i = 0 ,i_finish = graph.maxVertices; i < i_finish; ++i){
    graph.vertices[i] = undefined;
  }
  for(var i$1 = 0 ,i_finish$1 = graph.maxEdges; i$1 < i_finish$1; ++i$1){
    graph.edges[i$1] = undefined;
  }
  graph.vertexCount = 0;
  graph.edgeCount = 0;
}

export {
  errorToString ,
  make ,
  vertexCount ,
  edgeCount ,
  isEmpty ,
  addVertex ,
  getVertex ,
  findVertex ,
  hasVertex ,
  addEdge ,
  addEdgeUnweighted ,
  hasEdge ,
  getEdgeWeight ,
  removeEdge ,
  getNeighbors ,
  getPredecessors ,
  outDegree ,
  inDegree ,
  degree ,
  hasCycleFromVertex ,
  hasCycle ,
  dfs ,
  bfs ,
  topologicalSort ,
  hasPath ,
  getAllEdges ,
  getAllVertices ,
  clear ,
}
/* No side effect */
