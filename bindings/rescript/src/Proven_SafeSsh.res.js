// Generated by ReScript, PLEASE EDIT WITH CARE


function keyTypeToAlgorithm(keyType) {
  switch (keyType) {
    case "Rsa" :
        return "ssh-rsa";
    case "Dsa" :
        return "ssh-dss";
    case "Ecdsa256" :
        return "ecdsa-sha2-nistp256";
    case "Ecdsa384" :
        return "ecdsa-sha2-nistp384";
    case "Ecdsa521" :
        return "ecdsa-sha2-nistp521";
    case "Ed25519" :
        return "ssh-ed25519";
    case "Ed25519Sk" :
        return "sk-ssh-ed25519@openssh.com";
    case "EcdsaSk" :
        return "sk-ecdsa-sha2-nistp256@openssh.com";
    
  }
}

function minKeyBits(keyType) {
  switch (keyType) {
    case "Rsa" :
        return 2048;
    case "Dsa" :
        return 1024;
    case "Ecdsa384" :
        return 384;
    case "Ecdsa521" :
        return 521;
    default:
      return 256;
  }
}

function isKeyTypeSecure(keyType) {
  if (keyType === "Dsa") {
    return false;
  } else {
    return true;
  }
}

function isRecommendedKeyType(keyType) {
  switch (keyType) {
    case "Dsa" :
        return false;
    default:
      return true;
  }
}

function parseKeyType(algorithm) {
  switch (algorithm) {
    case "ecdsa-sha2-nistp256" :
        return {
                TAG: "Ok",
                _0: "Ecdsa256"
              };
    case "ecdsa-sha2-nistp384" :
        return {
                TAG: "Ok",
                _0: "Ecdsa384"
              };
    case "ecdsa-sha2-nistp521" :
        return {
                TAG: "Ok",
                _0: "Ecdsa521"
              };
    case "sk-ecdsa-sha2-nistp256@openssh.com" :
        return {
                TAG: "Ok",
                _0: "EcdsaSk"
              };
    case "sk-ssh-ed25519@openssh.com" :
        return {
                TAG: "Ok",
                _0: "Ed25519Sk"
              };
    case "ssh-dss" :
        return {
                TAG: "Ok",
                _0: "Dsa"
              };
    case "ssh-ed25519" :
        return {
                TAG: "Ok",
                _0: "Ed25519"
              };
    case "ssh-rsa" :
        return {
                TAG: "Ok",
                _0: "Rsa"
              };
    default:
      return {
              TAG: "Error",
              _0: "UnsupportedAlgorithm"
            };
  }
}

var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

function isValidBase64(data) {
  var length = data.length;
  if (length === 0) {
    return false;
  }
  var valid = true;
  for(var i = 0; i < length; ++i){
    if (valid) {
      var $$char = data.charAt(i);
      if (!base64Chars.includes($$char)) {
        valid = false;
      }
      
    }
    
  }
  return valid;
}

function parsePublicKey(keyString) {
  var length = keyString.length;
  if (length < 16) {
    return {
            TAG: "Error",
            _0: "KeyTooShort"
          };
  }
  if (length > 16384) {
    return {
            TAG: "Error",
            _0: "KeyTooLong"
          };
  }
  var parts = keyString.split(" ");
  var numParts = parts.length;
  if (numParts < 2) {
    return {
            TAG: "Error",
            _0: "InvalidKeyFormat"
          };
  }
  var algorithm = parts[0];
  var keyData = parts[1];
  var e = parseKeyType(algorithm);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  if (!isValidBase64(keyData)) {
    return {
            TAG: "Error",
            _0: "InvalidBase64"
          };
  }
  var comment = numParts >= 3 ? parts[2] : undefined;
  return {
          TAG: "Ok",
          _0: {
            keyType: e._0,
            keyData: keyData,
            comment: comment
          }
        };
}

function isValidPublicKey(keyString) {
  var match = parsePublicKey(keyString);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function isPublicKeySecure(key) {
  return isKeyTypeSecure(key.keyType);
}

function fingerprintPrefix(algorithm) {
  if (algorithm === "Md5") {
    return "MD5:";
  } else {
    return "SHA256:";
  }
}

function isValidMd5Fingerprint(fingerprint) {
  var length = fingerprint.length;
  if (length !== 47) {
    return false;
  }
  var valid = true;
  for(var i = 0; i < length; ++i){
    if (valid) {
      var $$char = fingerprint.charAt(i);
      if (i % 3 === 2) {
        if ($$char !== ":") {
          valid = false;
        }
        
      } else {
        var code = $$char.charCodeAt(0) | 0;
        var isHex = code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
        if (!isHex) {
          valid = false;
        }
        
      }
    }
    
  }
  return valid;
}

function parseFingerprint(fingerprintStr) {
  var length = fingerprintStr.length;
  if (length < 8) {
    return {
            TAG: "Error",
            _0: "InvalidFingerprint"
          };
  }
  if (fingerprintStr.startsWith("SHA256:")) {
    var hash = fingerprintStr.slice(7);
    if (isValidBase64(hash)) {
      return {
              TAG: "Ok",
              _0: {
                algorithm: "Sha256",
                hash: hash,
                keyType: undefined
              }
            };
    } else {
      return {
              TAG: "Error",
              _0: "InvalidFingerprint"
            };
    }
  }
  if (!fingerprintStr.startsWith("MD5:")) {
    if (isValidMd5Fingerprint(fingerprintStr)) {
      return {
              TAG: "Ok",
              _0: {
                algorithm: "Md5",
                hash: fingerprintStr,
                keyType: undefined
              }
            };
    } else {
      return {
              TAG: "Error",
              _0: "InvalidFingerprint"
            };
    }
  }
  var hash$1 = fingerprintStr.slice(4);
  if (isValidMd5Fingerprint(hash$1)) {
    return {
            TAG: "Ok",
            _0: {
              algorithm: "Md5",
              hash: hash$1,
              keyType: undefined
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidFingerprint"
          };
  }
}

function isValidFingerprint(fingerprintStr) {
  var match = parseFingerprint(fingerprintStr);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function formatFingerprint(fp) {
  return fingerprintPrefix(fp.algorithm) + fp.hash;
}

function parseKnownHostsEntry(entry) {
  var length = entry.length;
  if (length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidKnownHostsEntry"
          };
  }
  if (entry.charAt(0) === "#") {
    return {
            TAG: "Error",
            _0: "InvalidKnownHostsEntry"
          };
  }
  var parts = entry.split(" ");
  var numParts = parts.length;
  if (numParts < 3) {
    return {
            TAG: "Error",
            _0: "InvalidKnownHostsEntry"
          };
  }
  var hostnames = parts[0];
  var algorithm = parts[1];
  var keyData = parts[2];
  var isHashed = hostnames.startsWith("|1|");
  var e = parseKeyType(algorithm);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  if (!isValidBase64(keyData)) {
    return {
            TAG: "Error",
            _0: "InvalidBase64"
          };
  }
  var comment = numParts >= 4 ? parts[3] : undefined;
  return {
          TAG: "Ok",
          _0: {
            hostnames: hostnames,
            keyType: e._0,
            keyData: keyData,
            comment: comment,
            isHashed: isHashed
          }
        };
}

function isValidKnownHostsEntry(entry) {
  var match = parseKnownHostsEntry(entry);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function isValidSshHostname(hostname) {
  var length = hostname.length;
  if (length === 0 || length > 253) {
    return false;
  }
  var firstChar = hostname.charAt(0);
  var lastChar = hostname.charAt(length - 1 | 0);
  if (firstChar === "-" || lastChar === "-") {
    return false;
  }
  var valid = true;
  for(var i = 0; i < length; ++i){
    if (valid) {
      var $$char = hostname.charAt(i);
      var code = $$char.charCodeAt(0) | 0;
      var isAlnum = code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
      if (!isAlnum && $$char !== "." && $$char !== "-" && $$char !== "_") {
        valid = false;
      }
      
    }
    
  }
  return valid;
}

function isValidSshPort(port) {
  if (port > 0) {
    return port <= 65535;
  } else {
    return false;
  }
}

function formatHostPort(hostname, port) {
  if (!isValidSshHostname(hostname) || !isValidSshPort(port)) {
    return {
            TAG: "Error",
            _0: "InvalidKeyFormat"
          };
  } else if (port === 22) {
    return {
            TAG: "Ok",
            _0: hostname
          };
  } else if (hostname.includes(":")) {
    return {
            TAG: "Ok",
            _0: "[" + hostname + "]:" + String(port)
          };
  } else {
    return {
            TAG: "Ok",
            _0: hostname + ":" + String(port)
          };
  }
}

function sanitizeComment(comment) {
  var length = comment.length;
  var result = "";
  for(var i = 0; i < length; ++i){
    var $$char = comment.charAt(i);
    var code = $$char.charCodeAt(0) | 0;
    var isAlnum = code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
    if (isAlnum || $$char === " " || $$char === "@" || $$char === "." || $$char === "-" || $$char === "_") {
      result = result + $$char;
    }
    
  }
  return result;
}

function keyTypeToString(keyType) {
  switch (keyType) {
    case "Rsa" :
        return "RSA";
    case "Dsa" :
        return "DSA";
    case "Ecdsa256" :
        return "ECDSA-256";
    case "Ecdsa384" :
        return "ECDSA-384";
    case "Ecdsa521" :
        return "ECDSA-521";
    case "Ed25519" :
        return "Ed25519";
    case "Ed25519Sk" :
        return "Ed25519-SK";
    case "EcdsaSk" :
        return "ECDSA-SK";
    
  }
}

function sshErrorToString(error) {
  switch (error) {
    case "InvalidKeyFormat" :
        return "Invalid key format";
    case "InvalidKeyType" :
        return "Invalid key type";
    case "InvalidBase64" :
        return "Invalid base64 encoding";
    case "InvalidFingerprint" :
        return "Invalid fingerprint format";
    case "InvalidKnownHostsEntry" :
        return "Invalid known_hosts entry";
    case "KeyTooShort" :
        return "Key is too short";
    case "KeyTooLong" :
        return "Key is too long";
    case "UnsupportedAlgorithm" :
        return "Unsupported algorithm";
    
  }
}

export {
  keyTypeToAlgorithm ,
  minKeyBits ,
  isKeyTypeSecure ,
  isRecommendedKeyType ,
  parseKeyType ,
  base64Chars ,
  isValidBase64 ,
  parsePublicKey ,
  isValidPublicKey ,
  isPublicKeySecure ,
  fingerprintPrefix ,
  isValidMd5Fingerprint ,
  parseFingerprint ,
  isValidFingerprint ,
  formatFingerprint ,
  parseKnownHostsEntry ,
  isValidKnownHostsEntry ,
  isValidSshHostname ,
  isValidSshPort ,
  formatHostPort ,
  sanitizeComment ,
  keyTypeToString ,
  sshErrorToString ,
}
/* No side effect */
