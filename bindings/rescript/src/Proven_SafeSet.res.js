// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function make(capacity) {
  return {
          data: [],
          length: 0,
          capacity: capacity
        };
}

function count(set) {
  return set.length;
}

function isEmpty(set) {
  return set.length === 0;
}

function isFull(set) {
  return set.length >= set.capacity;
}

function remaining(set) {
  return set.capacity - set.length | 0;
}

function contains(set, value) {
  return Belt_Array.some(Belt_Array.slice(set.data, 0, set.length), (function (elem) {
                return Caml_obj.equal(elem, value);
              }));
}

function insert(set, value) {
  if (contains(set, value)) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else if (isFull(set)) {
    return {
            TAG: "Error",
            _0: "SetFull"
          };
  } else {
    set.data = Belt_Array.concat(set.data, [value]);
    set.length = set.length + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function insertResult(set, value) {
  if (contains(set, value)) {
    return "AlreadyPresent";
  } else if (isFull(set)) {
    return "SetFullResult";
  } else {
    set.data = Belt_Array.concat(set.data, [value]);
    set.length = set.length + 1 | 0;
    return "Inserted";
  }
}

function remove(set, value) {
  var idx = -1;
  for(var i = 0 ,i_finish = set.length; i < i_finish; ++i){
    if (idx === -1) {
      var elem = Belt_Array.get(set.data, i);
      if (elem !== undefined && Caml_obj.equal(Caml_option.valFromOption(elem), value)) {
        idx = i;
      }
      
    }
    
  }
  if (idx === -1) {
    return {
            TAG: "Error",
            _0: "ElementNotFound"
          };
  }
  var lastIdx = set.length - 1 | 0;
  if (idx < lastIdx) {
    var lastElem = Belt_Array.get(set.data, lastIdx);
    if (lastElem !== undefined) {
      set.data[idx] = Caml_option.valFromOption(lastElem);
    }
    
  }
  set.length = set.length - 1 | 0;
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function discard(set, value) {
  var match = remove(set, value);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function clear(set) {
  set.length = 0;
  set.data = [];
}

function items(set) {
  return Belt_Array.slice(set.data, 0, set.length);
}

function unionWith(set, other) {
  var otherItems = items(other);
  var added = {
    contents: 0
  };
  Belt_Array.forEach(otherItems, (function (elem) {
          if (insertResult(set, elem) === "Inserted") {
            added.contents = added.contents + 1 | 0;
            return ;
          }
          
        }));
  return added.contents;
}

function intersectWith(set, other) {
  var removed = 0;
  var i = 0;
  while(i < set.length) {
    var elem = Belt_Array.get(set.data, i);
    if (elem !== undefined) {
      var elem$1 = Caml_option.valFromOption(elem);
      if (contains(other, elem$1)) {
        i = i + 1 | 0;
      } else {
        discard(set, elem$1);
        removed = removed + 1 | 0;
      }
    } else {
      i = i + 1 | 0;
    }
  };
  return removed;
}

function differenceWith(set, other) {
  var removed = 0;
  var i = 0;
  while(i < set.length) {
    var elem = Belt_Array.get(set.data, i);
    if (elem !== undefined) {
      var elem$1 = Caml_option.valFromOption(elem);
      if (contains(other, elem$1)) {
        discard(set, elem$1);
        removed = removed + 1 | 0;
      } else {
        i = i + 1 | 0;
      }
    } else {
      i = i + 1 | 0;
    }
  };
  return removed;
}

function isSubsetOf(set, other) {
  return Belt_Array.every(items(set), (function (elem) {
                return contains(other, elem);
              }));
}

function isProperSubsetOf(set, other) {
  if (set.length < other.length) {
    return isSubsetOf(set, other);
  } else {
    return false;
  }
}

function isSupersetOf(set, other) {
  return isSubsetOf(other, set);
}

function isDisjointWith(set, other) {
  return !Belt_Array.some(items(set), (function (elem) {
                return contains(other, elem);
              }));
}

function equals(set, other) {
  if (set.length === other.length) {
    return isSubsetOf(set, other);
  } else {
    return false;
  }
}

function pop(set) {
  if (set.length === 0) {
    return ;
  } else {
    set.length = set.length - 1 | 0;
    return Belt_Array.get(set.data, set.length);
  }
}

function union(a, b) {
  var newSet = {
    data: [],
    length: 0,
    capacity: a.capacity + b.capacity | 0
  };
  Belt_Array.forEach(items(a), (function (elem) {
          insert(newSet, elem);
        }));
  Belt_Array.forEach(items(b), (function (elem) {
          insert(newSet, elem);
        }));
  return newSet;
}

function intersection(a, b) {
  var capacity = Math.min(a.capacity, b.capacity);
  var newSet = {
    data: [],
    length: 0,
    capacity: capacity
  };
  Belt_Array.forEach(items(a), (function (elem) {
          if (contains(b, elem)) {
            insert(newSet, elem);
            return ;
          }
          
        }));
  return newSet;
}

function difference(a, b) {
  var newSet = {
    data: [],
    length: 0,
    capacity: a.capacity
  };
  Belt_Array.forEach(items(a), (function (elem) {
          if (!contains(b, elem)) {
            insert(newSet, elem);
            return ;
          }
          
        }));
  return newSet;
}

function symmetricDifference(a, b) {
  var newSet = {
    data: [],
    length: 0,
    capacity: a.capacity + b.capacity | 0
  };
  Belt_Array.forEach(items(a), (function (elem) {
          if (!contains(b, elem)) {
            insert(newSet, elem);
            return ;
          }
          
        }));
  Belt_Array.forEach(items(b), (function (elem) {
          if (!contains(a, elem)) {
            insert(newSet, elem);
            return ;
          }
          
        }));
  return newSet;
}

function map(set, f) {
  var newSet = {
    data: [],
    length: 0,
    capacity: set.capacity
  };
  Belt_Array.forEach(items(set), (function (elem) {
          insert(newSet, f(elem));
        }));
  return newSet;
}

function filter(set, predicate) {
  var newSet = {
    data: [],
    length: 0,
    capacity: set.capacity
  };
  Belt_Array.forEach(items(set), (function (elem) {
          if (predicate(elem)) {
            insert(newSet, elem);
            return ;
          }
          
        }));
  return newSet;
}

function fold(set, init, f) {
  return Belt_Array.reduce(items(set), init, f);
}

function exists(set, predicate) {
  return Belt_Array.some(items(set), predicate);
}

function forAll(set, predicate) {
  return Belt_Array.every(items(set), predicate);
}

function find(set, predicate) {
  return Belt_Array.getBy(items(set), predicate);
}

function make$1(capacity) {
  return {
          data: [],
          length: 0,
          capacity: capacity
        };
}

function count$1(set) {
  return set.length;
}

function isEmpty$1(set) {
  return set.length === 0;
}

function isFull$1(set) {
  return set.length >= set.capacity;
}

function contains$1(set, value) {
  return Belt_Array.some(Belt_Array.slice(set.data, 0, set.length), (function (elem) {
                return Caml_obj.equal(elem, value);
              }));
}

function get(set, index) {
  if (index < 0 || index >= set.length) {
    return ;
  } else {
    return Belt_Array.get(set.data, index);
  }
}

function indexOf(set, value) {
  var idx;
  for(var i = 0 ,i_finish = set.length; i < i_finish; ++i){
    if (idx === undefined) {
      var elem = Belt_Array.get(set.data, i);
      if (elem !== undefined && Caml_obj.equal(Caml_option.valFromOption(elem), value)) {
        idx = i;
      }
      
    }
    
  }
  return idx;
}

function insert$1(set, value) {
  if (contains$1(set, value)) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else if (isFull$1(set)) {
    return {
            TAG: "Error",
            _0: "SetFull"
          };
  } else {
    set.data = Belt_Array.concat(set.data, [value]);
    set.length = set.length + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function remove$1(set, value) {
  var idx = indexOf(set, value);
  if (idx === undefined) {
    return {
            TAG: "Error",
            _0: "ElementNotFound"
          };
  }
  var newData = Belt_Array.keepWithIndex(set.data, (function (param, i) {
          return i !== idx;
        }));
  set.data = newData;
  set.length = set.length - 1 | 0;
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function first(set) {
  return get(set, 0);
}

function last(set) {
  if (set.length === 0) {
    return ;
  } else {
    return get(set, set.length - 1 | 0);
  }
}

function clear$1(set) {
  set.length = 0;
  set.data = [];
}

function items$1(set) {
  return Belt_Array.slice(set.data, 0, set.length);
}

var Ordered = {
  make: make$1,
  count: count$1,
  isEmpty: isEmpty$1,
  isFull: isFull$1,
  contains: contains$1,
  get: get,
  indexOf: indexOf,
  insert: insert$1,
  remove: remove$1,
  first: first,
  last: last,
  clear: clear$1,
  items: items$1
};

function make$2(capacity) {
  return {
          data: [],
          length: 0,
          capacity: capacity
        };
}

function count$2(set) {
  return set.length;
}

function isEmpty$2(set) {
  return set.length === 0;
}

function isFull$2(set) {
  return set.length >= set.capacity;
}

function findPosition(set, value) {
  if (set.length === 0) {
    return [
            false,
            0
          ];
  }
  var left = 0;
  var right = set.length;
  var found = false;
  var result = 0;
  while(left < right && !found) {
    var mid = left + ((right - left | 0) / 2 | 0) | 0;
    var elem = Belt_Array.get(set.data, mid);
    if (elem !== undefined) {
      var elem$1 = Caml_option.valFromOption(elem);
      if (Caml_obj.equal(elem$1, value)) {
        found = true;
        result = mid;
      } else if (Caml_obj.lessthan(elem$1, value)) {
        left = mid + 1 | 0;
      } else {
        right = mid;
      }
    } else {
      right = mid;
    }
  };
  if (found) {
    return [
            true,
            result
          ];
  } else {
    return [
            false,
            left
          ];
  }
}

function contains$2(set, value) {
  return findPosition(set, value)[0];
}

function insert$2(set, value) {
  var match = findPosition(set, value);
  if (match[0]) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  var pos = match[1];
  if (isFull$2(set)) {
    return {
            TAG: "Error",
            _0: "SetFull"
          };
  }
  var before = Belt_Array.slice(set.data, 0, pos);
  var after = Belt_Array.slice(set.data, pos, set.length - pos | 0);
  set.data = Belt_Array.concatMany([
        before,
        [value],
        after
      ]);
  set.length = set.length + 1 | 0;
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function remove$2(set, value) {
  var match = findPosition(set, value);
  if (!match[0]) {
    return {
            TAG: "Error",
            _0: "ElementNotFound"
          };
  }
  var pos = match[1];
  var before = Belt_Array.slice(set.data, 0, pos);
  var after = Belt_Array.slice(set.data, pos + 1 | 0, (set.length - pos | 0) - 1 | 0);
  set.data = Belt_Array.concat(before, after);
  set.length = set.length - 1 | 0;
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function get$1(set, index) {
  if (index < 0 || index >= set.length) {
    return ;
  } else {
    return Belt_Array.get(set.data, index);
  }
}

function min(set) {
  return get$1(set, 0);
}

function max(set) {
  if (set.length === 0) {
    return ;
  } else {
    return get$1(set, set.length - 1 | 0);
  }
}

function items$2(set) {
  return Belt_Array.slice(set.data, 0, set.length);
}

function range(set, low, high) {
  return Belt_Array.keep(items$2(set), (function (elem) {
                if (Caml_obj.greaterequal(elem, low)) {
                  return Caml_obj.lessequal(elem, high);
                } else {
                  return false;
                }
              }));
}

function clear$2(set) {
  set.length = 0;
  set.data = [];
}

var Sorted = {
  make: make$2,
  count: count$2,
  isEmpty: isEmpty$2,
  isFull: isFull$2,
  findPosition: findPosition,
  contains: contains$2,
  insert: insert$2,
  remove: remove$2,
  get: get$1,
  min: min,
  max: max,
  items: items$2,
  range: range,
  clear: clear$2
};

function make$3(capacity) {
  return {
          data: [],
          length: 0,
          capacity: capacity
        };
}

function count$3(set) {
  return set.length;
}

function isEmpty$3(set) {
  return set.length === 0;
}

function isFull$3(set) {
  return set.length >= set.capacity;
}

function contains$3(set, value) {
  return Belt_Array.some(Belt_Array.slice(set.data, 0, set.length), (function (elem) {
                return elem === value;
              }));
}

function insert$3(set, value) {
  if (contains$3(set, value)) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else if (isFull$3(set)) {
    return {
            TAG: "Error",
            _0: "SetFull"
          };
  } else {
    set.data = Belt_Array.concat(set.data, [value]);
    set.length = set.length + 1 | 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function remove$3(set, value) {
  var idx = -1;
  for(var i = 0 ,i_finish = set.length; i < i_finish; ++i){
    if (idx === -1) {
      var elem = Belt_Array.get(set.data, i);
      if (elem !== undefined && elem === value) {
        idx = i;
      }
      
    }
    
  }
  if (idx === -1) {
    return {
            TAG: "Error",
            _0: "ElementNotFound"
          };
  }
  var lastIdx = set.length - 1 | 0;
  if (idx < lastIdx) {
    var lastElem = Belt_Array.get(set.data, lastIdx);
    if (lastElem !== undefined) {
      set.data[idx] = lastElem;
    }
    
  }
  set.length = set.length - 1 | 0;
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function clear$3(set) {
  set.length = 0;
  set.data = [];
}

function items$3(set) {
  return Belt_Array.slice(set.data, 0, set.length);
}

var StringSet = {
  make: make$3,
  count: count$3,
  isEmpty: isEmpty$3,
  isFull: isFull$3,
  contains: contains$3,
  insert: insert$3,
  remove: remove$3,
  clear: clear$3,
  items: items$3
};

export {
  make ,
  count ,
  isEmpty ,
  isFull ,
  remaining ,
  contains ,
  insert ,
  insertResult ,
  remove ,
  discard ,
  clear ,
  items ,
  unionWith ,
  intersectWith ,
  differenceWith ,
  isSubsetOf ,
  isProperSubsetOf ,
  isSupersetOf ,
  isDisjointWith ,
  equals ,
  pop ,
  union ,
  intersection ,
  difference ,
  symmetricDifference ,
  map ,
  filter ,
  fold ,
  exists ,
  forAll ,
  find ,
  Ordered ,
  Sorted ,
  StringSet ,
}
/* No side effect */
