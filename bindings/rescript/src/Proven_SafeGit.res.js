// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Proven_Bitwise from "./Proven_Bitwise.res.js";

var reservedPrefixes = [
  "refs/heads/",
  "refs/tags/",
  "refs/remotes/",
  "refs/notes/",
  "refs/stash"
];

function nullSha1() {
  return {
          bytes: Belt_Array.make(20, 0),
          idType: "Sha1"
        };
}

function nullSha256() {
  return {
          bytes: Belt_Array.make(32, 0),
          idType: "Sha256"
        };
}

function byteLen(idType) {
  if (idType === "Sha1") {
    return 20;
  } else {
    return 32;
  }
}

function hexLen(idType) {
  if (idType === "Sha1") {
    return 40;
  } else {
    return 64;
  }
}

function hexCharToNibble($$char) {
  var code = $$char.charCodeAt(0) | 0;
  if (code >= 48 && code <= 57) {
    return code - 48 | 0;
  } else if (code >= 65 && code <= 70) {
    return code - 55 | 0;
  } else if (code >= 97 && code <= 102) {
    return code - 87 | 0;
  } else {
    return ;
  }
}

function parseObjectId(hexString) {
  var length = hexString.length;
  var idType = length !== 40 ? (
      length !== 64 ? undefined : "Sha256"
    ) : "Sha1";
  if (idType === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidLength"
          };
  }
  var byteLength = byteLen(idType);
  var bytes = Belt_Array.make(byteLength, 0);
  var valid = true;
  for(var i = 0; i < byteLength; ++i){
    if (valid) {
      var highChar = hexString.charAt((i << 1));
      var lowChar = hexString.charAt((i << 1) + 1 | 0);
      var match = hexCharToNibble(highChar);
      var match$1 = hexCharToNibble(lowChar);
      if (match !== undefined && match$1 !== undefined) {
        bytes[i] = Proven_Bitwise.lsl(match, 4) + match$1 | 0;
      } else {
        valid = false;
      }
    }
    
  }
  if (valid) {
    return {
            TAG: "Ok",
            _0: {
              bytes: bytes,
              idType: idType
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidHex"
          };
  }
}

function isValidObjectId(hexString) {
  var match = parseObjectId(hexString);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function isNullObjectId(oid) {
  return Belt_Array.every(oid.bytes, (function ($$byte) {
                return $$byte === 0;
              }));
}

function getBytes(oid) {
  return oid.bytes;
}

function formatObjectId(oid) {
  var hexChars = "0123456789abcdef";
  var result = {
    contents: ""
  };
  Belt_Array.forEach(oid.bytes, (function ($$byte) {
          var high = Proven_Bitwise.lsr($$byte, 4);
          var low = Proven_Bitwise.land($$byte, 15);
          result.contents = result.contents + hexChars.charAt(high) + hexChars.charAt(low);
        }));
  return result.contents;
}

function abbreviateObjectId(oid, length) {
  var fullHex = formatObjectId(oid);
  var maxLen = hexLen(oid.idType);
  var actualLen = length > maxLen ? maxLen : (
      length < 1 ? 1 : length
    );
  return fullHex.slice(0, actualLen);
}

function equalObjectId(oidA, oidB) {
  if (oidA.idType !== oidB.idType) {
    return false;
  } else {
    return Belt_Array.eq(oidA.bytes, oidB.bytes, (function (a, b) {
                  return a === b;
                }));
  }
}

function constantTimeEqualObjectId(oidA, oidB) {
  if (oidA.idType !== oidB.idType) {
    return false;
  }
  var diff = {
    contents: 0
  };
  Belt_Array.forEachWithIndex(oidA.bytes, (function (i, byteA) {
          var byteB = oidB.bytes[i];
          diff.contents = Proven_Bitwise.lor(diff.contents, Proven_Bitwise.lxor(byteA, byteB));
        }));
  return diff.contents === 0;
}

function isValidRefChar($$char) {
  var code = $$char.charCodeAt(0) | 0;
  if (code >= 0 && code <= 31 || code === 127) {
    return false;
  }
  switch ($$char) {
    case " " :
    case "*" :
    case ":" :
    case "?" :
    case "[" :
    case "\\" :
    case "^" :
    case "~" :
        return false;
    default:
      return true;
  }
}

function isValidRefName(referenceName) {
  var length = referenceName.length;
  if (length === 0) {
    return false;
  }
  var firstChar = referenceName.charAt(0);
  var lastChar = referenceName.charAt(length - 1 | 0);
  if (firstChar === "/" || lastChar === "/") {
    return false;
  }
  if (firstChar === "." || lastChar === ".") {
    return false;
  }
  if (referenceName.endsWith(".lock")) {
    return false;
  }
  if (referenceName === "@") {
    return false;
  }
  if (referenceName.includes("@{")) {
    return false;
  }
  var valid = true;
  var prevChar = "";
  for(var i = 0; i < length; ++i){
    if (valid) {
      var $$char = referenceName.charAt(i);
      if (!(isValidRefChar($$char) && !($$char === "." && prevChar === "." || $$char === "/" && prevChar === "/" || $$char === "." && prevChar === "/"))) {
        valid = false;
      }
      prevChar = $$char;
    }
    
  }
  return valid;
}

function isValidBranchName(branchName) {
  if (!isValidRefName(branchName)) {
    return false;
  }
  var length = branchName.length;
  return !(length > 0 && branchName.charAt(0) === "-");
}

function isValidTagName(tagName) {
  return isValidRefName(tagName);
}

function sanitizeRefName(input) {
  var length = input.length;
  if (length === 0) {
    return {
            TAG: "Error",
            _0: "EmptyReference"
          };
  }
  var result = "";
  var prevChar = "";
  var skipLeadingDots = true;
  for(var i = 0; i < length; ++i){
    var $$char = input.charAt(i);
    if (!(skipLeadingDots && $$char === ".")) {
      skipLeadingDots = false;
      var sanitizedChar = isValidRefChar($$char) && $$char !== "/" ? $$char : "-";
      if (!(sanitizedChar === "-" && prevChar === "-") && !(sanitizedChar === "." && prevChar === ".")) {
        result = result + sanitizedChar;
        prevChar = sanitizedChar;
      }
      
    }
    
  }
  var trimmed = result;
  while((function () {
          var tmp = false;
          if (trimmed.length > 0) {
            var last = trimmed.charAt(trimmed.length - 1 | 0);
            tmp = last === "." || last === "-";
          }
          return tmp;
        })()) {
    trimmed = trimmed.slice(0, -1);
  };
  if (trimmed.endsWith(".lock")) {
    trimmed = trimmed.slice(0, -5);
  }
  if (trimmed.length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidStructure"
          };
  } else {
    return {
            TAG: "Ok",
            _0: trimmed
          };
  }
}

function normalizeRefName(referenceName) {
  if (referenceName.length === 0) {
    return {
            TAG: "Error",
            _0: "EmptyReference"
          };
  } else {
    return {
            TAG: "Ok",
            _0: referenceName.toLowerCase()
          };
  }
}

function hasReservedPrefix(referenceName) {
  return Belt_Array.some(reservedPrefixes, (function (prefix) {
                return referenceName.startsWith(prefix);
              }));
}

function shortName(referenceName) {
  var found = Belt_Array.getBy(reservedPrefixes, (function (prefix) {
          return referenceName.startsWith(prefix);
        }));
  if (found !== undefined) {
    return referenceName.slice(found.length);
  } else {
    return referenceName;
  }
}

function objectIdTypeToString(idType) {
  if (idType === "Sha1") {
    return "SHA-1";
  } else {
    return "SHA-256";
  }
}

function gitErrorToString(error) {
  switch (error) {
    case "EmptyReference" :
        return "Reference name is empty";
    case "InvalidCharacter" :
        return "Reference contains invalid characters";
    case "InvalidStructure" :
        return "Reference has invalid structure";
    case "ReservedName" :
        return "Reference name is reserved";
    case "InvalidLength" :
        return "Object ID has invalid length";
    case "InvalidHex" :
        return "Object ID contains non-hexadecimal characters";
    case "BufferTooSmall" :
        return "Buffer is too small for the operation";
    
  }
}

export {
  reservedPrefixes ,
  nullSha1 ,
  nullSha256 ,
  byteLen ,
  hexLen ,
  hexCharToNibble ,
  parseObjectId ,
  isValidObjectId ,
  isNullObjectId ,
  getBytes ,
  formatObjectId ,
  abbreviateObjectId ,
  equalObjectId ,
  constantTimeEqualObjectId ,
  isValidRefChar ,
  isValidRefName ,
  isValidBranchName ,
  isValidTagName ,
  sanitizeRefName ,
  normalizeRefName ,
  hasReservedPrefix ,
  shortName ,
  objectIdTypeToString ,
  gitErrorToString ,
}
/* No side effect */
