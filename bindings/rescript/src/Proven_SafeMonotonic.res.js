// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Id from "rescript/lib/es6/belt_Id.js";
import * as Belt_Set from "rescript/lib/es6/belt_Set.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

function makeCounter() {
  return {
          value: 0.0
        };
}

function makeCounterFrom(initialValue) {
  if (initialValue < 0.0) {
    return {
            TAG: "Error",
            _0: "Initial value must be non-negative"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              value: initialValue
            }
          };
  }
}

function getCounterValue(counter) {
  return counter.value;
}

function incrementCounter(counter) {
  counter.value = counter.value + 1.0;
  return counter.value;
}

function incrementCounterBy(counter, amount) {
  if (amount < 0.0) {
    return {
            TAG: "Error",
            _0: "Increment amount must be non-negative"
          };
  } else {
    counter.value = counter.value + amount;
    return {
            TAG: "Ok",
            _0: counter.value
          };
  }
}

function advanceCounterTo(counter, target) {
  counter.value = Math.max(counter.value, target);
  return counter.value;
}

function compareCounters(a, b) {
  if (a.value < b.value) {
    return -1;
  } else if (a.value > b.value) {
    return 1;
  } else {
    return 0;
  }
}

function makeLamportClock(nodeId) {
  return {
          timestamp: 0.0,
          nodeId: nodeId
        };
}

function getLamportTimestamp(clock) {
  return clock.timestamp;
}

function getLamportNodeId(clock) {
  return clock.nodeId;
}

function tick(clock) {
  clock.timestamp = clock.timestamp + 1.0;
  return clock.timestamp;
}

function send(clock) {
  return tick(clock);
}

function receive(clock, receivedTimestamp) {
  clock.timestamp = Math.max(clock.timestamp, receivedTimestamp) + 1.0;
  return clock.timestamp;
}

function compareLamportClocks(a, b) {
  if (a.timestamp < b.timestamp) {
    return "Before";
  } else if (a.timestamp > b.timestamp) {
    return "After";
  } else if (a.nodeId < b.nodeId) {
    return "Before";
  } else if (a.nodeId > b.nodeId) {
    return "After";
  } else {
    return "Equal";
  }
}

function happenedBefore(a, b) {
  return a.timestamp < b.timestamp;
}

function happenedAfter(a, b) {
  return a.timestamp > b.timestamp;
}

function areConcurrent(a, b) {
  if (a.timestamp === b.timestamp) {
    return a.nodeId !== b.nodeId;
  } else {
    return false;
  }
}

function makeHighWaterMark() {
  return {
          mark: 0.0
        };
}

function makeHighWaterMarkFrom(initialValue) {
  if (initialValue < 0.0) {
    return {
            TAG: "Error",
            _0: "Initial value must be non-negative"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              mark: initialValue
            }
          };
  }
}

function getHighWaterMark(hwm) {
  return hwm.mark;
}

function updateHighWaterMark(hwm, offset) {
  hwm.mark = Math.max(hwm.mark, offset);
}

function isProcessed(hwm, offset) {
  return offset <= hwm.mark;
}

function isPending(hwm, offset) {
  return offset > hwm.mark;
}

function getGap(hwm, offset) {
  return offset - hwm.mark;
}

function makeVectorClock(selfId) {
  return {
          selfId: selfId,
          entries: [{
              nodeId: selfId,
              timestamp: 0.0
            }]
        };
}

function findOrCreateEntry(vc, nodeId) {
  var maybeEntry = Belt_Array.getBy(vc.entries, (function (entry) {
          return entry.nodeId === nodeId;
        }));
  if (maybeEntry !== undefined) {
    return maybeEntry;
  }
  var newEntry = {
    nodeId: nodeId,
    timestamp: 0.0
  };
  vc.entries.push(newEntry);
  return newEntry;
}

function getVectorTimestamp(vc, nodeId) {
  return findOrCreateEntry(vc, nodeId).timestamp;
}

function getSelfTimestamp(vc) {
  return getVectorTimestamp(vc, vc.selfId);
}

function tickVectorClock(vc) {
  var entry = findOrCreateEntry(vc, vc.selfId);
  entry.timestamp = entry.timestamp + 1.0;
}

function mergeVectorClocks(vc, other) {
  Belt_Array.forEach(other, (function (otherEntry) {
          var entry = findOrCreateEntry(vc, otherEntry.nodeId);
          entry.timestamp = Math.max(entry.timestamp, otherEntry.timestamp);
        }));
}

function sendVectorClock(vc) {
  tickVectorClock(vc);
  return Belt_Array.map(vc.entries, (function (entry) {
                return {
                        nodeId: entry.nodeId,
                        timestamp: entry.timestamp
                      };
              }));
}

function receiveVectorClock(vc, received) {
  mergeVectorClocks(vc, received);
  tickVectorClock(vc);
}

function compareVectorClocks(a, b) {
  var aEntries = a.entries;
  var bEntries = b.entries;
  var cmp = Caml_obj.compare;
  var FloatCmp = Belt_Id.MakeComparable({
        cmp: cmp
      });
  var allNodeIds = Belt_Set.fromArray(Belt_Array.concat(Belt_Array.map(aEntries, (function (e) {
                  return e.nodeId;
                })), Belt_Array.map(bEntries, (function (e) {
                  return e.nodeId;
                }))), FloatCmp);
  var aLessOrEqual = {
    contents: true
  };
  var bLessOrEqual = {
    contents: true
  };
  var equal = {
    contents: true
  };
  Belt_Set.forEach(allNodeIds, (function (nodeId) {
          var e = Belt_Array.getBy(aEntries, (function (e) {
                  return e.nodeId === nodeId;
                }));
          var aTs = e !== undefined ? e.timestamp : 0.0;
          var e$1 = Belt_Array.getBy(bEntries, (function (e) {
                  return e.nodeId === nodeId;
                }));
          var bTs = e$1 !== undefined ? e$1.timestamp : 0.0;
          if (aTs > bTs) {
            bLessOrEqual.contents = false;
            equal.contents = false;
          }
          if (bTs > aTs) {
            aLessOrEqual.contents = false;
            equal.contents = false;
            return ;
          }
          
        }));
  if (equal.contents) {
    return "Equal";
  } else if (aLessOrEqual.contents) {
    return "Before";
  } else if (bLessOrEqual.contents) {
    return "After";
  } else {
    return "Concurrent";
  }
}

function getVectorClockEntries(vc) {
  return Belt_Array.map(vc.entries, (function (entry) {
                return {
                        nodeId: entry.nodeId,
                        timestamp: entry.timestamp
                      };
              }));
}

function getVectorClockSize(vc) {
  return vc.entries.length;
}

function clockOrderToString(order) {
  switch (order) {
    case "Before" :
        return "before";
    case "After" :
        return "after";
    case "Concurrent" :
        return "concurrent";
    case "Equal" :
        return "equal";
    
  }
}

function generateNodeId() {
  var now = Date.now();
  var random = Math.random() * 1000000.0;
  return now * 1000000.0 + random;
}

export {
  makeCounter ,
  makeCounterFrom ,
  getCounterValue ,
  incrementCounter ,
  incrementCounterBy ,
  advanceCounterTo ,
  compareCounters ,
  makeLamportClock ,
  getLamportTimestamp ,
  getLamportNodeId ,
  tick ,
  send ,
  receive ,
  compareLamportClocks ,
  happenedBefore ,
  happenedAfter ,
  areConcurrent ,
  makeHighWaterMark ,
  makeHighWaterMarkFrom ,
  getHighWaterMark ,
  updateHighWaterMark ,
  isProcessed ,
  isPending ,
  getGap ,
  makeVectorClock ,
  findOrCreateEntry ,
  getVectorTimestamp ,
  getSelfTimestamp ,
  tickVectorClock ,
  mergeVectorClocks ,
  sendVectorClock ,
  receiveVectorClock ,
  compareVectorClocks ,
  getVectorClockEntries ,
  getVectorClockSize ,
  clockOrderToString ,
  generateNodeId ,
}
/* No side effect */
