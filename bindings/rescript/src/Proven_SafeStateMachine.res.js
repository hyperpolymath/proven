// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function make(initialState) {
  return {
          currentState: initialState,
          initialState: initialState,
          transitions: [],
          finalStates: []
        };
}

function addTransition(stateMachine, from, trigger, to_) {
  var newTransition = {
    from: from,
    trigger: trigger,
    to: to_
  };
  return {
          currentState: stateMachine.currentState,
          initialState: stateMachine.initialState,
          transitions: Belt_Array.concat(stateMachine.transitions, [newTransition]),
          finalStates: stateMachine.finalStates
        };
}

function addFinalState(stateMachine, state) {
  return {
          currentState: stateMachine.currentState,
          initialState: stateMachine.initialState,
          transitions: stateMachine.transitions,
          finalStates: Belt_Array.concat(stateMachine.finalStates, [state])
        };
}

function findTransition(stateMachine, $$event, stateEq, eventEq) {
  var result = {
    contents: undefined
  };
  Belt_Array.forEach(stateMachine.transitions, (function (trans) {
          if (result.contents === undefined && stateEq(trans.from, stateMachine.currentState) && eventEq(trans.trigger, $$event)) {
            result.contents = Caml_option.some(trans.to);
            return ;
          }
          
        }));
  return result.contents;
}

function trigger(stateMachine, $$event, stateEq, eventEq) {
  var nextState = findTransition(stateMachine, $$event, stateEq, eventEq);
  if (nextState !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              currentState: Caml_option.valFromOption(nextState),
              initialState: stateMachine.initialState,
              transitions: stateMachine.transitions,
              finalStates: stateMachine.finalStates
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidTransition"
          };
  }
}

function canTrigger(stateMachine, $$event, stateEq, eventEq) {
  return Belt_Option.isSome(findTransition(stateMachine, $$event, stateEq, eventEq));
}

function getState(stateMachine) {
  return stateMachine.currentState;
}

function isInFinalState(stateMachine, stateEq) {
  return Belt_Array.some(stateMachine.finalStates, (function (finalState) {
                return stateEq(finalState, stateMachine.currentState);
              }));
}

function reset(stateMachine) {
  return {
          currentState: stateMachine.initialState,
          initialState: stateMachine.initialState,
          transitions: stateMachine.transitions,
          finalStates: stateMachine.finalStates
        };
}

function availableTransitions(stateMachine, stateEq) {
  return Belt_Array.keepMap(stateMachine.transitions, (function (trans) {
                if (stateEq(trans.from, stateMachine.currentState)) {
                  return Caml_option.some(trans.trigger);
                }
                
              }));
}

function reachableStates(stateMachine, stateEq) {
  return Belt_Array.keepMap(stateMachine.transitions, (function (trans) {
                if (stateEq(trans.from, stateMachine.currentState)) {
                  return Caml_option.some(trans.to);
                }
                
              }));
}

function transitionCount(stateMachine) {
  return stateMachine.transitions.length;
}

function hasState(stateMachine, state, stateEq) {
  return Belt_Array.some(stateMachine.transitions, (function (trans) {
                if (stateEq(trans.from, state)) {
                  return true;
                } else {
                  return stateEq(trans.to, state);
                }
              }));
}

function make$1(initialState) {
  return {
          currentState: initialState,
          initialState: initialState,
          transitions: [],
          finalStates: []
        };
}

function stringEq(a, b) {
  return a === b;
}

function addTransition$1(sm, from, trigger, to_) {
  return addTransition(sm, from, trigger, to_);
}

function addFinalState$1(sm, state) {
  return addFinalState(sm, state);
}

function trigger$1(sm, $$event) {
  return trigger(sm, $$event, stringEq, stringEq);
}

function canTrigger$1(sm, $$event) {
  return canTrigger(sm, $$event, stringEq, stringEq);
}

function getState$1(sm) {
  return sm.currentState;
}

function isInFinalState$1(sm) {
  return isInFinalState(sm, stringEq);
}

function reset$1(sm) {
  return reset(sm);
}

function availableTransitions$1(sm) {
  return availableTransitions(sm, stringEq);
}

var StringMachine = {
  make: make$1,
  stringEq: stringEq,
  addTransition: addTransition$1,
  addFinalState: addFinalState$1,
  trigger: trigger$1,
  canTrigger: canTrigger$1,
  getState: getState$1,
  isInFinalState: isInFinalState$1,
  reset: reset$1,
  availableTransitions: availableTransitions$1
};

function make$2(initialState) {
  return {
          currentState: initialState,
          initialState: initialState,
          transitions: [],
          finalStates: []
        };
}

function intEq(a, b) {
  return a === b;
}

function addTransition$2(sm, from, trigger, to_) {
  return addTransition(sm, from, trigger, to_);
}

function addFinalState$2(sm, state) {
  return addFinalState(sm, state);
}

function trigger$2(sm, $$event) {
  return trigger(sm, $$event, intEq, intEq);
}

function canTrigger$2(sm, $$event) {
  return canTrigger(sm, $$event, intEq, intEq);
}

function getState$2(sm) {
  return sm.currentState;
}

function isInFinalState$2(sm) {
  return isInFinalState(sm, intEq);
}

function reset$2(sm) {
  return reset(sm);
}

function availableTransitions$2(sm) {
  return availableTransitions(sm, intEq);
}

var IntMachine = {
  make: make$2,
  intEq: intEq,
  addTransition: addTransition$2,
  addFinalState: addFinalState$2,
  trigger: trigger$2,
  canTrigger: canTrigger$2,
  getState: getState$2,
  isInFinalState: isInFinalState$2,
  reset: reset$2,
  availableTransitions: availableTransitions$2
};

export {
  make ,
  addTransition ,
  addFinalState ,
  findTransition ,
  trigger ,
  canTrigger ,
  getState ,
  isInFinalState ,
  reset ,
  availableTransitions ,
  reachableStates ,
  transitionCount ,
  hasState ,
  StringMachine ,
  IntMachine ,
}
/* No side effect */
