// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Proven_Bitwise from "./Proven_Bitwise.res.js";

function errorToString(error) {
  switch (error) {
    case "InvalidSize" :
        return "Invalid filter size";
    case "InvalidHashCount" :
        return "Invalid hash count";
    case "InvalidFalsePositiveRate" :
        return "Invalid false positive rate (must be between 0 and 1)";
    
  }
}

function make(size, numHashes) {
  if (size <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidSize"
          };
  } else if (numHashes <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidHashCount"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              bits: Belt_Array.make(size, false),
              size: size,
              numHashes: numHashes,
              itemCount: 0
            }
          };
  }
}

function fnv1aHash(data, seed) {
  var hash = Proven_Bitwise.lxor(-2128831035, seed);
  for(var i = 0 ,i_finish = data.length; i < i_finish; ++i){
    var $$byte = data.charCodeAt(i) | 0;
    hash = Proven_Bitwise.lxor(hash, $$byte);
    hash = Proven_Bitwise.land(Math.imul(hash, 16777619), 2147483647);
  }
  return hash;
}

function computeHashIndex(data, hashIndex, size) {
  var h1 = fnv1aHash(data, 0);
  var h2 = fnv1aHash(data, h1);
  var combined = h1 + Math.imul(hashIndex, h2) | 0;
  return Caml_int32.mod_(Proven_Bitwise.land(combined, 2147483647), size);
}

function insert(filter, data) {
  for(var i = 0 ,i_finish = filter.numHashes; i < i_finish; ++i){
    var index = computeHashIndex(data, i, filter.size);
    filter.bits[index] = true;
  }
  filter.itemCount = filter.itemCount + 1 | 0;
}

function insertBytes(filter, bytes) {
  var data = Belt_Array.map(bytes, (function (b) {
            return String.fromCharCode(b);
          })).join("");
  insert(filter, data);
}

function contains(filter, data) {
  var found = true;
  var i = 0;
  while(found && i < filter.numHashes) {
    var index = computeHashIndex(data, i, filter.size);
    if (!filter.bits[index]) {
      found = false;
    }
    i = i + 1 | 0;
  };
  return found;
}

function containsBytes(filter, bytes) {
  var data = Belt_Array.map(bytes, (function (b) {
            return String.fromCharCode(b);
          })).join("");
  return contains(filter, data);
}

function countOnes(filter) {
  var count = 0;
  for(var i = 0 ,i_finish = filter.size; i < i_finish; ++i){
    if (filter.bits[i]) {
      count = count + 1 | 0;
    }
    
  }
  return count;
}

function fillRatio(filter) {
  return countOnes(filter) / filter.size;
}

function estimatedFalsePositiveRate(filter) {
  var ratio = fillRatio(filter);
  return Math.pow(ratio, filter.numHashes);
}

function clear(filter) {
  for(var i = 0 ,i_finish = filter.size; i < i_finish; ++i){
    filter.bits[i] = false;
  }
  filter.itemCount = 0;
}

function getItemCount(filter) {
  return filter.itemCount;
}

function getSize(filter) {
  return filter.size;
}

function getNumHashes(filter) {
  return filter.numHashes;
}

function union(filterA, filterB) {
  if (filterA.size !== filterB.size || filterA.numHashes !== filterB.numHashes) {
    return ;
  }
  var newBits = Belt_Array.make(filterA.size, false);
  for(var i = 0 ,i_finish = filterA.size; i < i_finish; ++i){
    var a = filterA.bits[i];
    var b = filterB.bits[i];
    newBits[i] = a || b;
  }
  return {
          bits: newBits,
          size: filterA.size,
          numHashes: filterA.numHashes,
          itemCount: filterA.itemCount + filterB.itemCount | 0
        };
}

function intersection(filterA, filterB) {
  if (filterA.size !== filterB.size || filterA.numHashes !== filterB.numHashes) {
    return ;
  }
  var newBits = Belt_Array.make(filterA.size, false);
  for(var i = 0 ,i_finish = filterA.size; i < i_finish; ++i){
    var a = filterA.bits[i];
    var b = filterB.bits[i];
    newBits[i] = a && b;
  }
  return {
          bits: newBits,
          size: filterA.size,
          numHashes: filterA.numHashes,
          itemCount: 0
        };
}

function unionWith(filter, other) {
  if (filter.size !== other.size || filter.numHashes !== other.numHashes) {
    return {
            TAG: "Error",
            _0: "InvalidSize"
          };
  }
  for(var i = 0 ,i_finish = filter.size; i < i_finish; ++i){
    var a = filter.bits[i];
    var b = other.bits[i];
    filter.bits[i] = a || b;
  }
  filter.itemCount = filter.itemCount + other.itemCount | 0;
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function intersectWith(filter, other) {
  if (filter.size !== other.size || filter.numHashes !== other.numHashes) {
    return {
            TAG: "Error",
            _0: "InvalidSize"
          };
  }
  for(var i = 0 ,i_finish = filter.size; i < i_finish; ++i){
    var a = filter.bits[i];
    var b = other.bits[i];
    filter.bits[i] = a && b;
  }
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function optimalSize(expectedItems, falsePositiveRate) {
  if (expectedItems <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidSize"
          };
  }
  if (falsePositiveRate <= 0.0 || falsePositiveRate >= 1.0) {
    return {
            TAG: "Error",
            _0: "InvalidFalsePositiveRate"
          };
  }
  var m = - expectedItems * Math.log(falsePositiveRate) / 0.4804530139182014;
  return {
          TAG: "Ok",
          _0: Js_math.ceil_int(m)
        };
}

function optimalHashes(filterSize, expectedItems) {
  if (filterSize <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidSize"
          };
  }
  if (expectedItems <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidSize"
          };
  }
  var k = filterSize / expectedItems * 0.6931471805599453;
  return {
          TAG: "Ok",
          _0: Caml.int_max(1, Js_math.ceil_int(k))
        };
}

function makeOptimal(expectedItems, falsePositiveRate) {
  var e = optimalSize(expectedItems, falsePositiveRate);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var size = e._0;
  var e$1 = optimalHashes(size, expectedItems);
  if (e$1.TAG === "Ok") {
    return make(size, e$1._0);
  } else {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
}

export {
  errorToString ,
  make ,
  fnv1aHash ,
  computeHashIndex ,
  insert ,
  insertBytes ,
  contains ,
  containsBytes ,
  countOnes ,
  fillRatio ,
  estimatedFalsePositiveRate ,
  clear ,
  getItemCount ,
  getSize ,
  getNumHashes ,
  union ,
  intersection ,
  unionWith ,
  intersectWith ,
  optimalSize ,
  optimalHashes ,
  makeOptimal ,
}
/* No side effect */
