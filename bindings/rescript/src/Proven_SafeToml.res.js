// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

var defaultParseOptions = {
  maxDepth: 32,
  maxKeys: 256,
  allowDuplicateKeys: false
};

function isValidKey(key) {
  if (key.length === 0) {
    return false;
  }
  var valid = true;
  var length = key.length;
  for(var index = 0; index < length; ++index){
    if (valid) {
      var charCode = key.charCodeAt(index) | 0;
      var isValidChar = charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || charCode >= 48 && charCode <= 57 || charCode === 95 || charCode === 45;
      if (!isValidChar) {
        valid = false;
      }
      
    }
    
  }
  return valid;
}

function isValidString(input) {
  var valid = true;
  var length = input.length;
  for(var index = 0; index < length; ++index){
    if (valid) {
      var charCode = input.charCodeAt(index) | 0;
      if (charCode >= 55296 && charCode <= 56319) {
        if ((index + 1 | 0) >= length) {
          valid = false;
        } else {
          var nextCode = input.charCodeAt(index + 1 | 0) | 0;
          if (nextCode < 56320 || nextCode > 57343) {
            valid = false;
          }
          
        }
      } else if (charCode >= 56320 && charCode <= 57343) {
        valid = false;
      }
      
    }
    
  }
  return valid;
}

function parseValue(input) {
  var trimmed = input.trim();
  if (trimmed.length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidValue"
          };
  }
  if (trimmed === "true") {
    return {
            TAG: "Ok",
            _0: {
              TAG: "Boolean",
              _0: true
            }
          };
  }
  if (trimmed === "false") {
    return {
            TAG: "Ok",
            _0: {
              TAG: "Boolean",
              _0: false
            }
          };
  }
  if (trimmed.charAt(0) === "\"" && trimmed.length >= 2 && trimmed.charAt(trimmed.length - 1 | 0) === "\"") {
    return {
            TAG: "Ok",
            _0: {
              TAG: "String",
              _0: trimmed.slice(1, trimmed.length - 1 | 0)
            }
          };
  }
  if (trimmed.charAt(0) === "'" && trimmed.length >= 2 && trimmed.charAt(trimmed.length - 1 | 0) === "'") {
    return {
            TAG: "Ok",
            _0: {
              TAG: "String",
              _0: trimmed.slice(1, trimmed.length - 1 | 0)
            }
          };
  }
  var intValue = Belt_Int.fromString(trimmed);
  if (intValue !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              TAG: "Integer",
              _0: intValue
            }
          };
  }
  var value = Number(trimmed);
  if (Number.isNaN(value)) {
    return {
            TAG: "Error",
            _0: "InvalidValue"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              TAG: "Float",
              _0: value
            }
          };
  }
}

function parseKeyValue(line) {
  var eqPos = line.indexOf("=");
  if (eqPos === -1) {
    return {
            TAG: "Error",
            _0: "ParseError"
          };
  }
  var key = line.slice(0, eqPos).trim();
  var valueStr = line.slice(eqPos + 1 | 0).trim();
  if (key.length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidKey"
          };
  }
  if (valueStr.length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidValue"
          };
  }
  var parsedValue = parseValue(valueStr);
  if (parsedValue.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: [
              key,
              parsedValue._0
            ]
          };
  } else {
    return {
            TAG: "Error",
            _0: parsedValue._0
          };
  }
}

function isValidToml(input) {
  if (!isValidString(input)) {
    return false;
  }
  var depth = {
    contents: 0
  };
  var valid = {
    contents: true
  };
  var lines = input.split("\n");
  Belt_Array.forEach(lines, (function (line) {
          if (!valid.contents) {
            return ;
          }
          var trimmed = line.trim();
          if (trimmed.length > 0 && trimmed.charAt(0) !== "#") {
            if (trimmed.charAt(0) === "[") {
              if (trimmed.length > 1 && trimmed.charAt(1) === "[") {
                depth.contents = depth.contents + 1 | 0;
                if (depth.contents > 32) {
                  valid.contents = false;
                  return ;
                } else {
                  return ;
                }
              } else {
                depth.contents = 1;
                return ;
              }
            } else if (trimmed.indexOf("=") === -1) {
              valid.contents = false;
              return ;
            } else {
              return ;
            }
          }
          
        }));
  return valid.contents;
}

function escapeString(input) {
  return input.replace(/\\\\/g, "\\\\").replace(/\"/g, "\\\"").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
}

function formatValue(value) {
  switch (value.TAG) {
    case "String" :
        return "\"" + escapeString(value._0) + "\"";
    case "Integer" :
        return String(value._0);
    case "Float" :
        return value._0.toString();
    case "Boolean" :
        if (value._0) {
          return "true";
        } else {
          return "false";
        }
    case "Datetime" :
        return value._0;
    case "Array" :
        var items = Belt_Array.map(value._0, formatValue);
        return "[" + items.join(", ") + "]";
    case "Table" :
        return "{ }";
    
  }
}

function asString(value) {
  if (value.TAG === "String") {
    return value._0;
  }
  
}

function asInteger(value) {
  if (value.TAG === "Integer") {
    return value._0;
  }
  
}

function asFloat(value) {
  if (value.TAG === "Float") {
    return value._0;
  }
  
}

function asBool(value) {
  if (value.TAG === "Boolean") {
    return value._0;
  }
  
}

function asArray(value) {
  if (value.TAG === "Array") {
    return value._0;
  }
  
}

function asTable(value) {
  if (value.TAG === "Table") {
    return value._0;
  }
  
}

function isString(value) {
  if (value.TAG === "String") {
    return true;
  } else {
    return false;
  }
}

function isInteger(value) {
  if (value.TAG === "Integer") {
    return true;
  } else {
    return false;
  }
}

function isFloat(value) {
  if (value.TAG === "Float") {
    return true;
  } else {
    return false;
  }
}

function isBoolean(value) {
  if (value.TAG === "Boolean") {
    return true;
  } else {
    return false;
  }
}

function isDatetime(value) {
  if (value.TAG === "Datetime") {
    return true;
  } else {
    return false;
  }
}

function isArray(value) {
  if (value.TAG === "Array") {
    return true;
  } else {
    return false;
  }
}

function isTable(value) {
  if (value.TAG === "Table") {
    return true;
  } else {
    return false;
  }
}

function emptyTable() {
  return {
          TAG: "Table",
          _0: {}
        };
}

function get(table, key) {
  if (table.TAG === "Table") {
    return Js_dict.get(table._0, key);
  }
  
}

function set(table, key, value) {
  if (table.TAG !== "Table") {
    return {
            TAG: "Error",
            _0: "TypeMismatch"
          };
  }
  var newDict = Js_dict.fromArray(Js_dict.entries(table._0));
  newDict[key] = value;
  return {
          TAG: "Ok",
          _0: {
            TAG: "Table",
            _0: newDict
          }
        };
}

function contains(table, key) {
  if (table.TAG === "Table") {
    return Belt_Option.isSome(Js_dict.get(table._0, key));
  } else {
    return false;
  }
}

function size(table) {
  if (table.TAG === "Table") {
    return Object.keys(table._0).length;
  } else {
    return 0;
  }
}

function getPath(table, path) {
  var parts = path.split(".");
  return Belt_Array.reduce(parts, table, (function (acc, key) {
                if (acc !== undefined && acc.TAG === "Table") {
                  return Js_dict.get(acc._0, key);
                }
                
              }));
}

function string(value) {
  return {
          TAG: "String",
          _0: value
        };
}

function integer(value) {
  return {
          TAG: "Integer",
          _0: value
        };
}

function $$float(value) {
  return {
          TAG: "Float",
          _0: value
        };
}

function $$boolean(value) {
  return {
          TAG: "Boolean",
          _0: value
        };
}

function datetime(value) {
  return {
          TAG: "Datetime",
          _0: value
        };
}

function array(values) {
  return {
          TAG: "Array",
          _0: values
        };
}

function table(entries) {
  return {
          TAG: "Table",
          _0: Js_dict.fromArray(entries)
        };
}

var maxDepth = 32;

var maxKeysPerTable = 256;

export {
  maxDepth ,
  maxKeysPerTable ,
  defaultParseOptions ,
  isValidKey ,
  isValidString ,
  parseValue ,
  parseKeyValue ,
  isValidToml ,
  escapeString ,
  formatValue ,
  asString ,
  asInteger ,
  asFloat ,
  asBool ,
  asArray ,
  asTable ,
  isString ,
  isInteger ,
  isFloat ,
  isBoolean ,
  isDatetime ,
  isArray ,
  isTable ,
  emptyTable ,
  get ,
  set ,
  contains ,
  size ,
  getPath ,
  string ,
  integer ,
  $$float ,
  $$boolean ,
  datetime ,
  array ,
  table ,
}
/* No side effect */
