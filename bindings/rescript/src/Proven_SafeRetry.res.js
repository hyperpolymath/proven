// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

var defaultConfig = {
  maxAttempts: 3,
  backoff: {
    TAG: "Exponential",
    initial: 100.0,
    multiplier: 2.0
  },
  maxDelay: 30000.0
};

function fixedBackoff(delay) {
  return {
          TAG: "Fixed",
          delay: delay
        };
}

function linearBackoff(initial, increment) {
  return {
          TAG: "Linear",
          initial: initial,
          increment: increment
        };
}

function exponentialBackoff(initial, multiplier) {
  return {
          TAG: "Exponential",
          initial: initial,
          multiplier: multiplier
        };
}

function jitteredBackoff(initial, multiplier, maxJitter) {
  return {
          TAG: "Jittered",
          initial: initial,
          multiplier: multiplier,
          maxJitter: maxJitter
        };
}

function calculateDelay(strategy, attempt) {
  switch (strategy.TAG) {
    case "Fixed" :
        return strategy.delay;
    case "Linear" :
        return strategy.initial + strategy.increment * attempt;
    case "Exponential" :
    case "Jittered" :
        break;
    
  }
  return strategy.initial * Math.pow(strategy.multiplier, attempt);
}

function calculateDelayWithCap(config, attempt) {
  var rawDelay = calculateDelay(config.backoff, attempt);
  return Math.min(config.maxDelay, rawDelay);
}

function addJitter(delay, maxJitter) {
  var jitter = Math.random() * maxJitter * 2.0 - maxJitter;
  return Math.max(0.0, delay + jitter);
}

function calculateDelayWithJitter(config, attempt) {
  var delay = calculateDelayWithCap(config, attempt);
  var match = config.backoff;
  if (match.TAG === "Jittered") {
    return addJitter(delay, match.maxJitter);
  } else {
    return delay;
  }
}

function make(config) {
  if (config.maxAttempts <= 0) {
    return {
            TAG: "Error",
            _0: "Max attempts must be positive"
          };
  } else if (config.maxDelay <= 0.0) {
    return {
            TAG: "Error",
            _0: "Max delay must be positive"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              config: config,
              state: {
                attempt: 0,
                totalDelay: 0.0,
                lastError: undefined
              }
            }
          };
  }
}

function makeDefault() {
  return {
          config: defaultConfig,
          state: {
            attempt: 0,
            totalDelay: 0.0,
            lastError: undefined
          }
        };
}

function makeWith(maxAttempts, backoff, maxDelay) {
  return make({
              maxAttempts: maxAttempts,
              backoff: backoff,
              maxDelay: maxDelay
            });
}

function canRetry(executor) {
  return executor.state.attempt < executor.config.maxAttempts;
}

function remainingAttempts(executor) {
  return executor.config.maxAttempts - executor.state.attempt | 0;
}

function nextAttempt(executor, errorMessage) {
  if (!canRetry(executor)) {
    return ;
  }
  var delay = calculateDelayWithJitter(executor.config, executor.state.attempt);
  executor.state.attempt = executor.state.attempt + 1 | 0;
  executor.state.totalDelay = executor.state.totalDelay + delay;
  executor.state.lastError = errorMessage;
  return delay;
}

function currentAttempt(executor) {
  return executor.state.attempt;
}

function totalDelay(executor) {
  return executor.state.totalDelay;
}

function lastError(executor) {
  return executor.state.lastError;
}

function reset(executor) {
  executor.state.attempt = 0;
  executor.state.totalDelay = 0.0;
  executor.state.lastError = undefined;
}

function executeSync(executor, operation) {
  reset(executor);
  var loop = function () {
    while(true) {
      var value = operation();
      if (value.TAG === "Ok") {
        return {
                TAG: "Success",
                _0: value._0
              };
      }
      var _delay = nextAttempt(executor, value._0);
      if (_delay === undefined) {
        return {
                TAG: "Exhausted",
                attempts: executor.state.attempt,
                lastError: executor.state.lastError
              };
      }
      continue ;
    };
  };
  if (executor.config.maxAttempts <= 0) {
    return {
            TAG: "NoRetry",
            reason: "No attempts configured"
          };
  } else {
    return loop();
  }
}

function peekNextDelay(executor) {
  if (canRetry(executor)) {
    return calculateDelayWithJitter(executor.config, executor.state.attempt);
  }
  
}

function getAllDelays(config) {
  return Belt_Array.makeBy(config.maxAttempts, (function (i) {
                return calculateDelayWithCap(config, i);
              }));
}

function totalMaxDelay(config) {
  return Belt_Array.reduce(getAllDelays(config), 0.0, (function (acc, delay) {
                return acc + delay;
              }));
}

function isSuccess(result) {
  switch (result.TAG) {
    case "Success" :
        return true;
    case "Exhausted" :
    case "NoRetry" :
        return false;
    
  }
}

function getValue(result) {
  switch (result.TAG) {
    case "Success" :
        return Caml_option.some(result._0);
    case "Exhausted" :
    case "NoRetry" :
        return ;
    
  }
}

function getExhaustedAttempts(result) {
  switch (result.TAG) {
    case "Exhausted" :
        return result.attempts;
    case "Success" :
    case "NoRetry" :
        return ;
    
  }
}

function toResult(result) {
  switch (result.TAG) {
    case "Success" :
        return {
                TAG: "Ok",
                _0: result._0
              };
    case "Exhausted" :
        var lastError = result.lastError;
        var attempts = result.attempts;
        var errorMsg = lastError !== undefined ? "Exhausted after " + String(attempts) + " attempts: " + lastError : "Exhausted after " + String(attempts) + " attempts";
        return {
                TAG: "Error",
                _0: errorMsg
              };
    case "NoRetry" :
        return {
                TAG: "Error",
                _0: result.reason
              };
    
  }
}

function sleep(ms) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve();
                      }), ms | 0);
              }));
}

export {
  defaultConfig ,
  fixedBackoff ,
  linearBackoff ,
  exponentialBackoff ,
  jitteredBackoff ,
  calculateDelay ,
  calculateDelayWithCap ,
  addJitter ,
  calculateDelayWithJitter ,
  make ,
  makeDefault ,
  makeWith ,
  canRetry ,
  remainingAttempts ,
  nextAttempt ,
  currentAttempt ,
  totalDelay ,
  lastError ,
  reset ,
  executeSync ,
  peekNextDelay ,
  getAllDelays ,
  totalMaxDelay ,
  isSuccess ,
  getValue ,
  getExhaustedAttempts ,
  toResult ,
  sleep ,
}
/* No side effect */
