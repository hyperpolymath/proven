// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

function escapeText(input) {
  return input.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/'/g, "&#x27;");
}

function escapeAttribute(input) {
  return input.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;");
}

function escapeSingleQuotedAttr(input) {
  return input.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#x27;");
}

function escapeUnquotedAttr(input) {
  return input.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/'/g, "&#x27;").replace(/`/g, "&#x60;").replace(/=/g, "&#x3D;").replace(/\\s/g, "&#x20;");
}

function escapeForContext(input, context) {
  switch (context) {
    case "TextContent" :
        return escapeText(input);
    case "SingleQuotedAttr" :
        return escapeSingleQuotedAttr(input);
    case "DoubleQuotedAttr" :
        return escapeAttribute(input);
    case "UnquotedAttr" :
        return escapeUnquotedAttr(input);
    
  }
}

var dangerousSchemes = [
  "javascript:",
  "vbscript:",
  "data:",
  "blob:"
];

function isSafeUrlScheme(url) {
  var trimmed = url.trim().toLowerCase();
  var isDangerous = {
    contents: false
  };
  Belt_Array.forEach(dangerousSchemes, (function (scheme) {
          if (isDangerous.contents) {
            return ;
          }
          var schemeLen = scheme.length;
          if (trimmed.length < schemeLen) {
            return ;
          }
          var prefix = trimmed.slice(0, schemeLen);
          if (prefix === scheme) {
            isDangerous.contents = true;
            return ;
          }
          
        }));
  return !isDangerous.contents;
}

function escapeUrl(input) {
  return input.replace(/&/g, "&amp;").replace(/\"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function sanitizeUrl(input) {
  if (isSafeUrlScheme(input)) {
    return escapeUrl(input);
  }
  
}

var dangerousTags = [
  "script",
  "style",
  "iframe",
  "frame",
  "frameset",
  "object",
  "embed",
  "applet",
  "form",
  "input",
  "button",
  "select",
  "textarea",
  "link",
  "meta",
  "base",
  "svg",
  "math"
];

function isDangerousTag(tagName) {
  var lowerTag = tagName.toLowerCase();
  return Belt_Array.some(dangerousTags, (function (t) {
                return t === lowerTag;
              }));
}

var dangerousAttributes = [
  "onclick",
  "ondblclick",
  "onmousedown",
  "onmouseup",
  "onmouseover",
  "onmousemove",
  "onmouseout",
  "onmouseenter",
  "onmouseleave",
  "onkeydown",
  "onkeyup",
  "onkeypress",
  "onload",
  "onerror",
  "onabort",
  "onsubmit",
  "onreset",
  "onselect",
  "onblur",
  "onfocus",
  "onchange",
  "oninput",
  "onscroll",
  "onwheel",
  "oncopy",
  "oncut",
  "onpaste",
  "ondrag",
  "ondragstart",
  "ondragend",
  "ondragover",
  "ondragenter",
  "ondragleave",
  "ondrop",
  "onanimationstart",
  "onanimationend",
  "onanimationiteration",
  "ontransitionend",
  "formaction",
  "xlink:href"
];

function isDangerousAttribute(attrName) {
  var lowerAttr = attrName.toLowerCase();
  if (Belt_Array.some(dangerousAttributes, (function (a) {
            return a === lowerAttr;
          }))) {
    return true;
  } else if (lowerAttr.length >= 2) {
    return lowerAttr.slice(0, 2) === "on";
  } else {
    return false;
  }
}

function stripTags(input) {
  return input.replace(/<[^>]*>/g, "");
}

function stripTagsByName(input, tagNames) {
  var result = {
    contents: input
  };
  Belt_Array.forEach(tagNames, (function (tagName) {
          var pattern = new RegExp("<" + tagName + "[^>]*>|</" + tagName + ">", "gi");
          result.contents = result.contents.replace(pattern, "");
        }));
  return result.contents;
}

function stripDangerousTags(input) {
  return stripTagsByName(input, dangerousTags);
}

function escapeJsInHtml(input) {
  return input.replace(/\\\\/g, "\\\\").replace(/\"/g, "\\\"").replace(/'/g, "\\'").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/</g, "\\u003C").replace(/>/g, "\\u003E").replace(/&/g, "\\u0026").replace(/[/]/g, "\\/");
}

function escapeCssInHtml(input) {
  return input.replace(/\\\\/g, "\\\\").replace(/\"/g, "\\\"").replace(/'/g, "\\'").replace(/</g, "\\3C ").replace(/>/g, "\\3E ").replace(/&/g, "\\26 ").replace(/[/]/g, "\\2F ").replace(/\n/g, "\\A ").replace(/\r/g, "\\D ");
}

var entityMap = [
  [
    "&amp;",
    "&"
  ],
  [
    "&lt;",
    "<"
  ],
  [
    "&gt;",
    ">"
  ],
  [
    "&quot;",
    "\""
  ],
  [
    "&#x27;",
    "'"
  ],
  [
    "&apos;",
    "'"
  ],
  [
    "&#39;",
    "'"
  ],
  [
    "&nbsp;",
    " "
  ],
  [
    "&#160;",
    " "
  ],
  [
    "&#xa0;",
    " "
  ],
  [
    "&#x20;",
    " "
  ],
  [
    "&#32;",
    " "
  ]
];

function unescapeEntities(input) {
  var result = {
    contents: input
  };
  Belt_Array.forEach(entityMap, (function (param) {
          result.contents = result.contents.replace(new RegExp(param[0], "gi"), param[1]);
        }));
  result.contents = result.contents.replace(/&#(\d+);/g, (function (param, numStr, param$1, param$2) {
          var code = Belt_Int.fromString(numStr);
          if (code !== undefined) {
            if (code >= 0 && code <= 255) {
              return String.fromCharCode(code);
            } else {
              return "&#" + numStr + ";";
            }
          } else {
            return "&#" + numStr + ";";
          }
        }));
  result.contents = result.contents.replace(/&#x([0-9a-fA-F]+);/gi, (function (param, hexStr, param$1, param$2) {
          var code = Number("0x" + hexStr) | 0;
          if (code >= 0 && code <= 255) {
            return String.fromCharCode(code);
          } else {
            return "&#x" + hexStr + ";";
          }
        }));
  return result.contents;
}

function maxEscapedLength(inputLength) {
  return Math.imul(inputLength, 6);
}

function containsHtmlTags(input) {
  return /<[^>]+>/.test(input);
}

function containsDangerousHtml(input) {
  if (/<script/i.test(input) || /javascript:/i.test(input) || /on\\w+\\s*=/i.test(input)) {
    return true;
  } else {
    return /data:[^\"'\\s]+/i.test(input);
  }
}

function extractText(input) {
  return unescapeEntities(stripTags(input));
}

function safeElement(tagName, content) {
  if (isDangerousTag(tagName)) {
    return {
            TAG: "Error",
            _0: "MalformedHtml"
          };
  }
  var escapedContent = escapeText(content);
  return {
          TAG: "Ok",
          _0: "<" + tagName + ">" + escapedContent + "</" + tagName + ">"
        };
}

function safeLink(href, text) {
  var safeHref = sanitizeUrl(href);
  if (safeHref === undefined) {
    return ;
  }
  var escapedText = escapeText(text);
  return "<a href=\"" + safeHref + "\">" + escapedText + "</a>";
}

function safeImage(src, alt) {
  var safeSrc = sanitizeUrl(src);
  if (safeSrc === undefined) {
    return ;
  }
  var escapedAlt = escapeAttribute(alt);
  return "<img src=\"" + safeSrc + "\" alt=\"" + escapedAlt + "\" />";
}

function errorToString(err) {
  switch (err) {
    case "BufferTooSmall" :
        return "Buffer too small for operation";
    case "InvalidUtf8" :
        return "Invalid UTF-8 sequence";
    case "MalformedHtml" :
        return "Malformed HTML structure";
    
  }
}

export {
  escapeText ,
  escapeAttribute ,
  escapeSingleQuotedAttr ,
  escapeUnquotedAttr ,
  escapeForContext ,
  dangerousSchemes ,
  isSafeUrlScheme ,
  escapeUrl ,
  sanitizeUrl ,
  dangerousTags ,
  isDangerousTag ,
  dangerousAttributes ,
  isDangerousAttribute ,
  stripTags ,
  stripTagsByName ,
  stripDangerousTags ,
  escapeJsInHtml ,
  escapeCssInHtml ,
  entityMap ,
  unescapeEntities ,
  maxEscapedLength ,
  containsHtmlTags ,
  containsDangerousHtml ,
  extractText ,
  safeElement ,
  safeLink ,
  safeImage ,
  errorToString ,
}
/* No side effect */
