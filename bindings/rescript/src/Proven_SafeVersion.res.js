// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_SortArray from "rescript/lib/es6/belt_SortArray.js";

function make(major, minor, patch) {
  if (major < 0 || minor < 0 || patch < 0) {
    return ;
  } else {
    return {
            major: major,
            minor: minor,
            patch: patch,
            prerelease: undefined,
            buildMetadata: undefined
          };
  }
}

function makeWithPrerelease(major, minor, patch, prerelease) {
  if (major < 0 || minor < 0 || patch < 0) {
    return ;
  } else {
    return {
            major: major,
            minor: minor,
            patch: patch,
            prerelease: prerelease,
            buildMetadata: undefined
          };
  }
}

function makeFull(major, minor, patch, prerelease, buildMetadata) {
  if (major < 0 || minor < 0 || patch < 0) {
    return ;
  } else {
    return {
            major: major,
            minor: minor,
            patch: patch,
            prerelease: prerelease,
            buildMetadata: buildMetadata
          };
  }
}

function parse(versionString) {
  var str = versionString.trim();
  var str$1 = str.startsWith("v") ? str.slice(1) : str;
  var idx = str$1.indexOf("+");
  var match = idx !== -1 ? [
      str$1.slice(0, idx),
      str$1.slice(idx + 1 | 0)
    ] : [
      str$1,
      undefined
    ];
  var str$2 = match[0];
  var idx$1 = str$2.indexOf("-");
  var match$1 = idx$1 !== -1 ? [
      str$2.slice(0, idx$1),
      str$2.slice(idx$1 + 1 | 0)
    ] : [
      str$2,
      undefined
    ];
  var parts = match$1[0].split(".");
  if (parts.length !== 3) {
    return ;
  }
  var major = Belt_Int.fromString(parts[0]);
  var minor = Belt_Int.fromString(parts[1]);
  var patch = Belt_Int.fromString(parts[2]);
  if (major !== undefined && minor !== undefined && patch !== undefined && !(major < 0 || minor < 0 || patch < 0)) {
    return {
            major: major,
            minor: minor,
            patch: patch,
            prerelease: match$1[1],
            buildMetadata: match[1]
          };
  }
  
}

function toString(v) {
  var base = String(v.major) + "." + String(v.minor) + "." + String(v.patch);
  var pre = v.prerelease;
  var withPre = pre !== undefined ? base + "-" + pre : base;
  var build = v.buildMetadata;
  if (build !== undefined) {
    return withPre + "+" + build;
  } else {
    return withPre;
  }
}

function comparePrerelease(a, b) {
  if (a !== undefined) {
    if (b !== undefined) {
      return a.localeCompare(b) | 0;
    } else {
      return -1;
    }
  } else if (b !== undefined) {
    return 1;
  } else {
    return 0;
  }
}

function compare(a, b) {
  if (a.major !== b.major) {
    if (a.major < b.major) {
      return -1;
    } else {
      return 1;
    }
  } else if (a.minor !== b.minor) {
    if (a.minor < b.minor) {
      return -1;
    } else {
      return 1;
    }
  } else if (a.patch !== b.patch) {
    if (a.patch < b.patch) {
      return -1;
    } else {
      return 1;
    }
  } else {
    return comparePrerelease(a.prerelease, b.prerelease);
  }
}

function lt(a, b) {
  return compare(a, b) < 0;
}

function lte(a, b) {
  return compare(a, b) <= 0;
}

function gt(a, b) {
  return compare(a, b) > 0;
}

function gte(a, b) {
  return compare(a, b) >= 0;
}

function eq(a, b) {
  return compare(a, b) === 0;
}

function incMajor(v) {
  return {
          major: v.major + 1 | 0,
          minor: 0,
          patch: 0,
          prerelease: undefined,
          buildMetadata: undefined
        };
}

function incMinor(v) {
  return {
          major: v.major,
          minor: v.minor + 1 | 0,
          patch: 0,
          prerelease: undefined,
          buildMetadata: undefined
        };
}

function incPatch(v) {
  return {
          major: v.major,
          minor: v.minor,
          patch: v.patch + 1 | 0,
          prerelease: undefined,
          buildMetadata: undefined
        };
}

function satisfies(v, versionConstraint) {
  var match = versionConstraint.op;
  switch (match) {
    case "Eq" :
        return eq(v, versionConstraint.version);
    case "Gt" :
        return gt(v, versionConstraint.version);
    case "Gte" :
        return gte(v, versionConstraint.version);
    case "Lt" :
        return lt(v, versionConstraint.version);
    case "Lte" :
        return lte(v, versionConstraint.version);
    case "Tilde" :
        if (gte(v, versionConstraint.version)) {
          return lt(v, {
                      major: versionConstraint.version.major,
                      minor: versionConstraint.version.minor + 1 | 0,
                      patch: 0,
                      prerelease: undefined,
                      buildMetadata: undefined
                    });
        } else {
          return false;
        }
    case "Caret" :
        if (versionConstraint.version.major > 0) {
          if (gte(v, versionConstraint.version)) {
            return lt(v, {
                        major: versionConstraint.version.major + 1 | 0,
                        minor: 0,
                        patch: 0,
                        prerelease: undefined,
                        buildMetadata: undefined
                      });
          } else {
            return false;
          }
        } else if (versionConstraint.version.minor > 0) {
          if (gte(v, versionConstraint.version)) {
            return lt(v, {
                        major: 0,
                        minor: versionConstraint.version.minor + 1 | 0,
                        patch: 0,
                        prerelease: undefined,
                        buildMetadata: undefined
                      });
          } else {
            return false;
          }
        } else if (gte(v, versionConstraint.version)) {
          return lt(v, {
                      major: 0,
                      minor: 0,
                      patch: versionConstraint.version.patch + 1 | 0,
                      prerelease: undefined,
                      buildMetadata: undefined
                    });
        } else {
          return false;
        }
    
  }
}

function isStable(v) {
  var match = v.prerelease;
  return match === undefined;
}

function isPrerelease(v) {
  return v.prerelease !== undefined;
}

function max(versions) {
  if (versions.length === 0) {
    return ;
  } else {
    return Belt_Array.reduce(versions, versions[0], (function (acc, v) {
                  if (gt(v, acc)) {
                    return v;
                  } else {
                    return acc;
                  }
                }));
  }
}

function min(versions) {
  if (versions.length === 0) {
    return ;
  } else {
    return Belt_Array.reduce(versions, versions[0], (function (acc, v) {
                  if (lt(v, acc)) {
                    return v;
                  } else {
                    return acc;
                  }
                }));
  }
}

function sort(versions) {
  var copy = versions.slice(0);
  Belt_SortArray.stableSortInPlaceBy(copy, compare);
  return copy;
}

export {
  make ,
  makeWithPrerelease ,
  makeFull ,
  parse ,
  toString ,
  comparePrerelease ,
  compare ,
  lt ,
  lte ,
  gt ,
  gte ,
  eq ,
  incMajor ,
  incMinor ,
  incPatch ,
  satisfies ,
  isStable ,
  isPrerelease ,
  max ,
  min ,
  sort ,
}
/* No side effect */
