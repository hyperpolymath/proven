// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

function makeTokenBucket(capacity, refillRate) {
  if (capacity <= 0.0) {
    return {
            TAG: "Error",
            _0: "Capacity must be positive"
          };
  } else if (refillRate <= 0.0) {
    return {
            TAG: "Error",
            _0: "Refill rate must be positive"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              capacity: capacity,
              tokens: capacity,
              refillRate: refillRate,
              lastRefill: 0.0
            }
          };
  }
}

function refillTokens(bucket, currentTime) {
  var elapsed = currentTime - bucket.lastRefill;
  if (elapsed <= 0.0) {
    return ;
  }
  var newTokens = bucket.refillRate * elapsed;
  bucket.tokens = Math.min(bucket.capacity, bucket.tokens + newTokens);
  bucket.lastRefill = currentTime;
}

function tryAcquire(bucket, count, currentTime) {
  refillTokens(bucket, currentTime);
  if (bucket.tokens >= count) {
    bucket.tokens = bucket.tokens - count;
    return "Allowed";
  }
  var needed = count - bucket.tokens;
  var waitTime = needed / bucket.refillRate;
  return {
          TAG: "Denied",
          retryAfter: waitTime
        };
}

function wouldAllowTokenBucket(bucket, count, currentTime) {
  var elapsed = currentTime - bucket.lastRefill;
  var projectedTokens = elapsed > 0.0 ? Math.min(bucket.capacity, bucket.tokens + bucket.refillRate * elapsed) : bucket.tokens;
  return projectedTokens >= count;
}

function currentTokens(bucket, currentTime) {
  var elapsed = currentTime - bucket.lastRefill;
  if (elapsed > 0.0) {
    return Math.min(bucket.capacity, bucket.tokens + bucket.refillRate * elapsed);
  } else {
    return bucket.tokens;
  }
}

function remainingCapacity(bucket, currentTime) {
  return currentTokens(bucket, currentTime);
}

function makeSlidingWindow(maxRequests, windowSize) {
  if (maxRequests <= 0) {
    return {
            TAG: "Error",
            _0: "Max requests must be positive"
          };
  } else if (windowSize <= 0.0) {
    return {
            TAG: "Error",
            _0: "Window size must be positive"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              maxRequests: maxRequests,
              windowSize: windowSize,
              requests: []
            }
          };
  }
}

function pruneRequests($$window, currentTime) {
  var cutoff = currentTime - $$window.windowSize;
  $$window.requests = Belt_Array.keep($$window.requests, (function (ts) {
          return ts >= cutoff;
        }));
}

function tryRequestSlidingWindow($$window, currentTime) {
  pruneRequests($$window, currentTime);
  if ($$window.requests.length < $$window.maxRequests) {
    $$window.requests.push(currentTime);
    return "Allowed";
  }
  var oldest = Belt_Array.reduce($$window.requests, currentTime, (function (acc, ts) {
          return Math.min(acc, ts);
        }));
  var retryAfter = $$window.windowSize - (currentTime - oldest);
  return {
          TAG: "Denied",
          retryAfter: Math.max(0.0, retryAfter)
        };
}

function currentCountSlidingWindow($$window, currentTime) {
  pruneRequests($$window, currentTime);
  return $$window.requests.length;
}

function remainingSlidingWindow($$window, currentTime) {
  pruneRequests($$window, currentTime);
  return $$window.maxRequests - $$window.requests.length | 0;
}

function makeFixedWindow(maxRequests, windowSize) {
  if (maxRequests <= 0) {
    return {
            TAG: "Error",
            _0: "Max requests must be positive"
          };
  } else if (windowSize <= 0.0) {
    return {
            TAG: "Error",
            _0: "Window size must be positive"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              maxRequests: maxRequests,
              windowSize: windowSize,
              windowStart: 0.0,
              count: 0
            }
          };
  }
}

function tryRequestFixedWindow($$window, currentTime) {
  var windowEnd = $$window.windowStart + $$window.windowSize;
  if (currentTime >= windowEnd) {
    $$window.windowStart = Math.floor(currentTime / $$window.windowSize) * $$window.windowSize;
    $$window.count = 0;
  }
  if ($$window.count < $$window.maxRequests) {
    $$window.count = $$window.count + 1 | 0;
    return "Allowed";
  }
  var retryAfter = $$window.windowStart + $$window.windowSize - currentTime;
  return {
          TAG: "Denied",
          retryAfter: Math.max(0.0, retryAfter)
        };
}

function currentCountFixedWindow($$window, currentTime) {
  var windowEnd = $$window.windowStart + $$window.windowSize;
  if (currentTime >= windowEnd) {
    return 0;
  } else {
    return $$window.count;
  }
}

function remainingFixedWindow($$window, currentTime) {
  var windowEnd = $$window.windowStart + $$window.windowSize;
  if (currentTime >= windowEnd) {
    return $$window.maxRequests;
  } else {
    return $$window.maxRequests - $$window.count | 0;
  }
}

function isAllowed(result) {
  if (typeof result !== "object") {
    return true;
  } else {
    return false;
  }
}

function getRetryAfter(result) {
  if (typeof result !== "object") {
    return ;
  } else {
    return result.retryAfter;
  }
}

function now() {
  return Date.now();
}

function resetTokenBucket(bucket) {
  bucket.tokens = bucket.capacity;
  bucket.lastRefill = 0.0;
}

function resetSlidingWindow($$window) {
  $$window.requests = [];
}

function resetFixedWindow($$window) {
  $$window.windowStart = 0.0;
  $$window.count = 0;
}

export {
  makeTokenBucket ,
  refillTokens ,
  tryAcquire ,
  wouldAllowTokenBucket ,
  currentTokens ,
  remainingCapacity ,
  makeSlidingWindow ,
  pruneRequests ,
  tryRequestSlidingWindow ,
  currentCountSlidingWindow ,
  remainingSlidingWindow ,
  makeFixedWindow ,
  tryRequestFixedWindow ,
  currentCountFixedWindow ,
  remainingFixedWindow ,
  isAllowed ,
  getRetryAfter ,
  now ,
  resetTokenBucket ,
  resetSlidingWindow ,
  resetFixedWindow ,
}
/* No side effect */
