// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Proven_Bitwise from "./Proven_Bitwise.res.js";

function positiveMod(a, m) {
  var result = Caml_int32.mod_(a, m);
  if (result < 0) {
    return result + m | 0;
  } else {
    return result;
  }
}

function makeFieldElement(value, modulus) {
  if (modulus <= 1) {
    return ;
  } else {
    return {
            value: positiveMod(value, modulus),
            modulus: modulus
          };
  }
}

function getValue(element) {
  return element.value;
}

function getModulus(element) {
  return element.modulus;
}

function equal(a, b) {
  if (a.modulus === b.modulus) {
    return a.value === b.value;
  } else {
    return false;
  }
}

function isZero(element) {
  return element.value === 0;
}

function isOne(element) {
  return element.value === 1;
}

function zero(modulus) {
  if (modulus <= 1) {
    return ;
  } else {
    return {
            value: 0,
            modulus: modulus
          };
  }
}

function one(modulus) {
  if (modulus <= 1) {
    return ;
  } else {
    return {
            value: 1,
            modulus: modulus
          };
  }
}

function add(a, b) {
  if (a.modulus !== b.modulus) {
    return ;
  }
  var sum = a.value + b.value | 0;
  return {
          value: positiveMod(sum, a.modulus),
          modulus: a.modulus
        };
}

function sub(a, b) {
  if (a.modulus !== b.modulus) {
    return ;
  }
  var diff = a.value - b.value | 0;
  return {
          value: positiveMod(diff, a.modulus),
          modulus: a.modulus
        };
}

function mul(a, b) {
  if (a.modulus !== b.modulus) {
    return ;
  }
  var product = Math.imul(a.value, b.value);
  return {
          value: positiveMod(product, a.modulus),
          modulus: a.modulus
        };
}

function negate(element) {
  if (element.value === 0) {
    return element;
  } else {
    return {
            value: element.modulus - element.value | 0,
            modulus: element.modulus
          };
  }
}

function extendedGcd(a, b) {
  var _oldR = a;
  var _r = b;
  var _oldS = 1;
  var _s = 0;
  var _oldT = 0;
  var _t = 1;
  while(true) {
    var t = _t;
    var oldT = _oldT;
    var s = _s;
    var oldS = _oldS;
    var r = _r;
    var oldR = _oldR;
    if (r === 0) {
      return {
              gcd: PervasivesU.abs(oldR),
              x: oldS,
              y: oldT
            };
    }
    var quotient = Caml_int32.div(oldR, r);
    _t = oldT - Math.imul(quotient, t) | 0;
    _oldT = t;
    _s = oldS - Math.imul(quotient, s) | 0;
    _oldS = s;
    _r = oldR - Math.imul(quotient, r) | 0;
    _oldR = r;
    continue ;
  };
}

function gcd(a, b) {
  var _x = a;
  var _y = b;
  while(true) {
    var y = _y;
    var x = _x;
    if (y === 0) {
      return PervasivesU.abs(x);
    }
    _y = Caml_int32.mod_(x, y);
    _x = y;
    continue ;
  };
}

function lcm(a, b) {
  if (a === 0 || b === 0) {
    return 0;
  }
  var g = gcd(a, b);
  var divResult = Caml_int32.div(a, g);
  var result = Math.imul(divResult, b);
  if (divResult !== 0 && Caml_int32.div(result, divResult) !== b) {
    return ;
  } else {
    return PervasivesU.abs(result);
  }
}

function coprime(a, b) {
  return gcd(a, b) === 1;
}

function modAdd(a, b, modulus) {
  if (modulus <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidModulus"
          };
  }
  var aMod = positiveMod(a, modulus);
  var bMod = positiveMod(b, modulus);
  return {
          TAG: "Ok",
          _0: positiveMod(aMod + bMod | 0, modulus)
        };
}

function modSub(a, b, modulus) {
  if (modulus <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidModulus"
          };
  }
  var aMod = positiveMod(a, modulus);
  var bMod = positiveMod(b, modulus);
  return {
          TAG: "Ok",
          _0: positiveMod(aMod - bMod | 0, modulus)
        };
}

function modMul(a, b, modulus) {
  if (modulus <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidModulus"
          };
  }
  var aMod = positiveMod(a, modulus);
  var bMod = positiveMod(b, modulus);
  return {
          TAG: "Ok",
          _0: positiveMod(Math.imul(aMod, bMod), modulus)
        };
}

function modPow(base, exponent, modulus) {
  if (modulus <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidModulus"
          };
  }
  if (modulus === 1) {
    return {
            TAG: "Ok",
            _0: 0
          };
  }
  if (exponent < 0) {
    return {
            TAG: "Error",
            _0: "InvalidModulus"
          };
  }
  if (exponent === 0) {
    return {
            TAG: "Ok",
            _0: 1
          };
  }
  var loop = function (_result, _b, _exp) {
    while(true) {
      var exp = _exp;
      var b = _b;
      var result = _result;
      if (exp <= 0) {
        return result;
      }
      var newResult = Proven_Bitwise.land(exp, 1) === 1 ? positiveMod(Math.imul(result, b), modulus) : result;
      _exp = Proven_Bitwise.lsr(exp, 1);
      _b = positiveMod(Math.imul(b, b), modulus);
      _result = newResult;
      continue ;
    };
  };
  return {
          TAG: "Ok",
          _0: loop(1, positiveMod(base, modulus), exponent)
        };
}

function modInverse(a, modulus) {
  if (modulus <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidModulus"
          };
  }
  if (a === 0) {
    return {
            TAG: "Error",
            _0: "DivisionByZero"
          };
  }
  var result = extendedGcd(positiveMod(a, modulus), modulus);
  if (result.gcd !== 1) {
    return {
            TAG: "Error",
            _0: "NoInverse"
          };
  } else {
    return {
            TAG: "Ok",
            _0: positiveMod(result.x, modulus)
          };
  }
}

function modDiv(a, b, modulus) {
  var e = modInverse(b, modulus);
  if (e.TAG === "Ok") {
    return modMul(a, e._0, modulus);
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function pow(element, exponent) {
  if (exponent < 0) {
    return ;
  }
  var result = modPow(element.value, exponent, element.modulus);
  if (result.TAG === "Ok") {
    return {
            value: result._0,
            modulus: element.modulus
          };
  }
  
}

function inverse(element) {
  var e = modInverse(element.value, element.modulus);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: {
              value: e._0,
              modulus: element.modulus
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function div(a, b) {
  if (a.modulus !== b.modulus) {
    return {
            TAG: "Error",
            _0: "InvalidModulus"
          };
  }
  var e = inverse(b);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = mul(a, e._0);
  if (result !== undefined) {
    return {
            TAG: "Ok",
            _0: result
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidModulus"
          };
  }
}

function f17(value) {
  return makeFieldElement(value, 17);
}

function f31(value) {
  return makeFieldElement(value, 31);
}

function f101(value) {
  return makeFieldElement(value, 101);
}

function f257(value) {
  return makeFieldElement(value, 257);
}

function f65537(value) {
  return makeFieldElement(value, 65537);
}

function isPrime(n) {
  if (n <= 1) {
    return false;
  }
  if (n <= 3) {
    return true;
  }
  if (n % 2 === 0 || n % 3 === 0) {
    return false;
  }
  var _i = 5;
  while(true) {
    var i = _i;
    if (Math.imul(i, i) > n) {
      return true;
    }
    if (Caml_int32.mod_(n, i) === 0 || Caml_int32.mod_(n, i + 2 | 0) === 0) {
      return false;
    }
    _i = i + 6 | 0;
    continue ;
  };
}

function eulerTotient(n) {
  if (n <= 0) {
    return ;
  }
  if (n === 1) {
    return 1;
  }
  var loop = function (_result, _n, _p) {
    while(true) {
      var p = _p;
      var n = _n;
      var result = _result;
      if (Math.imul(p, p) > n) {
        if (n > 1) {
          return Math.imul(result, n - 1 | 0);
        } else {
          return result;
        }
      }
      if (Caml_int32.mod_(n, p) === 0) {
        var divideOut = (function(p){
        return function divideOut(_n, _count) {
          while(true) {
            var count = _count;
            var n = _n;
            if (Caml_int32.mod_(n, p) !== 0) {
              return [
                      n,
                      count
                    ];
            }
            _count = count + 1 | 0;
            _n = Caml_int32.div(n, p);
            continue ;
          };
        }
        }(p));
        var match = divideOut(n, 0);
        var contribution = Math.imul(result, p - 1 | 0);
        var mulByP = (function(p){
        return function mulByP(_acc, _remaining) {
          while(true) {
            var remaining = _remaining;
            var acc = _acc;
            if (remaining <= 1) {
              return acc;
            }
            _remaining = remaining - 1 | 0;
            _acc = Math.imul(acc, p);
            continue ;
          };
        }
        }(p));
        _p = p + (
          p === 2 ? 1 : 2
        ) | 0;
        _n = match[0];
        _result = mulByP(contribution, 1);
        continue ;
      }
      _p = p + (
        p === 2 ? 1 : 2
      ) | 0;
      continue ;
    };
  };
  return loop(1, n, 2);
}

function toString(element) {
  return String(element.value) + " (mod " + String(element.modulus) + ")";
}

export {
  positiveMod ,
  makeFieldElement ,
  getValue ,
  getModulus ,
  equal ,
  isZero ,
  isOne ,
  zero ,
  one ,
  add ,
  sub ,
  mul ,
  negate ,
  extendedGcd ,
  gcd ,
  lcm ,
  coprime ,
  modAdd ,
  modSub ,
  modMul ,
  modPow ,
  modInverse ,
  modDiv ,
  pow ,
  inverse ,
  div ,
  f17 ,
  f31 ,
  f101 ,
  f257 ,
  f65537 ,
  isPrime ,
  eulerTotient ,
  toString ,
}
/* No side effect */
