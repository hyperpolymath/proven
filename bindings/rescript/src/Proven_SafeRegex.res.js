// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function isMetaChar(c) {
  switch (c) {
    case "$" :
    case "(" :
    case ")" :
    case "*" :
    case "+" :
    case "." :
    case "?" :
    case "[" :
    case "\\" :
    case "]" :
    case "^" :
    case "{" :
    case "|" :
    case "}" :
        return true;
    default:
      return false;
  }
}

function $$escape(input) {
  var result = "";
  var length = input.length;
  for(var i = 0; i < length; ++i){
    var c = input.charAt(i);
    if (isMetaChar(c)) {
      result = result + "\\";
    }
    result = result + c;
  }
  return result;
}

function parseQuantifierBounds(pattern) {
  var length = pattern.length;
  if (length < 3 || pattern.charAt(0) !== "{") {
    return ;
  }
  var minVal = 0;
  var maxVal = 0;
  var parsingMax = false;
  var valid = true;
  var i = 1;
  while(i < length && pattern.charAt(i) !== "}" && valid) {
    var c = pattern.charAt(i);
    if (c === ",") {
      parsingMax = true;
    } else {
      var code = c.charCodeAt(0);
      if (code >= 48.0 && code <= 57.0) {
        var digit = (code | 0) - 48 | 0;
        if (parsingMax) {
          maxVal = Math.imul(maxVal, 10) + digit | 0;
        } else {
          minVal = Math.imul(minVal, 10) + digit | 0;
        }
      } else {
        valid = false;
      }
    }
    i = i + 1 | 0;
  };
  if (!valid) {
    return ;
  }
  if (!parsingMax) {
    maxVal = minVal;
  }
  return {
          min: minVal,
          max: maxVal
        };
}

function analyzePattern(pattern) {
  var length = pattern.length;
  if (length > 1024) {
    return {
            TAG: "Error",
            _0: "PatternTooLong"
          };
  }
  var warnings = [];
  var complexity = 0;
  var maxDepth = 0;
  var currentDepth = 0;
  var hasNestedQuantifiers = false;
  var hasOverlappingAlternations = false;
  var inBracket = false;
  var prevWasQuantifier = false;
  var i = 0;
  var error;
  while(i < length && Belt_Option.isNone(error)) {
    var c = pattern.charAt(i);
    var exit = 0;
    switch (c) {
      case "(" :
          if (!inBracket) {
            currentDepth = currentDepth + 1 | 0;
            maxDepth = maxDepth > currentDepth ? maxDepth : currentDepth;
            if (currentDepth > 10) {
              error = "PatternTooComplex";
            }
            complexity = complexity + 2 | 0;
          }
          prevWasQuantifier = false;
          break;
      case ")" :
          if (!inBracket) {
            if (currentDepth === 0) {
              error = "UnbalancedParentheses";
            } else {
              currentDepth = currentDepth - 1 | 0;
            }
          }
          prevWasQuantifier = false;
          break;
      case "." :
          complexity = complexity + 2 | 0;
          prevWasQuantifier = false;
          break;
      case "*" :
      case "+" :
      case "?" :
          exit = 1;
          break;
      case "[" :
          if (!inBracket) {
            inBracket = true;
            complexity = complexity + 1 | 0;
          }
          prevWasQuantifier = false;
          break;
      case "\\" :
          if ((i + 1 | 0) >= length) {
            error = "InvalidEscape";
          } else {
            i = i + 1 | 0;
          }
          prevWasQuantifier = false;
          break;
      case "]" :
          if (inBracket) {
            inBracket = false;
          }
          prevWasQuantifier = false;
          break;
      case "{" :
          if (!inBracket) {
            var rest = pattern.slice(i);
            var bounds = parseQuantifierBounds(rest);
            if (bounds !== undefined) {
              if (bounds.max > 1000) {
                error = "PatternTooComplex";
              }
              complexity = complexity + (
                bounds.max < 100 ? bounds.max : 100
              ) | 0;
              if (prevWasQuantifier) {
                hasNestedQuantifiers = true;
              }
              prevWasQuantifier = true;
            }
            
          }
          break;
      case "|" :
          if (!inBracket) {
            complexity = complexity + 3 | 0;
            if (i > 0 && (i + 1 | 0) < length) {
              var prev = pattern.charAt(i - 1 | 0);
              var next = pattern.charAt(i + 1 | 0);
              if (prev === "|" || next === "|") {
                hasOverlappingAlternations = true;
              }
              
            }
            
          }
          prevWasQuantifier = false;
          break;
      default:
        complexity = complexity + 1 | 0;
        prevWasQuantifier = false;
    }
    if (exit === 1) {
      if (prevWasQuantifier) {
        hasNestedQuantifiers = true;
        warnings = warnings.concat([{
                position: i,
                message: "Nested quantifier detected - potential ReDoS"
              }]);
      }
      complexity = complexity + 5 | 0;
      prevWasQuantifier = true;
    }
    i = i + 1 | 0;
  };
  var e = error;
  if (e !== undefined) {
    return {
            TAG: "Error",
            _0: e
          };
  }
  if (currentDepth !== 0) {
    return {
            TAG: "Error",
            _0: "UnbalancedParentheses"
          };
  }
  if (inBracket) {
    return {
            TAG: "Error",
            _0: "UnbalancedBrackets"
          };
  }
  var estimatedStates = Math.imul(complexity, maxDepth + 1 | 0);
  var isSafe = !hasNestedQuantifiers && estimatedStates < 10000;
  return {
          TAG: "Ok",
          _0: {
            isSafe: isSafe,
            complexityScore: complexity,
            hasNestedQuantifiers: hasNestedQuantifiers,
            hasOverlappingAlternations: hasOverlappingAlternations,
            maxNestingDepth: maxDepth,
            estimatedStates: estimatedStates,
            warnings: warnings
          }
        };
}

function validatePattern(pattern) {
  var e = analyzePattern(pattern);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var analysis = e._0;
  if (analysis.isSafe) {
    return {
            TAG: "Ok",
            _0: {
              pattern: pattern,
              analysis: analysis
            }
          };
  } else if (analysis.hasNestedQuantifiers) {
    return {
            TAG: "Error",
            _0: "NestedQuantifiers"
          };
  } else {
    return {
            TAG: "Error",
            _0: "ExcessiveBacktracking"
          };
  }
}

function isSafePattern(pattern) {
  var match = validatePattern(pattern);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function literalPrefix(pattern) {
  var length = pattern.length;
  var endPos = 0;
  while(endPos < length && !isMetaChar(pattern.charAt(endPos))) {
    endPos = endPos + 1 | 0;
  };
  if (endPos === 0) {
    return ;
  } else {
    return pattern.slice(0, endPos);
  }
}

function matches(safePattern, input) {
  try {
    var regex = new RegExp(safePattern.pattern);
    return regex.test(input);
  }
  catch (exn){
    return false;
  }
}

function matchesFull(safePattern, input) {
  try {
    var anchoredPattern = "^" + safePattern.pattern + "$";
    var regex = new RegExp(anchoredPattern);
    return regex.test(input);
  }
  catch (exn){
    return false;
  }
}

function findFirst(safePattern, input) {
  try {
    var regex = new RegExp(safePattern.pattern);
    var result = regex.exec(input);
    if (result !== null) {
      return Caml_option.nullable_to_opt(Caml_array.get(result, 0));
    } else {
      return ;
    }
  }
  catch (exn){
    return ;
  }
}

function findAll(safePattern, input) {
  try {
    var regex = new RegExp(safePattern.pattern, "g");
    var matches = [];
    var done = false;
    while(!done) {
      var result = regex.exec(input);
      if (result !== null) {
        var m = Caml_array.get(result, 0);
        if (!(m == null)) {
          matches = matches.concat([m]);
        }
        
      } else {
        done = true;
      }
    };
    return matches;
  }
  catch (exn){
    return [];
  }
}

function replaceFirst(safePattern, input, replacement) {
  try {
    var regex = new RegExp(safePattern.pattern);
    return input.replace(regex, replacement);
  }
  catch (exn){
    return input;
  }
}

function replaceAll(safePattern, input, replacement) {
  try {
    var regex = new RegExp(safePattern.pattern, "g");
    return input.replace(regex, replacement);
  }
  catch (exn){
    return input;
  }
}

function split(safePattern, input) {
  try {
    var regex = new RegExp(safePattern.pattern);
    return input.split(regex).map(function (opt) {
                return Belt_Option.getWithDefault(opt, "");
              });
  }
  catch (exn){
    return [input];
  }
}

var CommonPatterns = {
  email: "^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$",
  ipv4: "^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$",
  uuid: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
  hexString: "^[0-9a-fA-F]+$",
  alphanumeric: "^[a-zA-Z0-9]+$",
  url: "^https?://[^\\s]+$",
  dateYmd: "^\\d{4}-\\d{2}-\\d{2}$",
  timeHms: "^\\d{2}:\\d{2}:\\d{2}$",
  positiveInt: "^[1-9]\\d*$",
  identifier: "^[a-zA-Z_][a-zA-Z0-9_]*$"
};

var examples = [
  "(a+)+",
  "(a|a)+",
  "(a|aa)+",
  "(.*a){x}",
  "([a-zA-Z]+)*"
];

function isDangerous(pattern) {
  var hasNestedQuantifier = /[*+?]\\s*[*+?]/.test(pattern) || /[*+]\\s*\\{/.test(pattern) || /\\)[*+?]\\)[*+?]/.test(pattern);
  var hasDangerousBackref = /\\(.*\\)\\1+/.test(pattern);
  if (hasNestedQuantifier) {
    return true;
  } else {
    return hasDangerousBackref;
  }
}

var DangerousPatterns = {
  examples: examples,
  isDangerous: isDangerous
};

var maxPatternLength = 1024;

var maxQuantifierBound = 1000;

var maxNestingDepth = 10;

export {
  maxPatternLength ,
  maxQuantifierBound ,
  maxNestingDepth ,
  isMetaChar ,
  $$escape ,
  parseQuantifierBounds ,
  analyzePattern ,
  validatePattern ,
  isSafePattern ,
  literalPrefix ,
  matches ,
  matchesFull ,
  findFirst ,
  findAll ,
  replaceFirst ,
  replaceAll ,
  split ,
  CommonPatterns ,
  DangerousPatterns ,
}
/* No side effect */
