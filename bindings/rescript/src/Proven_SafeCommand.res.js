// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_option from "rescript/lib/es6/caml_option.js";

var dangerousShellChars = [
  ";",
  "&",
  "|",
  "$",
  "`",
  "(",
  ")",
  "{",
  "}",
  "<",
  ">",
  "\n",
  "\r",
  "!",
  "#",
  "~"
];

var requiresQuotingChars = [
  " ",
  "\t",
  "\"",
  "'",
  "*",
  "?",
  "[",
  "]",
  "\\"
];

function isDangerousChar($$char) {
  return dangerousShellChars.includes($$char);
}

function requiresQuoting($$char) {
  if (dangerousShellChars.includes($$char)) {
    return true;
  } else {
    return requiresQuotingChars.includes($$char);
  }
}

function containsDangerousChars(input) {
  var chars = input.split("");
  return chars.some(function ($$char) {
              if (dangerousShellChars.includes($$char)) {
                return true;
              } else {
                return $$char === "\x00";
              }
            });
}

function containsNullByte(input) {
  return input.includes("\x00");
}

function hasPathTraversal(input) {
  return input.includes("..");
}

function validateCommandName(command) {
  var len = command.length;
  if (len === 0) {
    return {
            TAG: "Error",
            _0: "EmptyCommand"
          };
  } else if (len > 8192) {
    return {
            TAG: "Error",
            _0: "CommandTooLong"
          };
  } else if (command.includes("\x00")) {
    return {
            TAG: "Error",
            _0: "NullByteDetected"
          };
  } else if (containsDangerousChars(command)) {
    return {
            TAG: "Error",
            _0: "DangerousCharacter"
          };
  } else if (command.includes("..")) {
    return {
            TAG: "Error",
            _0: "PathTraversal"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function validateArgument(arg) {
  var len = arg.length;
  if (len > 4096) {
    return {
            TAG: "Error",
            _0: "InvalidArgument"
          };
  } else if (arg.includes("\x00")) {
    return {
            TAG: "Error",
            _0: "NullByteDetected"
          };
  } else if (containsDangerousChars(arg)) {
    return {
            TAG: "Error",
            _0: "DangerousCharacter"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function sanitizeForShell(input) {
  if (input.includes("\x00")) {
    return {
            TAG: "Error",
            _0: "NullByteDetected"
          };
  }
  var chars = input.split("");
  var sanitized = chars.map(function ($$char) {
        if (dangerousShellChars.includes($$char)) {
          return "_";
        } else if (requiresQuoting($$char)) {
          return "\\" + $$char;
        } else {
          return $$char;
        }
      });
  return {
          TAG: "Ok",
          _0: sanitized.join("")
        };
}

function quoteForShell(input) {
  if (input.includes("\x00")) {
    return {
            TAG: "Error",
            _0: "NullByteDetected"
          };
  }
  var chars = input.split("");
  var escaped = chars.map(function ($$char) {
        if ($$char === "'") {
          return "'\\''";
        } else {
          return $$char;
        }
      });
  return {
          TAG: "Ok",
          _0: "'" + escaped.join("") + "'"
        };
}

function validateArguments(args) {
  var results = args.map(validateArgument);
  var firstError = results.find(function (r) {
        if (r.TAG === "Ok") {
          return false;
        } else {
          return true;
        }
      });
  if (firstError !== undefined && firstError.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: firstError._0
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function buildSafeCommand(command, args) {
  var e = validateCommandName(command);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var e$1 = validateArguments(args);
  if (e$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
  var quotedArgs = args.map(function (arg) {
        var quoted = quoteForShell(arg);
        if (quoted.TAG === "Ok") {
          return quoted._0;
        } else {
          return "";
        }
      });
  var argString = quotedArgs.join(" ");
  if (argString.length > 0) {
    return {
            TAG: "Ok",
            _0: command + " " + argString
          };
  } else {
    return {
            TAG: "Ok",
            _0: command
          };
  }
}

function isAbsolutePath(path) {
  if (path.length > 0) {
    return path.charAt(0) === "/";
  } else {
    return false;
  }
}

function validateAbsoluteCommand(path) {
  if (isAbsolutePath(path)) {
    return validateCommandName(path);
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCommand"
          };
  }
}

function splitCommand(commandLine) {
  var trimmed = commandLine.trim();
  if (trimmed.length === 0) {
    return {
            TAG: "Error",
            _0: "EmptyCommand"
          };
  }
  if (trimmed.includes("\x00")) {
    return {
            TAG: "Error",
            _0: "NullByteDetected"
          };
  }
  var parts = trimmed.split(" ").filter(function (part) {
        return part.length > 0;
      });
  if (parts.length === 0) {
    return {
            TAG: "Error",
            _0: "EmptyCommand"
          };
  }
  var command = parts[0];
  var args = parts.slice(1);
  return {
          TAG: "Ok",
          _0: {
            command: command,
            args: args
          }
        };
}

function isCommandAllowed(command, allowedCommands) {
  return allowedCommands.some(function (allowed) {
              return allowed.name === command;
            });
}

function getAllowedCommandConfig(command, allowedCommands) {
  return Caml_option.undefined_to_opt(allowedCommands.find(function (allowed) {
                  return allowed.name === command;
                }));
}

function createAllowlist(commands) {
  return commands.map(function (name) {
              return {
                      name: name,
                      allowedArgsPatterns: undefined,
                      requireAbsolutePath: false
                    };
            });
}

var commonSafeCommands = createAllowlist([
      "ls",
      "cat",
      "head",
      "tail",
      "wc",
      "grep",
      "find",
      "which",
      "echo",
      "date",
      "pwd",
      "whoami"
    ]);

function validateAgainstAllowlist(command, allowedCommands) {
  if (isCommandAllowed(command, allowedCommands)) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCommand"
          };
  }
}

function escapeArgument(arg) {
  if (arg.includes("\x00")) {
    return {
            TAG: "Error",
            _0: "NullByteDetected"
          };
  } else {
    return {
            TAG: "Ok",
            _0: arg
          };
  }
}

function buildExecArgs(args) {
  if (args.some(containsNullByte)) {
    return {
            TAG: "Error",
            _0: "NullByteDetected"
          };
  } else {
    return {
            TAG: "Ok",
            _0: args
          };
  }
}

function looksLikeInjection(input) {
  var injectionPatterns = [
    "$(",
    "`",
    "&&",
    "||",
    ";",
    "|",
    ">",
    "<",
    "${",
    "$()"
  ];
  return injectionPatterns.some(function (pattern) {
              return input.includes(pattern);
            });
}

function sanitizeFilename(filename) {
  return filename.replace(/\\.\\./g, "_").replace(/[\\/\\\\]/g, "_").replace(/[\\x00-\\x1f]/g, "").replace(/[;|&$`<>(){}!#~]/g, "_");
}

function sanitizeEnvVarName(name) {
  if (name.length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidArgument"
          };
  }
  if (name.includes("\x00")) {
    return {
            TAG: "Error",
            _0: "NullByteDetected"
          };
  }
  var sanitized = name.replace(/[^a-zA-Z0-9_]/g, "_").replace(/^[0-9]/, "_$&");
  return {
          TAG: "Ok",
          _0: sanitized
        };
}

var maxCommandLength = 8192;

var maxArgumentLength = 4096;

export {
  maxCommandLength ,
  maxArgumentLength ,
  dangerousShellChars ,
  requiresQuotingChars ,
  isDangerousChar ,
  requiresQuoting ,
  containsDangerousChars ,
  containsNullByte ,
  hasPathTraversal ,
  validateCommandName ,
  validateArgument ,
  sanitizeForShell ,
  quoteForShell ,
  validateArguments ,
  buildSafeCommand ,
  isAbsolutePath ,
  validateAbsoluteCommand ,
  splitCommand ,
  isCommandAllowed ,
  getAllowedCommandConfig ,
  createAllowlist ,
  commonSafeCommands ,
  validateAgainstAllowlist ,
  escapeArgument ,
  buildExecArgs ,
  looksLikeInjection ,
  sanitizeFilename ,
  sanitizeEnvVarName ,
}
/* commonSafeCommands Not a pure module */
