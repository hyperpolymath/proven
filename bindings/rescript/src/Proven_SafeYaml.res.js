// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

var defaultParseOptions = {
  maxDepth: 32,
  maxSize: 1048576,
  allowAnchors: false,
  allowTags: false,
  strictIndentation: true
};

function isNullValue(input) {
  var trimmed = input.trim();
  if (trimmed.length === 0 || trimmed === "null" || trimmed === "Null" || trimmed === "NULL") {
    return true;
  } else {
    return trimmed === "~";
  }
}

function isBoolValue(input) {
  var trimmed = input.trim();
  switch (trimmed) {
    case "FALSE" :
    case "False" :
    case "NO" :
    case "No" :
    case "OFF" :
    case "ON" :
    case "Off" :
    case "On" :
    case "TRUE" :
    case "True" :
    case "YES" :
    case "Yes" :
    case "false" :
    case "no" :
    case "off" :
    case "on" :
    case "true" :
    case "yes" :
        return true;
    default:
      return false;
  }
}

function parseBool(input) {
  var trimmed = input.trim();
  switch (trimmed) {
    case "FALSE" :
    case "False" :
    case "NO" :
    case "No" :
    case "OFF" :
    case "Off" :
    case "false" :
    case "no" :
    case "off" :
        return false;
    case "ON" :
    case "On" :
    case "TRUE" :
    case "True" :
    case "YES" :
    case "Yes" :
    case "on" :
    case "true" :
    case "yes" :
        return true;
    default:
      return ;
  }
}

function isIntegerValue(input) {
  var trimmed = input.trim();
  if (trimmed.length === 0) {
    return false;
  }
  var match = Belt_Int.fromString(trimmed);
  if (match !== undefined) {
    return true;
  }
  if (trimmed.startsWith("0x") || trimmed.startsWith("0X")) {
    var hexPart = trimmed.slice(2);
    var value = parseInt(hexPart, 16);
    return !Number.isNaN(value);
  }
  if (!trimmed.startsWith("0o")) {
    return false;
  }
  var octPart = trimmed.slice(2);
  var value$1 = parseInt(octPart, 8);
  return !Number.isNaN(value$1);
}

function parseInteger(input) {
  var trimmed = input.trim();
  if (trimmed.length === 0) {
    return ;
  }
  var intValue = Belt_Int.fromString(trimmed);
  if (intValue !== undefined) {
    return intValue;
  }
  if (trimmed.startsWith("0x") || trimmed.startsWith("0X")) {
    var hexPart = trimmed.slice(2);
    var value = parseInt(hexPart, 16);
    if (!Number.isNaN(value)) {
      return value | 0;
    } else {
      return ;
    }
  }
  if (!trimmed.startsWith("0o")) {
    return ;
  }
  var octPart = trimmed.slice(2);
  var value$1 = parseInt(octPart, 8);
  if (!Number.isNaN(value$1)) {
    return value$1 | 0;
  }
  
}

function isFloatValue(input) {
  var trimmed = input.trim();
  if (trimmed.length === 0) {
    return false;
  }
  switch (trimmed) {
    case "-.INF" :
    case "-.Inf" :
    case "-.inf" :
    case ".INF" :
    case ".Inf" :
    case ".NAN" :
    case ".NaN" :
    case ".inf" :
    case ".nan" :
        return true;
    default:
      var value = Number(trimmed);
      return !Number.isNaN(value);
  }
}

function $$parseFloat(input) {
  var trimmed = input.trim();
  switch (trimmed) {
    case "-.INF" :
    case "-.Inf" :
    case "-.inf" :
        return PervasivesU.neg_infinity;
    case ".INF" :
    case ".Inf" :
    case ".inf" :
        return PervasivesU.infinity;
    case ".NAN" :
    case ".NaN" :
    case ".nan" :
        return NaN;
    default:
      var value = Number(trimmed);
      if (!Number.isNaN(value)) {
        return value;
      } else {
        return ;
      }
  }
}

function escapeString(input) {
  var needsQuoting = input.length === 0 || isNullValue(input) || isBoolValue(input) || isIntegerValue(input) || isFloatValue(input);
  var hasSpecialChars = input.includes(":") || input.includes("#") || input.includes("{") || input.includes("}") || input.includes("[") || input.includes("]") || input.includes(",") || input.includes("&") || input.includes("*") || input.includes("!") || input.includes("|") || input.includes(">") || input.includes("'") || input.includes("\"") || input.includes("%") || input.includes("@") || input.includes("`");
  var hasEscapeChars = input.includes("\n") || input.includes("\r") || input.includes("\t") || input.includes("\\");
  var hasLeadingOrTrailingSpace = input.length > 0 && (input.charAt(0) === " " || input.charAt(input.length - 1 | 0) === " ");
  if (!needsQuoting && !hasSpecialChars && !hasEscapeChars && !hasLeadingOrTrailingSpace) {
    return input;
  }
  var escaped = input.replace(/\\\\/g, "\\\\").replace(/\"/g, "\\\"").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
  return "\"" + escaped + "\"";
}

function unescapeString(input) {
  var trimmed = input.trim();
  if (trimmed.length === 0) {
    return "";
  }
  var isDoubleQuoted = trimmed.charAt(0) === "\"" && trimmed.length > 1 && trimmed.charAt(trimmed.length - 1 | 0) === "\"";
  var isSingleQuoted = trimmed.charAt(0) === "'" && trimmed.length > 1 && trimmed.charAt(trimmed.length - 1 | 0) === "'";
  if (isSingleQuoted) {
    var content = trimmed.slice(1, trimmed.length - 1 | 0);
    return content.replace(/''/g, "'");
  }
  if (!isDoubleQuoted) {
    return trimmed;
  }
  var content$1 = trimmed.slice(1, trimmed.length - 1 | 0);
  return content$1.replace(/\\\\n/g, "\n").replace(/\\\\r/g, "\r").replace(/\\\\t/g, "\t").replace(/\\\\\"/g, "\"").replace(/\\\\\\\\/g, "\\");
}

function isValidKey(key) {
  if (key.length === 0) {
    return false;
  }
  var firstChar = key.charAt(0);
  if (firstChar === "-" || firstChar === "?" || firstChar === ":" || firstChar === "[" || firstChar === "{" || key.includes("\n")) {
    return false;
  } else {
    return !key.includes("\r");
  }
}

function hasDangerousContent(input) {
  if (input.includes("&") || input.includes("*") || input.includes("!")) {
    return true;
  } else {
    return input.includes("%");
  }
}

function validateIndentation(input) {
  var lines = input.split("\n");
  var expectedIndent = {
    contents: undefined
  };
  var valid = {
    contents: true
  };
  var errorFound = {
    contents: undefined
  };
  Belt_Array.forEach(lines, (function (line) {
          if (!(valid.contents && line.length > 0)) {
            return ;
          }
          var spaceCount = 0;
          var hasTab = false;
          var lineLength = line.length;
          while(spaceCount < lineLength && valid.contents) {
            var currentChar = line.charAt(spaceCount);
            if (currentChar === " ") {
              spaceCount = spaceCount + 1 | 0;
            } else if (currentChar === "\t") {
              hasTab = true;
              valid.contents = false;
              errorFound.contents = "InvalidIndentation";
            }
            if (currentChar !== " " && currentChar !== "\t") {
              spaceCount = lineLength + 1 | 0;
            }
            
          };
          if (spaceCount > lineLength) {
            var count = 0;
            var done = false;
            var index = 0;
            while(index < lineLength && !done) {
              if (line.charAt(index) === " ") {
                count = count + 1 | 0;
                index = index + 1 | 0;
              } else {
                done = true;
              }
            };
            spaceCount = count;
          }
          if (!(!hasTab && spaceCount < lineLength)) {
            return ;
          }
          var firstNonSpace = line.charAt(spaceCount);
          if (firstNonSpace === "#") {
            return ;
          }
          var baseIndent = expectedIndent.contents;
          if (baseIndent !== undefined) {
            if (spaceCount > 0 && Caml_int32.mod_(spaceCount, baseIndent) !== 0) {
              valid.contents = false;
              errorFound.contents = "InvalidIndentation";
              return ;
            } else {
              return ;
            }
          } else if (spaceCount > 0) {
            expectedIndent.contents = spaceCount;
            return ;
          } else {
            return ;
          }
        }));
  var err = errorFound.contents;
  if (err !== undefined) {
    return {
            TAG: "Error",
            _0: err
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function calculateDepth(input) {
  var maxDepthFound = 0;
  var currentDepth = 0;
  var length = input.length;
  for(var index = 0; index < length; ++index){
    var currentChar = input.charAt(index);
    if (currentChar === "{" || currentChar === "[") {
      currentDepth = currentDepth + 1 | 0;
      if (currentDepth > maxDepthFound) {
        maxDepthFound = currentDepth;
      }
      
    } else if ((currentChar === "}" || currentChar === "]") && currentDepth > 0) {
      currentDepth = currentDepth - 1 | 0;
    }
    
  }
  return maxDepthFound;
}

function isValid(input, optionsOpt, param) {
  var options = optionsOpt !== undefined ? optionsOpt : defaultParseOptions;
  if (input.length > options.maxSize) {
    return false;
  }
  if (!options.allowAnchors && !options.allowTags && hasDangerousContent(input)) {
    return false;
  }
  if (calculateDepth(input) > options.maxDepth) {
    return false;
  }
  if (!options.strictIndentation) {
    return true;
  }
  var match = validateIndentation(input);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function asBool(value) {
  if (typeof value !== "object" || value.TAG !== "Boolean") {
    return ;
  } else {
    return value._0;
  }
}

function asInteger(value) {
  if (typeof value !== "object" || value.TAG !== "Integer") {
    return ;
  } else {
    return value._0;
  }
}

function asFloat(value) {
  if (typeof value !== "object") {
    return ;
  }
  switch (value.TAG) {
    case "Integer" :
    case "Float" :
        return value._0;
    default:
      return ;
  }
}

function asString(value) {
  if (typeof value !== "object" || value.TAG !== "String") {
    return ;
  } else {
    return value._0;
  }
}

function asSequence(value) {
  if (typeof value !== "object" || value.TAG !== "Sequence") {
    return ;
  } else {
    return value._0;
  }
}

function asMapping(value) {
  if (typeof value !== "object" || value.TAG !== "Mapping") {
    return ;
  } else {
    return value._0;
  }
}

function isNull(value) {
  if (typeof value !== "object") {
    return true;
  } else {
    return false;
  }
}

function get(value, key) {
  if (typeof value !== "object" || value.TAG !== "Mapping") {
    return ;
  } else {
    return Js_dict.get(value._0, key);
  }
}

function getPath(value, path) {
  var parts = path.split(".");
  return Belt_Array.reduce(parts, value, (function (acc, key) {
                if (acc === undefined) {
                  return ;
                }
                if (typeof acc !== "object") {
                  return ;
                }
                switch (acc.TAG) {
                  case "Sequence" :
                      var idx = Belt_Int.fromString(key);
                      if (idx !== undefined) {
                        return Belt_Array.get(acc._0, idx);
                      } else {
                        return ;
                      }
                  case "Mapping" :
                      return Js_dict.get(acc._0, key);
                  default:
                    return ;
                }
              }));
}

var maxDepth = 32;

var maxSize = 1048576;

export {
  maxDepth ,
  maxSize ,
  defaultParseOptions ,
  isNullValue ,
  isBoolValue ,
  parseBool ,
  isIntegerValue ,
  parseInteger ,
  isFloatValue ,
  $$parseFloat ,
  escapeString ,
  unescapeString ,
  isValidKey ,
  hasDangerousContent ,
  validateIndentation ,
  calculateDepth ,
  isValid ,
  asBool ,
  asInteger ,
  asFloat ,
  asString ,
  asSequence ,
  asMapping ,
  isNull ,
  get ,
  getPath ,
}
/* No side effect */
