// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Proven_Bitwise from "./Proven_Bitwise.res.js";

function wordCountForSize(size) {
  return ((size + 32 | 0) - 1 | 0) / 32 | 0;
}

function initEmpty(size) {
  var wordCount = wordCountForSize(size);
  return {
          words: Belt_Array.make(wordCount, 0),
          size: size,
          wordCount: wordCount
        };
}

function initFull(size) {
  var wordCount = wordCountForSize(size);
  var words = Belt_Array.make(wordCount, -1);
  var extraBits = size % 32;
  if (extraBits !== 0 && wordCount > 0) {
    var mask = Proven_Bitwise.lsl(1, extraBits) - 1 | 0;
    words[wordCount - 1 | 0] = mask;
  }
  return {
          words: words,
          size: size,
          wordCount: wordCount
        };
}

function capacity(bitset) {
  return bitset.size;
}

function wordAndBit(index) {
  var wordIndex = index / 32 | 0;
  var bitIndex = index % 32;
  var mask = Proven_Bitwise.lsl(1, bitIndex);
  return [
          wordIndex,
          mask
        ];
}

function set(bitset, index) {
  if (index < 0 || index >= bitset.size) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var match = wordAndBit(index);
  var wordIndex = match[0];
  var word = Belt_Array.get(bitset.words, wordIndex);
  if (word !== undefined) {
    bitset.words[wordIndex] = Proven_Bitwise.lor(word, match[1]);
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
}

function unset(bitset, index) {
  if (index < 0 || index >= bitset.size) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var match = wordAndBit(index);
  var wordIndex = match[0];
  var word = Belt_Array.get(bitset.words, wordIndex);
  if (word !== undefined) {
    bitset.words[wordIndex] = Proven_Bitwise.land(word, Proven_Bitwise.lnot(match[1]));
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
}

function toggle(bitset, index) {
  if (index < 0 || index >= bitset.size) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var match = wordAndBit(index);
  var wordIndex = match[0];
  var word = Belt_Array.get(bitset.words, wordIndex);
  if (word !== undefined) {
    bitset.words[wordIndex] = Proven_Bitwise.lxor(word, match[1]);
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
}

function isSet(bitset, index) {
  if (index < 0 || index >= bitset.size) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var match = wordAndBit(index);
  var word = Belt_Array.get(bitset.words, match[0]);
  if (word !== undefined) {
    return {
            TAG: "Ok",
            _0: Proven_Bitwise.land(word, match[1]) !== 0
          };
  } else {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
}

function get(bitset, index) {
  var v = isSet(bitset, index);
  if (v.TAG === "Ok") {
    return v._0;
  }
  
}

function put(bitset, index, value) {
  var result = value ? set(bitset, index) : unset(bitset, index);
  if (result.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function setRange(bitset, startIdx, endIdx) {
  if (startIdx > endIdx) {
    return {
            TAG: "Error",
            _0: "InvalidRange"
          };
  }
  if (endIdx > bitset.size) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  for(var i = startIdx; i < endIdx; ++i){
    set(bitset, i);
  }
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function unsetRange(bitset, startIdx, endIdx) {
  if (startIdx > endIdx) {
    return {
            TAG: "Error",
            _0: "InvalidRange"
          };
  }
  if (endIdx > bitset.size) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  for(var i = startIdx; i < endIdx; ++i){
    unset(bitset, i);
  }
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function count(bitset) {
  var total = {
    contents: 0
  };
  Belt_Array.forEach(bitset.words, (function (word) {
          var w = word;
          while(w !== 0) {
            w = Proven_Bitwise.land(w, w - 1 | 0);
            total.contents = total.contents + 1 | 0;
          };
        }));
  return total.contents;
}

function countZeros(bitset) {
  return bitset.size - count(bitset) | 0;
}

function isEmpty(bitset) {
  return Belt_Array.every(bitset.words, (function (word) {
                return word === 0;
              }));
}

function isFull(bitset) {
  return count(bitset) === bitset.size;
}

function any(bitset) {
  return !isEmpty(bitset);
}

function none(bitset) {
  return isEmpty(bitset);
}

function findFirstSet(bitset) {
  var result;
  var i = 0;
  while(result === undefined && i < bitset.wordCount) {
    var word = Belt_Array.get(bitset.words, i);
    if (word !== undefined && word !== 0) {
      for(var bit = 0; bit <= 31; ++bit){
        if (result === undefined) {
          var bitIdx = (i << 5) + bit | 0;
          if (bitIdx < bitset.size && Proven_Bitwise.land(word, Proven_Bitwise.lsl(1, bit)) !== 0) {
            result = bitIdx;
          }
          
        }
        
      }
    }
    i = i + 1 | 0;
  };
  return result;
}

function findLastSet(bitset) {
  var result;
  var i = bitset.wordCount - 1 | 0;
  while(result === undefined && i >= 0) {
    var word = Belt_Array.get(bitset.words, i);
    if (word !== undefined && word !== 0) {
      for(var bit = 31; bit >= 0; --bit){
        if (result === undefined) {
          var bitIdx = (i << 5) + bit | 0;
          if (bitIdx < bitset.size && Proven_Bitwise.land(word, Proven_Bitwise.lsl(1, bit)) !== 0) {
            result = bitIdx;
          }
          
        }
        
      }
    }
    i = i - 1 | 0;
  };
  return result;
}

function findFirstUnset(bitset) {
  var result;
  for(var i = 0 ,i_finish = bitset.size; i < i_finish; ++i){
    if (result === undefined) {
      var match = get(bitset, i);
      if (match !== undefined && !match) {
        result = i;
      }
      
    }
    
  }
  return result;
}

function clear(bitset) {
  for(var i = 0 ,i_finish = bitset.wordCount; i < i_finish; ++i){
    bitset.words[i] = 0;
  }
}

function fill(bitset) {
  for(var i = 0 ,i_finish = bitset.wordCount; i < i_finish; ++i){
    bitset.words[i] = -1;
  }
  var extraBits = bitset.size % 32;
  if (!(extraBits !== 0 && bitset.wordCount > 0)) {
    return ;
  }
  var mask = Proven_Bitwise.lsl(1, extraBits) - 1 | 0;
  bitset.words[bitset.wordCount - 1 | 0] = mask;
}

function complement(bitset) {
  for(var i = 0 ,i_finish = bitset.wordCount; i < i_finish; ++i){
    var word = Belt_Array.get(bitset.words, i);
    if (word !== undefined) {
      bitset.words[i] = Proven_Bitwise.lnot(word);
    }
    
  }
  var extraBits = bitset.size % 32;
  if (!(extraBits !== 0 && bitset.wordCount > 0)) {
    return ;
  }
  var mask = Proven_Bitwise.lsl(1, extraBits) - 1 | 0;
  var word$1 = Belt_Array.get(bitset.words, bitset.wordCount - 1 | 0);
  if (word$1 !== undefined) {
    bitset.words[bitset.wordCount - 1 | 0] = Proven_Bitwise.land(word$1, mask);
    return ;
  }
  
}

function setIntersection(bitset, other) {
  if (bitset.size !== other.size) {
    return {
            TAG: "Error",
            _0: "SizeMismatch"
          };
  }
  for(var i = 0 ,i_finish = bitset.wordCount; i < i_finish; ++i){
    var match = Belt_Array.get(bitset.words, i);
    var match$1 = Belt_Array.get(other.words, i);
    if (match !== undefined && match$1 !== undefined) {
      bitset.words[i] = Proven_Bitwise.land(match, match$1);
    }
    
  }
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function setUnion(bitset, other) {
  if (bitset.size !== other.size) {
    return {
            TAG: "Error",
            _0: "SizeMismatch"
          };
  }
  for(var i = 0 ,i_finish = bitset.wordCount; i < i_finish; ++i){
    var match = Belt_Array.get(bitset.words, i);
    var match$1 = Belt_Array.get(other.words, i);
    if (match !== undefined && match$1 !== undefined) {
      bitset.words[i] = Proven_Bitwise.lor(match, match$1);
    }
    
  }
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function setXor(bitset, other) {
  if (bitset.size !== other.size) {
    return {
            TAG: "Error",
            _0: "SizeMismatch"
          };
  }
  for(var i = 0 ,i_finish = bitset.wordCount; i < i_finish; ++i){
    var match = Belt_Array.get(bitset.words, i);
    var match$1 = Belt_Array.get(other.words, i);
    if (match !== undefined && match$1 !== undefined) {
      bitset.words[i] = Proven_Bitwise.lxor(match, match$1);
    }
    
  }
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function setDifference(bitset, other) {
  if (bitset.size !== other.size) {
    return {
            TAG: "Error",
            _0: "SizeMismatch"
          };
  }
  for(var i = 0 ,i_finish = bitset.wordCount; i < i_finish; ++i){
    var match = Belt_Array.get(bitset.words, i);
    var match$1 = Belt_Array.get(other.words, i);
    if (match !== undefined && match$1 !== undefined) {
      bitset.words[i] = Proven_Bitwise.land(match, Proven_Bitwise.lnot(match$1));
    }
    
  }
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function equals(bitset, other) {
  if (bitset.size !== other.size) {
    return false;
  } else {
    return Belt_Array.every(Belt_Array.zip(bitset.words, other.words), (function (param) {
                  return param[0] === param[1];
                }));
  }
}

function isSubsetOf(bitset, other) {
  if (bitset.size !== other.size) {
    return false;
  }
  var result = true;
  for(var i = 0 ,i_finish = bitset.wordCount; i < i_finish; ++i){
    if (result) {
      var match = Belt_Array.get(bitset.words, i);
      var match$1 = Belt_Array.get(other.words, i);
      if (!(match !== undefined && match$1 !== undefined && Proven_Bitwise.land(match, Proven_Bitwise.lnot(match$1)) === 0)) {
        result = false;
      }
      
    }
    
  }
  return result;
}

function isSupersetOf(bitset, other) {
  return isSubsetOf(other, bitset);
}

function isDisjoint(bitset, other) {
  if (bitset.size !== other.size) {
    return true;
  }
  var result = true;
  for(var i = 0 ,i_finish = bitset.wordCount; i < i_finish; ++i){
    if (result) {
      var match = Belt_Array.get(bitset.words, i);
      var match$1 = Belt_Array.get(other.words, i);
      if (match !== undefined && match$1 !== undefined && Proven_Bitwise.land(match, match$1) !== 0) {
        result = false;
      }
      
    }
    
  }
  return result;
}

function clone(bitset) {
  return {
          words: bitset.words.slice(0),
          size: bitset.size,
          wordCount: bitset.wordCount
        };
}

function intersection(a, b) {
  if (a.size !== b.size) {
    return ;
  }
  var result = clone(a);
  var match = setIntersection(result, b);
  if (match.TAG === "Ok") {
    return result;
  }
  
}

function union(a, b) {
  if (a.size !== b.size) {
    return ;
  }
  var result = clone(a);
  var match = setUnion(result, b);
  if (match.TAG === "Ok") {
    return result;
  }
  
}

function xorWith(a, b) {
  if (a.size !== b.size) {
    return ;
  }
  var result = clone(a);
  var match = setXor(result, b);
  if (match.TAG === "Ok") {
    return result;
  }
  
}

function difference(a, b) {
  if (a.size !== b.size) {
    return ;
  }
  var result = clone(a);
  var match = setDifference(result, b);
  if (match.TAG === "Ok") {
    return result;
  }
  
}

function toIndexArray(bitset) {
  var result = [];
  for(var i = 0 ,i_finish = bitset.size; i < i_finish; ++i){
    var match = get(bitset, i);
    if (match !== undefined && match) {
      result = Belt_Array.concat(result, [i]);
    }
    
  }
  return result;
}

function fromIndices(size, indices) {
  var bitset = initEmpty(size);
  var error = {
    contents: undefined
  };
  Belt_Array.forEach(indices, (function (index) {
          if (error.contents !== undefined) {
            return ;
          }
          var e = set(bitset, index);
          if (e.TAG === "Ok") {
            return ;
          } else {
            error.contents = e._0;
            return ;
          }
        }));
  var e = error.contents;
  if (e !== undefined) {
    return {
            TAG: "Error",
            _0: e
          };
  } else {
    return {
            TAG: "Ok",
            _0: bitset
          };
  }
}

function hammingDistance(a, b) {
  var xored = xorWith(a, b);
  if (xored !== undefined) {
    return count(xored);
  }
  
}

function jaccardSimilarity(a, b) {
  var match = intersection(a, b);
  var match$1 = union(a, b);
  if (match === undefined) {
    return ;
  }
  if (match$1 === undefined) {
    return ;
  }
  var intersectCount = count(match);
  var unionCount = count(match$1);
  if (unionCount === 0) {
    return 1.0;
  } else {
    return intersectCount / unionCount;
  }
}

function forEach(bitset, f) {
  for(var i = 0 ,i_finish = bitset.size; i < i_finish; ++i){
    var match = get(bitset, i);
    if (match !== undefined && match) {
      f(i);
    }
    
  }
}

function mapIndices(bitset, f) {
  var result = {
    contents: []
  };
  forEach(bitset, (function (i) {
          result.contents = Belt_Array.concat(result.contents, [f(i)]);
        }));
  return result.contents;
}

function filterIndices(bitset, predicate) {
  var result = {
    contents: []
  };
  forEach(bitset, (function (i) {
          if (predicate(i)) {
            result.contents = Belt_Array.concat(result.contents, [i]);
            return ;
          }
          
        }));
  return result.contents;
}

function foldIndices(bitset, init, f) {
  var acc = {
    contents: init
  };
  forEach(bitset, (function (i) {
          acc.contents = f(acc.contents, i);
        }));
  return acc.contents;
}

var bitsPerWord = 32;

export {
  bitsPerWord ,
  wordCountForSize ,
  initEmpty ,
  initFull ,
  capacity ,
  wordAndBit ,
  set ,
  unset ,
  toggle ,
  isSet ,
  get ,
  put ,
  setRange ,
  unsetRange ,
  count ,
  countZeros ,
  isEmpty ,
  isFull ,
  any ,
  none ,
  findFirstSet ,
  findLastSet ,
  findFirstUnset ,
  clear ,
  fill ,
  complement ,
  setIntersection ,
  setUnion ,
  setXor ,
  setDifference ,
  equals ,
  isSubsetOf ,
  isSupersetOf ,
  isDisjoint ,
  clone ,
  intersection ,
  union ,
  xorWith ,
  difference ,
  toIndexArray ,
  fromIndices ,
  hammingDistance ,
  jaccardSimilarity ,
  forEach ,
  mapIndices ,
  filterIndices ,
  foldIndices ,
}
/* No side effect */
