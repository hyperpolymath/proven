// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Proven_Bitwise from "./Proven_Bitwise.res.js";

var standardAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

var urlSafeAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

function getAlphabet(v) {
  switch (v) {
    case "Standard" :
    case "StandardNoPad" :
        return standardAlphabet;
    case "UrlSafe" :
    case "UrlSafeNoPad" :
        return urlSafeAlphabet;
    
  }
}

function usesPadding(v) {
  switch (v) {
    case "Standard" :
    case "UrlSafe" :
        return true;
    case "StandardNoPad" :
    case "UrlSafeNoPad" :
        return false;
    
  }
}

function calcEncodedLen(inputLen, withPadding) {
  if (inputLen === 0) {
    return 0;
  }
  if (withPadding) {
    return (((inputLen + 2 | 0) / 3 | 0) << 2);
  }
  var fullGroups = inputLen / 3 | 0;
  var remainder = inputLen % 3;
  var extraChars;
  switch (remainder) {
    case 1 :
        extraChars = 2;
        break;
    case 2 :
        extraChars = 3;
        break;
    default:
      extraChars = 0;
  }
  return (fullGroups << 2) + extraChars | 0;
}

function calcDecodedLenMax(encodedLen) {
  if (encodedLen === 0) {
    return 0;
  }
  var fullGroups = encodedLen / 4 | 0;
  var remainder = encodedLen % 4;
  var extraBytes = remainder > 2 || remainder < 0 ? (
      remainder !== 3 ? 0 : 2
    ) : (
      remainder >= 2 ? 1 : 0
    );
  return Math.imul(fullGroups, 3) + extraBytes | 0;
}

function charToIndex($$char, alphabet) {
  return alphabet.indexOf($$char);
}

function indexToChar(index, alphabet) {
  return alphabet.charAt(index);
}

function encodeBytes(bytes, variant) {
  var inputLen = bytes.length;
  if (inputLen === 0) {
    return {
            TAG: "Ok",
            _0: ""
          };
  }
  var alphabet = getAlphabet(variant);
  var withPadding = usesPadding(variant);
  var result = "";
  var valid = {
    contents: true
  };
  Belt_Array.forEach(bytes, (function (b) {
          if (b < 0 || b > 255) {
            valid.contents = false;
            return ;
          }
          
        }));
  if (!valid.contents) {
    return {
            TAG: "Error",
            _0: "InvalidCharacter"
          };
  }
  var i = 0;
  while((i + 3 | 0) <= inputLen) {
    var b0 = bytes[i];
    var b1 = bytes[i + 1 | 0];
    var b2 = bytes[i + 2 | 0];
    var c0 = Proven_Bitwise.lsr(b0, 2);
    var c1 = Proven_Bitwise.lor(Proven_Bitwise.lsl(Proven_Bitwise.land(b0, 3), 4), Proven_Bitwise.lsr(b1, 4));
    var c2 = Proven_Bitwise.lor(Proven_Bitwise.lsl(Proven_Bitwise.land(b1, 15), 2), Proven_Bitwise.lsr(b2, 6));
    var c3 = Proven_Bitwise.land(b2, 63);
    result = result + alphabet.charAt(c0) + alphabet.charAt(c1) + alphabet.charAt(c2) + alphabet.charAt(c3);
    i = i + 3 | 0;
  };
  var remainder = inputLen - i | 0;
  if (remainder === 1) {
    var b0$1 = bytes[i];
    var c0$1 = Proven_Bitwise.lsr(b0$1, 2);
    var c1$1 = Proven_Bitwise.lsl(Proven_Bitwise.land(b0$1, 3), 4);
    result = result + alphabet.charAt(c0$1) + alphabet.charAt(c1$1);
    if (withPadding) {
      result = result + "==";
    }
    
  } else if (remainder === 2) {
    var b0$2 = bytes[i];
    var b1$1 = bytes[i + 1 | 0];
    var c0$2 = Proven_Bitwise.lsr(b0$2, 2);
    var c1$2 = Proven_Bitwise.lor(Proven_Bitwise.lsl(Proven_Bitwise.land(b0$2, 3), 4), Proven_Bitwise.lsr(b1$1, 4));
    var c2$1 = Proven_Bitwise.lsl(Proven_Bitwise.land(b1$1, 15), 2);
    result = result + alphabet.charAt(c0$2) + alphabet.charAt(c1$2) + alphabet.charAt(c2$1);
    if (withPadding) {
      result = result + "=";
    }
    
  }
  return {
          TAG: "Ok",
          _0: result
        };
}

function encode(input, variant) {
  var length = input.length;
  if (length === 0) {
    return {
            TAG: "Ok",
            _0: ""
          };
  }
  var bytes = Belt_Array.make(length, 0);
  var valid = true;
  for(var i = 0; i < length; ++i){
    if (valid) {
      var code = input.charCodeAt(i) | 0;
      if (code > 255) {
        valid = false;
      } else {
        bytes[i] = code;
      }
    }
    
  }
  if (valid) {
    return encodeBytes(bytes, variant);
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCharacter"
          };
  }
}

function decodeToBytes(input, variant) {
  var trimmed = input.trim();
  var inputLen = trimmed.length;
  if (inputLen === 0) {
    return {
            TAG: "Ok",
            _0: []
          };
  }
  var alphabet = getAlphabet(variant);
  var withPadding = usesPadding(variant);
  var paddingCount = 0;
  var effectiveLen = inputLen;
  if (withPadding) {
    while(effectiveLen > 0 && trimmed.charAt(effectiveLen - 1 | 0) === "=") {
      paddingCount = paddingCount + 1 | 0;
      effectiveLen = effectiveLen - 1 | 0;
    };
    if (paddingCount > 2) {
      return {
              TAG: "Error",
              _0: "InvalidPadding"
            };
    }
    if (inputLen % 4 !== 0) {
      return {
              TAG: "Error",
              _0: "InvalidLength"
            };
    }
    var fullGroups = effectiveLen / 4 | 0;
    var remainder = effectiveLen % 4;
    var tmp;
    switch (remainder) {
      case 0 :
          tmp = paddingCount > 0 && fullGroups > 0 ? -paddingCount | 0 : 0;
          break;
      case 2 :
          tmp = 1;
          break;
      case 3 :
          tmp = 2;
          break;
      default:
        tmp = 0;
    }
    var outputLen = Math.imul(fullGroups, 3) + tmp | 0;
    var result = Belt_Array.make(0 > outputLen ? 0 : outputLen, 0);
    var outIdx = 0;
    var valid = true;
    var i = 0;
    while((i + 4 | 0) <= effectiveLen && valid) {
      var c0 = alphabet.indexOf(trimmed.charAt(i));
      var c1 = alphabet.indexOf(trimmed.charAt(i + 1 | 0));
      var c2 = alphabet.indexOf(trimmed.charAt(i + 2 | 0));
      var c3 = alphabet.indexOf(trimmed.charAt(i + 3 | 0));
      if (c0 < 0 || c1 < 0 || c2 < 0 || c3 < 0) {
        valid = false;
      } else {
        result[outIdx] = Proven_Bitwise.lor(Proven_Bitwise.lsl(c0, 2), Proven_Bitwise.lsr(c1, 4));
        result[outIdx + 1 | 0] = Proven_Bitwise.lor(Proven_Bitwise.lsl(Proven_Bitwise.land(c1, 15), 4), Proven_Bitwise.lsr(c2, 2));
        result[outIdx + 2 | 0] = Proven_Bitwise.lor(Proven_Bitwise.lsl(Proven_Bitwise.land(c2, 3), 6), c3);
        outIdx = outIdx + 3 | 0;
      }
      i = i + 4 | 0;
    };
    var remaining = effectiveLen - i | 0;
    if (valid && remaining === 2) {
      var c0$1 = alphabet.indexOf(trimmed.charAt(i));
      var c1$1 = alphabet.indexOf(trimmed.charAt(i + 1 | 0));
      if (c0$1 < 0 || c1$1 < 0) {
        valid = false;
      } else {
        result[outIdx] = Proven_Bitwise.lor(Proven_Bitwise.lsl(c0$1, 2), Proven_Bitwise.lsr(c1$1, 4));
      }
    } else if (valid && remaining === 3) {
      var c0$2 = alphabet.indexOf(trimmed.charAt(i));
      var c1$2 = alphabet.indexOf(trimmed.charAt(i + 1 | 0));
      var c2$1 = alphabet.indexOf(trimmed.charAt(i + 2 | 0));
      if (c0$2 < 0 || c1$2 < 0 || c2$1 < 0) {
        valid = false;
      } else {
        result[outIdx] = Proven_Bitwise.lor(Proven_Bitwise.lsl(c0$2, 2), Proven_Bitwise.lsr(c1$2, 4));
        result[outIdx + 1 | 0] = Proven_Bitwise.lor(Proven_Bitwise.lsl(Proven_Bitwise.land(c1$2, 15), 4), Proven_Bitwise.lsr(c2$1, 2));
      }
    } else if (remaining === 1) {
      valid = false;
    }
    if (valid) {
      return {
              TAG: "Ok",
              _0: result
            };
    } else {
      return {
              TAG: "Error",
              _0: "InvalidCharacter"
            };
    }
  }
  var remainder$1 = inputLen % 4;
  if (remainder$1 === 1) {
    return {
            TAG: "Error",
            _0: "InvalidLength"
          };
  }
  var fullGroups$1 = inputLen / 4 | 0;
  var tmp$1;
  switch (remainder$1) {
    case 2 :
        tmp$1 = 1;
        break;
    case 3 :
        tmp$1 = 2;
        break;
    default:
      tmp$1 = 0;
  }
  var outputLen$1 = Math.imul(fullGroups$1, 3) + tmp$1 | 0;
  var result$1 = Belt_Array.make(outputLen$1, 0);
  var outIdx$1 = 0;
  var valid$1 = true;
  var i$1 = 0;
  while((i$1 + 4 | 0) <= inputLen && valid$1) {
    var c0$3 = alphabet.indexOf(trimmed.charAt(i$1));
    var c1$3 = alphabet.indexOf(trimmed.charAt(i$1 + 1 | 0));
    var c2$2 = alphabet.indexOf(trimmed.charAt(i$1 + 2 | 0));
    var c3$1 = alphabet.indexOf(trimmed.charAt(i$1 + 3 | 0));
    if (c0$3 < 0 || c1$3 < 0 || c2$2 < 0 || c3$1 < 0) {
      valid$1 = false;
    } else {
      result$1[outIdx$1] = Proven_Bitwise.lor(Proven_Bitwise.lsl(c0$3, 2), Proven_Bitwise.lsr(c1$3, 4));
      result$1[outIdx$1 + 1 | 0] = Proven_Bitwise.lor(Proven_Bitwise.lsl(Proven_Bitwise.land(c1$3, 15), 4), Proven_Bitwise.lsr(c2$2, 2));
      result$1[outIdx$1 + 2 | 0] = Proven_Bitwise.lor(Proven_Bitwise.lsl(Proven_Bitwise.land(c2$2, 3), 6), c3$1);
      outIdx$1 = outIdx$1 + 3 | 0;
    }
    i$1 = i$1 + 4 | 0;
  };
  var remaining$1 = inputLen - i$1 | 0;
  if (valid$1 && remaining$1 === 2) {
    var c0$4 = alphabet.indexOf(trimmed.charAt(i$1));
    var c1$4 = alphabet.indexOf(trimmed.charAt(i$1 + 1 | 0));
    if (c0$4 < 0 || c1$4 < 0) {
      valid$1 = false;
    } else {
      result$1[outIdx$1] = Proven_Bitwise.lor(Proven_Bitwise.lsl(c0$4, 2), Proven_Bitwise.lsr(c1$4, 4));
    }
  } else if (valid$1 && remaining$1 === 3) {
    var c0$5 = alphabet.indexOf(trimmed.charAt(i$1));
    var c1$5 = alphabet.indexOf(trimmed.charAt(i$1 + 1 | 0));
    var c2$3 = alphabet.indexOf(trimmed.charAt(i$1 + 2 | 0));
    if (c0$5 < 0 || c1$5 < 0 || c2$3 < 0) {
      valid$1 = false;
    } else {
      result$1[outIdx$1] = Proven_Bitwise.lor(Proven_Bitwise.lsl(c0$5, 2), Proven_Bitwise.lsr(c1$5, 4));
      result$1[outIdx$1 + 1 | 0] = Proven_Bitwise.lor(Proven_Bitwise.lsl(Proven_Bitwise.land(c1$5, 15), 4), Proven_Bitwise.lsr(c2$3, 2));
    }
  }
  if (valid$1) {
    return {
            TAG: "Ok",
            _0: result$1
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidCharacter"
          };
  }
}

function decode(input, variant) {
  var e = decodeToBytes(input, variant);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = {
    contents: ""
  };
  Belt_Array.forEach(e._0, (function (b) {
          result.contents = result.contents + String.fromCharCode(b);
        }));
  return {
          TAG: "Ok",
          _0: result.contents
        };
}

function isValid(input, variant) {
  var trimmed = input.trim();
  var length = trimmed.length;
  if (length === 0) {
    return true;
  }
  var alphabet = getAlphabet(variant);
  var withPadding = usesPadding(variant);
  if (withPadding && length % 4 !== 0) {
    return false;
  }
  var valid = true;
  var paddingStarted = false;
  for(var i = 0; i < length; ++i){
    if (valid) {
      var $$char = trimmed.charAt(i);
      if ($$char === "=") {
        if (withPadding) {
          paddingStarted = true;
        } else {
          valid = false;
        }
      } else if (paddingStarted || alphabet.indexOf($$char) < 0) {
        valid = false;
      }
      
    }
    
  }
  if (valid && withPadding && paddingStarted) {
    var padCount = 0;
    var idx = length;
    while(idx > 0 && trimmed.charAt(idx - 1 | 0) === "=") {
      padCount = padCount + 1 | 0;
      idx = idx - 1 | 0;
    };
    if (padCount > 2) {
      valid = false;
    }
    
  }
  return valid;
}

function isValidChar($$char, variant) {
  if ($$char === "=") {
    return usesPadding(variant);
  }
  var alphabet = getAlphabet(variant);
  return alphabet.indexOf($$char) >= 0;
}

function convert(input, from, to) {
  var e = decodeToBytes(input, from);
  if (e.TAG === "Ok") {
    return encodeBytes(e._0, to);
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function stripWhitespace(input) {
  return input.replace(/\\s/g, "");
}

function encodeStandard(input) {
  return encode(input, "Standard");
}

function decodeStandard(input) {
  return decode(input, "Standard");
}

function encodeUrlSafe(input) {
  return encode(input, "UrlSafeNoPad");
}

function decodeUrlSafe(input) {
  return decode(input, "UrlSafeNoPad");
}

function errorToString(err) {
  switch (err) {
    case "InvalidCharacter" :
        return "Invalid character in Base64 string";
    case "InvalidPadding" :
        return "Invalid padding in Base64 string";
    case "InvalidLength" :
        return "Invalid length for Base64 string";
    case "BufferTooSmall" :
        return "Buffer too small for operation";
    
  }
}

var padChar = "=";

export {
  standardAlphabet ,
  urlSafeAlphabet ,
  padChar ,
  getAlphabet ,
  usesPadding ,
  calcEncodedLen ,
  calcDecodedLenMax ,
  charToIndex ,
  indexToChar ,
  encodeBytes ,
  encode ,
  decodeToBytes ,
  decode ,
  isValid ,
  isValidChar ,
  convert ,
  stripWhitespace ,
  encodeStandard ,
  decodeStandard ,
  encodeUrlSafe ,
  decodeUrlSafe ,
  errorToString ,
}
/* No side effect */
