// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function errorToString(error) {
  if (error === "InvalidCapacity") {
    return "Invalid cache capacity";
  } else {
    return "Key not found in cache";
  }
}

function make(capacity) {
  if (capacity <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidCapacity"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              entries: Belt_Array.make(capacity, undefined),
              counter: 0,
              length: 0,
              capacity: capacity
            }
          };
  }
}

function size(cache) {
  return cache.length;
}

function isEmpty(cache) {
  return cache.length === 0;
}

function isFull(cache) {
  return cache.length >= cache.capacity;
}

function getCapacity(cache) {
  return cache.capacity;
}

function fillRatio(cache) {
  return cache.length / cache.capacity;
}

function findEntryIndex(cache, key) {
  var found;
  var i = 0;
  while(Belt_Option.isNone(found) && i < cache.capacity) {
    var entry = cache.entries[i];
    if (entry !== undefined && Caml_obj.equal(entry.key, key)) {
      found = i;
    }
    i = i + 1 | 0;
  };
  return found;
}

function findLruIndex(cache) {
  var lruIndex = 0;
  var minOrder = PervasivesU.max_int;
  for(var i = 0 ,i_finish = cache.capacity; i < i_finish; ++i){
    var entry = cache.entries[i];
    if (entry !== undefined) {
      if (entry.accessOrder < minOrder) {
        minOrder = entry.accessOrder;
        lruIndex = i;
      }
      
    } else {
      lruIndex = i;
      minOrder = -1;
    }
  }
  return lruIndex;
}

function get(cache, key) {
  var index = findEntryIndex(cache, key);
  if (index === undefined) {
    return ;
  }
  var entry = cache.entries[index];
  if (entry !== undefined) {
    cache.counter = cache.counter + 1 | 0;
    entry.accessOrder = cache.counter;
    return Caml_option.some(entry.value);
  }
  
}

function peek(cache, key) {
  var index = findEntryIndex(cache, key);
  if (index === undefined) {
    return ;
  }
  var entry = cache.entries[index];
  if (entry !== undefined) {
    return Caml_option.some(entry.value);
  }
  
}

function put(cache, key, value) {
  cache.counter = cache.counter + 1 | 0;
  var index = findEntryIndex(cache, key);
  if (index !== undefined) {
    var entry = cache.entries[index];
    if (entry !== undefined) {
      cache.entries[index] = {
        key: key,
        value: value,
        accessOrder: cache.counter
      };
      return ;
    } else {
      return ;
    }
  }
  var targetIndex = findLruIndex(cache);
  var evicted = cache.entries[targetIndex];
  cache.entries[targetIndex] = {
    key: key,
    value: value,
    accessOrder: cache.counter
  };
  if (evicted !== undefined) {
    return [
            evicted.key,
            evicted.value
          ];
  } else {
    cache.length = cache.length + 1 | 0;
    return ;
  }
}

function remove(cache, key) {
  var index = findEntryIndex(cache, key);
  if (index !== undefined) {
    cache.entries[index] = undefined;
    cache.length = cache.length - 1 | 0;
    return true;
  } else {
    return false;
  }
}

function contains(cache, key) {
  return Belt_Option.isSome(findEntryIndex(cache, key));
}

function clear(cache) {
  for(var i = 0 ,i_finish = cache.capacity; i < i_finish; ++i){
    cache.entries[i] = undefined;
  }
  cache.length = 0;
  cache.counter = 0;
}

function keys(cache) {
  var result = [];
  for(var i = 0 ,i_finish = cache.capacity; i < i_finish; ++i){
    var entry = cache.entries[i];
    if (entry !== undefined) {
      result.push(entry.key);
    }
    
  }
  return result;
}

function values(cache) {
  var result = [];
  for(var i = 0 ,i_finish = cache.capacity; i < i_finish; ++i){
    var entry = cache.entries[i];
    if (entry !== undefined) {
      result.push(entry.value);
    }
    
  }
  return result;
}

function entries(cache) {
  var result = [];
  for(var i = 0 ,i_finish = cache.capacity; i < i_finish; ++i){
    var entry = cache.entries[i];
    if (entry !== undefined) {
      result.push([
            entry.key,
            entry.value
          ]);
    }
    
  }
  return result;
}

function forEach(cache, fn) {
  for(var i = 0 ,i_finish = cache.capacity; i < i_finish; ++i){
    var entry = cache.entries[i];
    if (entry !== undefined) {
      fn(entry.key, entry.value);
    }
    
  }
}

function entriesByAccessOrder(cache) {
  var validEntries = [];
  for(var i = 0 ,i_finish = cache.capacity; i < i_finish; ++i){
    var entry = cache.entries[i];
    if (entry !== undefined) {
      validEntries.push(entry);
    }
    
  }
  var sorted = validEntries.sort(function (a, b) {
        return b.accessOrder - a.accessOrder | 0;
      });
  return Belt_Array.map(sorted, (function (entry) {
                return [
                        entry.key,
                        entry.value
                      ];
              }));
}

function getMostRecentlyUsed(cache) {
  var mru;
  var maxOrder = -1;
  for(var i = 0 ,i_finish = cache.capacity; i < i_finish; ++i){
    var entry = cache.entries[i];
    if (entry !== undefined && entry.accessOrder > maxOrder) {
      maxOrder = entry.accessOrder;
      mru = [
        entry.key,
        entry.value
      ];
    }
    
  }
  return mru;
}

function getLeastRecentlyUsed(cache) {
  if (cache.length === 0) {
    return ;
  }
  var lru;
  var minOrder = PervasivesU.max_int;
  for(var i = 0 ,i_finish = cache.capacity; i < i_finish; ++i){
    var entry = cache.entries[i];
    if (entry !== undefined && entry.accessOrder < minOrder) {
      minOrder = entry.accessOrder;
      lru = [
        entry.key,
        entry.value
      ];
    }
    
  }
  return lru;
}

function getOrCompute(cache, key, compute) {
  var value = get(cache, key);
  if (value !== undefined) {
    return Caml_option.valFromOption(value);
  }
  var value$1 = compute(key);
  put(cache, key, value$1);
  return value$1;
}

export {
  errorToString ,
  make ,
  size ,
  isEmpty ,
  isFull ,
  getCapacity ,
  fillRatio ,
  findEntryIndex ,
  findLruIndex ,
  get ,
  peek ,
  put ,
  remove ,
  contains ,
  clear ,
  keys ,
  values ,
  entries ,
  forEach ,
  entriesByAccessOrder ,
  getMostRecentlyUsed ,
  getLeastRecentlyUsed ,
  getOrCompute ,
}
/* No side effect */
