// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Float from "rescript/lib/es6/belt_Float.js";

function isFlag(argType) {
  switch (argType) {
    case "ShortFlag" :
    case "LongFlag" :
        return true;
    default:
      return false;
  }
}

function isOption(argType) {
  switch (argType) {
    case "ShortOption" :
    case "LongOption" :
        return true;
    default:
      return false;
  }
}

function classifyArg(arg) {
  var len = arg.length;
  if (len === 0) {
    return {
            argType: "Positional",
            name: "",
            value: undefined,
            original: arg
          };
  }
  if (arg === "--") {
    return {
            argType: "Separator",
            name: "",
            value: undefined,
            original: arg
          };
  }
  if (len >= 2 && arg.charAt(0) === "-" && arg.charAt(1) === "-") {
    var rest = arg.slice(2);
    var restLen = rest.length;
    if (restLen === 0) {
      return {
              argType: "Separator",
              name: "",
              value: undefined,
              original: arg
            };
    }
    var eqPos = rest.indexOf("=");
    if (eqPos === -1) {
      return {
              argType: "LongFlag",
              name: rest,
              value: undefined,
              original: arg
            };
    }
    var name = rest.slice(0, eqPos);
    var value = rest.slice(eqPos + 1 | 0);
    return {
            argType: "LongOption",
            name: name,
            value: value,
            original: arg
          };
  }
  if (!(len >= 2 && arg.charAt(0) === "-" && arg.charAt(1) !== "-")) {
    return {
            argType: "Positional",
            name: arg,
            value: undefined,
            original: arg
          };
  }
  var rest$1 = arg.slice(1);
  var restLen$1 = rest$1.length;
  if (restLen$1 === 1) {
    return {
            argType: "ShortFlag",
            name: rest$1,
            value: undefined,
            original: arg
          };
  }
  var name$1 = rest$1.slice(0, 1);
  var value$1 = rest$1.slice(1);
  return {
          argType: "ShortOption",
          name: name$1,
          value: value$1,
          original: arg
        };
}

function createIterator(maxArgsOpt, args) {
  var maxArgs = maxArgsOpt !== undefined ? maxArgsOpt : 1000;
  return {
          args: args,
          index: 0,
          pastSeparator: false,
          positionalCount: 0,
          maxArgs: maxArgs
        };
}

function nextArg(iter) {
  if (iter.index >= iter.args.length) {
    return ;
  }
  if (iter.index >= iter.maxArgs) {
    return ;
  }
  var arg = iter.args[iter.index];
  iter.index = iter.index + 1 | 0;
  if (iter.pastSeparator) {
    iter.positionalCount = iter.positionalCount + 1 | 0;
    return {
            argType: "Positional",
            name: arg,
            value: undefined,
            original: arg
          };
  }
  var classified = classifyArg(arg);
  if (classified.argType === "Separator") {
    iter.pastSeparator = true;
  } else if (classified.argType === "Positional") {
    iter.positionalCount = iter.positionalCount + 1 | 0;
  }
  return classified;
}

function peekArg(iter) {
  if (iter.index >= iter.args.length || iter.index >= iter.maxArgs) {
    return ;
  } else {
    return iter.args[iter.index];
  }
}

function skipArg(iter) {
  if (iter.index < iter.args.length && iter.index < iter.maxArgs) {
    iter.index = iter.index + 1 | 0;
    return ;
  }
  
}

function position(iter) {
  return iter.index;
}

function remaining(iter) {
  var maxRemaining = iter.maxArgs - (
    iter.index < iter.maxArgs ? iter.index : iter.maxArgs
  ) | 0;
  var actualRemaining = iter.args.length - Caml.int_min(iter.index, iter.args.length) | 0;
  if (maxRemaining < actualRemaining) {
    return maxRemaining;
  } else {
    return actualRemaining;
  }
}

function resetIterator(iter) {
  iter.index = 0;
  iter.pastSeparator = false;
  iter.positionalCount = 0;
}

function $$parseInt(str) {
  if (str.length === 0) {
    return {
            TAG: "Error",
            _0: "EmptyArgument"
          };
  }
  var n = Belt_Int.fromString(str);
  if (n !== undefined) {
    return {
            TAG: "Ok",
            _0: n
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidNumber"
          };
  }
}

function parseIntBounded(str, minVal, maxVal) {
  var e = $$parseInt(str);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var value = e._0;
  if (value < minVal || value > maxVal) {
    return {
            TAG: "Error",
            _0: "ValueOutOfRange"
          };
  } else {
    return {
            TAG: "Ok",
            _0: value
          };
  }
}

function $$parseFloat(str) {
  if (str.length === 0) {
    return {
            TAG: "Error",
            _0: "EmptyArgument"
          };
  }
  var n = Belt_Float.fromString(str);
  if (n !== undefined) {
    return {
            TAG: "Ok",
            _0: n
          };
  } else {
    return {
            TAG: "Error",
            _0: "InvalidNumber"
          };
  }
}

function parseBool(str) {
  var lower = str.toLowerCase();
  switch (lower) {
    case "0" :
    case "false" :
    case "no" :
    case "off" :
        return {
                TAG: "Ok",
                _0: false
              };
    case "1" :
    case "on" :
    case "true" :
    case "yes" :
        return {
                TAG: "Ok",
                _0: true
              };
    default:
      return {
              TAG: "Error",
              _0: "InvalidArgument"
            };
  }
}

function isValidOptionName(name) {
  var len = name.length;
  if (len === 0) {
    return false;
  }
  var firstCode = name.charCodeAt(0) | 0;
  var firstIsAlphanumeric = firstCode >= 48 && firstCode <= 57 || firstCode >= 65 && firstCode <= 90 || firstCode >= 97 && firstCode <= 122;
  if (!firstIsAlphanumeric) {
    return false;
  }
  var lastChar = name.charAt(len - 1 | 0);
  if (lastChar === "-") {
    return false;
  }
  var valid = true;
  for(var i = 0; i < len; ++i){
    if (valid) {
      var charCode = name.charCodeAt(i) | 0;
      var isValidChar = charCode >= 48 && charCode <= 57 || charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || charCode === 45 || charCode === 95;
      if (!isValidChar) {
        valid = false;
      }
      
    }
    
  }
  return valid;
}

function extractValue(current, nextArgValue) {
  var v = current.value;
  if (v !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              value: v,
              consumedNext: false
            }
          };
  } else if (nextArgValue !== undefined && !(nextArgValue.length > 0 && nextArgValue.charAt(0) === "-")) {
    return {
            TAG: "Ok",
            _0: {
              value: nextArgValue,
              consumedNext: true
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: "MissingValue"
          };
  }
}

function countPositional(args) {
  var count = {
    contents: 0
  };
  var pastSeparator = {
    contents: false
  };
  Belt_Array.forEach(args, (function (arg) {
          if (arg === "--") {
            pastSeparator.contents = true;
            return ;
          }
          if (pastSeparator.contents) {
            count.contents = count.contents + 1 | 0;
            return ;
          }
          var classified = classifyArg(arg);
          if (classified.argType === "Positional") {
            count.contents = count.contents + 1 | 0;
            return ;
          }
          
        }));
  return count.contents;
}

function matchesOption(arg, $$short, $$long) {
  var match = arg.argType;
  var exit = 0;
  switch (match) {
    case "ShortFlag" :
    case "ShortOption" :
        exit = 1;
        break;
    case "LongFlag" :
    case "LongOption" :
        exit = 2;
        break;
    case "Positional" :
    case "Separator" :
        return false;
    
  }
  switch (exit) {
    case 1 :
        if ($$short !== undefined) {
          return arg.name === $$short;
        } else {
          return false;
        }
    case 2 :
        if ($$long !== undefined) {
          return arg.name === $$long;
        } else {
          return false;
        }
    
  }
}

function needsQuoting(arg) {
  if (arg.length === 0) {
    return true;
  }
  var specialChars = [
    " ",
    "\t",
    "\n",
    "\r",
    "\"",
    "'",
    "\\",
    "$",
    "`",
    "!",
    "*",
    "?",
    "[",
    "]",
    "(",
    ")",
    "{",
    "}",
    "|",
    "&",
    ";",
    "<",
    ">"
  ];
  var chars = arg.split("");
  return chars.some(function ($$char) {
              return specialChars.includes($$char);
            });
}

function joinArgs(args) {
  return args.join(" ");
}

function createOptionSet(maxOptionsOpt) {
  var maxOptions = maxOptionsOpt !== undefined ? maxOptionsOpt : 100;
  return {
          entries: [],
          maxOptions: maxOptions
        };
}

function setOption(set, name, value) {
  var existingIndex = Belt_Array.getIndexBy(set.entries, (function (entry) {
          return entry.name === name;
        }));
  if (existingIndex === undefined) {
    if (set.entries.length >= set.maxOptions) {
      return {
              TAG: "Error",
              _0: "TooManyArguments"
            };
    } else {
      set.entries = Belt_Array.concat(set.entries, [{
              name: name,
              value: value,
              count: 1
            }]);
      return {
              TAG: "Ok",
              _0: undefined
            };
    }
  }
  var entry = set.entries[existingIndex];
  var updatedEntry_name = entry.name;
  var updatedEntry_count = entry.count + 1 | 0;
  var updatedEntry = {
    name: updatedEntry_name,
    value: value,
    count: updatedEntry_count
  };
  set.entries = Belt_Array.mapWithIndex(set.entries, (function (i, e) {
          if (i === existingIndex) {
            return updatedEntry;
          } else {
            return e;
          }
        }));
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function getOption(set, name) {
  var entry = Belt_Array.getBy(set.entries, (function (entry) {
          return entry.name === name;
        }));
  if (entry !== undefined) {
    return entry.value;
  }
  
}

function hasOption(set, name) {
  return Belt_Array.some(set.entries, (function (entry) {
                return entry.name === name;
              }));
}

function getOptionCount(set, name) {
  var entry = Belt_Array.getBy(set.entries, (function (entry) {
          return entry.name === name;
        }));
  if (entry !== undefined) {
    return entry.count;
  } else {
    return 0;
  }
}

function argTypeToString(argType) {
  switch (argType) {
    case "ShortFlag" :
        return "short_flag";
    case "LongFlag" :
        return "long_flag";
    case "ShortOption" :
        return "short_option";
    case "LongOption" :
        return "long_option";
    case "Positional" :
        return "positional";
    case "Separator" :
        return "separator";
    
  }
}

function argsErrorToString(error) {
  switch (error) {
    case "InvalidArgument" :
        return "Invalid argument";
    case "MissingValue" :
        return "Missing value for option";
    case "UnknownOption" :
        return "Unknown option";
    case "DuplicateOption" :
        return "Duplicate option";
    case "TooManyArguments" :
        return "Too many arguments";
    case "InvalidNumber" :
        return "Invalid number";
    case "ValueOutOfRange" :
        return "Value out of range";
    case "EmptyArgument" :
        return "Empty argument";
    
  }
}

function collectPositional(args) {
  var result = {
    contents: []
  };
  var pastSeparator = {
    contents: false
  };
  Belt_Array.forEach(args, (function (arg) {
          if (arg === "--") {
            pastSeparator.contents = true;
            return ;
          }
          if (pastSeparator.contents) {
            result.contents = Belt_Array.concat(result.contents, [arg]);
            return ;
          }
          var classified = classifyArg(arg);
          if (classified.argType === "Positional") {
            result.contents = Belt_Array.concat(result.contents, [arg]);
            return ;
          }
          
        }));
  return result.contents;
}

function parseCommaSeparated(str) {
  if (str.length === 0) {
    return [];
  } else {
    return str.split(",").map(function (s) {
                  return s.trim();
                }).filter(function (s) {
                return s.length > 0;
              });
  }
}

function isNegativeNumber(str) {
  var len = str.length;
  if (len < 2) {
    return false;
  }
  if (str.charAt(0) !== "-") {
    return false;
  }
  var rest = str.slice(1);
  return Belt_Float.fromString(rest) !== undefined;
}

function classifyArgWithNumbers(arg) {
  if (isNegativeNumber(arg)) {
    return {
            argType: "Positional",
            name: arg,
            value: undefined,
            original: arg
          };
  } else {
    return classifyArg(arg);
  }
}

function formatOptionHelp($$short, $$long, description) {
  var shortPart = $$short !== undefined ? "-" + $$short : "";
  var longPart = $$long !== undefined ? "--" + $$long : "";
  var optionPart = $$short !== undefined ? (
      $$long !== undefined ? shortPart + ", " + longPart : shortPart
    ) : (
      $$long !== undefined ? longPart : ""
    );
  return "  " + optionPart + "    " + description;
}

export {
  isFlag ,
  isOption ,
  classifyArg ,
  createIterator ,
  nextArg ,
  peekArg ,
  skipArg ,
  position ,
  remaining ,
  resetIterator ,
  $$parseInt ,
  parseIntBounded ,
  $$parseFloat ,
  parseBool ,
  isValidOptionName ,
  extractValue ,
  countPositional ,
  matchesOption ,
  needsQuoting ,
  joinArgs ,
  createOptionSet ,
  setOption ,
  getOption ,
  hasOption ,
  getOptionCount ,
  argTypeToString ,
  argsErrorToString ,
  collectPositional ,
  parseCommaSeparated ,
  isNegativeNumber ,
  classifyArgWithNumbers ,
  formatOptionHelp ,
}
/* No side effect */
