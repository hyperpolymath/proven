// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function gcd(_a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    var absA = a < 0 ? -a | 0 : a;
    var absB = b < 0 ? -b | 0 : b;
    if (absB === 0) {
      return absA;
    }
    _b = Caml_int32.mod_(absA, absB);
    _a = absB;
    continue ;
  };
}

function absInt(value) {
  if (value < 0) {
    return -value | 0;
  } else {
    return value;
  }
}

function make(numerator, denominator) {
  if (denominator === 0) {
    return {
            TAG: "Error",
            _0: "DivisionByZero"
          };
  }
  var num = numerator;
  var denom = denominator;
  if (denom < 0) {
    if (num === PervasivesU.min_int || denom === PervasivesU.min_int) {
      return {
              TAG: "Error",
              _0: "Overflow"
            };
    }
    num = -num | 0;
    denom = -denom | 0;
    var divisor = gcd(absInt(num), absInt(denom));
    if (divisor > 1) {
      num = Caml_int32.div(num, divisor);
      denom = Caml_int32.div(denom, divisor);
    }
    return {
            TAG: "Ok",
            _0: {
              numerator: num,
              denominator: denom
            }
          };
  }
  var divisor$1 = gcd(absInt(num), absInt(denom));
  if (divisor$1 > 1) {
    num = Caml_int32.div(num, divisor$1);
    denom = Caml_int32.div(denom, divisor$1);
  }
  return {
          TAG: "Ok",
          _0: {
            numerator: num,
            denominator: denom
          }
        };
}

function fromInt(value) {
  return {
          numerator: value,
          denominator: 1
        };
}

var one = {
  numerator: 1,
  denominator: 1
};

function isZero(r) {
  return r.numerator === 0;
}

function isPositive(r) {
  return r.numerator > 0;
}

function isNegative(r) {
  return r.numerator < 0;
}

function isInteger(r) {
  return r.denominator === 1;
}

function negate(r) {
  if (r.numerator === PervasivesU.min_int) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              numerator: -r.numerator | 0,
              denominator: r.denominator
            }
          };
  }
}

function abs(r) {
  return {
          numerator: absInt(r.numerator),
          denominator: r.denominator
        };
}

function reciprocal(r) {
  if (r.numerator === 0) {
    return {
            TAG: "Error",
            _0: "DivisionByZero"
          };
  } else {
    return make(r.denominator, r.numerator);
  }
}

function mulChecked(a, b) {
  if (a === 0 || b === 0) {
    return {
            TAG: "Ok",
            _0: 0
          };
  }
  var result = Math.imul(a, b);
  if (Caml_int32.div(result, a) !== b) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: result
          };
  }
}

function addChecked(a, b) {
  var result = a + b | 0;
  if (a > 0 && b > 0 && result < 0 || a < 0 && b < 0 && result > 0) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: result
          };
  }
}

function add(r1, r2) {
  var e = mulChecked(r1.numerator, r2.denominator);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var e$1 = mulChecked(r2.numerator, r1.denominator);
  if (e$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
  var e$2 = addChecked(e._0, e$1._0);
  if (e$2.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e$2._0
          };
  }
  var e$3 = mulChecked(r1.denominator, r2.denominator);
  if (e$3.TAG === "Ok") {
    return make(e$2._0, e$3._0);
  } else {
    return {
            TAG: "Error",
            _0: e$3._0
          };
  }
}

function sub(r1, r2) {
  var e = negate(r2);
  if (e.TAG === "Ok") {
    return add(r1, e._0);
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function mul(r1, r2) {
  var e = mulChecked(r1.numerator, r2.numerator);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var e$1 = mulChecked(r1.denominator, r2.denominator);
  if (e$1.TAG === "Ok") {
    return make(e._0, e$1._0);
  } else {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
}

function div(r1, r2) {
  var e = reciprocal(r2);
  if (e.TAG === "Ok") {
    return mul(r1, e._0);
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function compare(r1, r2) {
  var e = mulChecked(r1.numerator, r2.denominator);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var ad = e._0;
  var e$1 = mulChecked(r2.numerator, r1.denominator);
  if (e$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
  var cb = e$1._0;
  if (ad < cb) {
    return {
            TAG: "Ok",
            _0: -1
          };
  } else if (ad > cb) {
    return {
            TAG: "Ok",
            _0: 1
          };
  } else {
    return {
            TAG: "Ok",
            _0: 0
          };
  }
}

function equal(r1, r2) {
  if (r1.numerator === r2.numerator) {
    return r1.denominator === r2.denominator;
  } else {
    return false;
  }
}

function toFloat(r) {
  return r.numerator / r.denominator;
}

function floor(r) {
  if (r.numerator >= 0) {
    return Caml_int32.div(r.numerator, r.denominator);
  }
  var q = Caml_int32.div(r.numerator, r.denominator);
  var rem = Caml_int32.mod_(r.numerator, r.denominator);
  if (rem !== 0) {
    return q - 1 | 0;
  } else {
    return q;
  }
}

function ceil(r) {
  if (r.numerator >= 0) {
    return Caml_int32.div((r.numerator + r.denominator | 0) - 1 | 0, r.denominator);
  } else {
    return Caml_int32.div(r.numerator, r.denominator);
  }
}

function round(r) {
  var doubled = (r.numerator << 1);
  if (doubled >= 0) {
    return Caml_int32.div(doubled + r.denominator | 0, (r.denominator << 1));
  } else {
    return Caml_int32.div(doubled - r.denominator | 0, (r.denominator << 1));
  }
}

function pow(_r, _exponent) {
  while(true) {
    var exponent = _exponent;
    var r = _r;
    if (exponent === 0) {
      return {
              TAG: "Ok",
              _0: one
            };
    }
    if (exponent < 0) {
      var e = reciprocal(r);
      if (e.TAG !== "Ok") {
        return {
                TAG: "Error",
                _0: e._0
              };
      }
      _exponent = -exponent | 0;
      _r = e._0;
      continue ;
    }
    if (exponent === 1) {
      return {
              TAG: "Ok",
              _0: r
            };
    }
    var e$1 = pow(r, exponent / 2 | 0);
    if (e$1.TAG !== "Ok") {
      return {
              TAG: "Error",
              _0: e$1._0
            };
    }
    var half = e$1._0;
    var e$2 = mul(half, half);
    if (e$2.TAG !== "Ok") {
      return {
              TAG: "Error",
              _0: e$2._0
            };
    }
    var squared = e$2._0;
    if (exponent % 2 === 0) {
      return {
              TAG: "Ok",
              _0: squared
            };
    } else {
      return mul(squared, r);
    }
  };
}

function mediant(r1, r2) {
  var e = addChecked(r1.numerator, r2.numerator);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var e$1 = addChecked(r1.denominator, r2.denominator);
  if (e$1.TAG === "Ok") {
    return make(e._0, e$1._0);
  } else {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
}

function toString(r) {
  if (r.denominator === 1) {
    return String(r.numerator);
  } else {
    return String(r.numerator) + "/" + String(r.denominator);
  }
}

function toMixedString(r) {
  if (r.denominator === 1) {
    return String(r.numerator);
  }
  var wholePart = floor(r);
  var remainder = absInt(r.numerator - Math.imul(wholePart, r.denominator) | 0);
  if (wholePart === 0) {
    return String(r.numerator) + "/" + String(r.denominator);
  } else if (remainder === 0) {
    return String(wholePart);
  } else {
    return String(wholePart) + " " + String(remainder) + "/" + String(r.denominator);
  }
}

function parse(input) {
  var trimmed = input.trim();
  var parts = trimmed.split("/");
  if (parts.length === 1) {
    var n = Belt_Int.fromString(trimmed);
    if (n !== undefined) {
      return {
              TAG: "Ok",
              _0: {
                numerator: n,
                denominator: 1
              }
            };
    } else {
      return {
              TAG: "Error",
              _0: "InvalidRepresentation"
            };
    }
  }
  if (parts.length !== 2) {
    return {
            TAG: "Error",
            _0: "InvalidRepresentation"
          };
  }
  var numStr = parts[0];
  var denomStr = parts[1];
  var match = Belt_Int.fromString(numStr.trim());
  var match$1 = Belt_Int.fromString(denomStr.trim());
  if (match !== undefined && match$1 !== undefined) {
    return make(match, match$1);
  } else {
    return {
            TAG: "Error",
            _0: "InvalidRepresentation"
          };
  }
}

function sign(r) {
  if (r.numerator < 0) {
    return -1;
  } else if (r.numerator > 0) {
    return 1;
  } else {
    return 0;
  }
}

function lessThan(r1, r2) {
  var e = compare(r1, r2);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: e._0 < 0
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function greaterThan(r1, r2) {
  var e = compare(r1, r2);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: e._0 > 0
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function lessThanOrEqual(r1, r2) {
  var e = compare(r1, r2);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: e._0 <= 0
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function greaterThanOrEqual(r1, r2) {
  var e = compare(r1, r2);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: e._0 >= 0
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function min(r1, r2) {
  var e = compare(r1, r2);
  if (e.TAG === "Ok") {
    if (e._0 <= 0) {
      return {
              TAG: "Ok",
              _0: r1
            };
    } else {
      return {
              TAG: "Ok",
              _0: r2
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function max(r1, r2) {
  var e = compare(r1, r2);
  if (e.TAG === "Ok") {
    if (e._0 >= 0) {
      return {
              TAG: "Ok",
              _0: r1
            };
    } else {
      return {
              TAG: "Ok",
              _0: r2
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

function isProperFraction(r) {
  return absInt(r.numerator) < r.denominator;
}

var zero = {
  numerator: 0,
  denominator: 1
};

var negOne = {
  numerator: -1,
  denominator: 1
};

var oneHalf = {
  numerator: 1,
  denominator: 2
};

var oneThird = {
  numerator: 1,
  denominator: 3
};

var twoThirds = {
  numerator: 2,
  denominator: 3
};

var oneQuarter = {
  numerator: 1,
  denominator: 4
};

var threeQuarters = {
  numerator: 3,
  denominator: 4
};

export {
  gcd ,
  absInt ,
  make ,
  fromInt ,
  zero ,
  one ,
  negOne ,
  isZero ,
  isPositive ,
  isNegative ,
  isInteger ,
  negate ,
  abs ,
  reciprocal ,
  mulChecked ,
  addChecked ,
  add ,
  sub ,
  mul ,
  div ,
  compare ,
  equal ,
  toFloat ,
  floor ,
  ceil ,
  round ,
  pow ,
  mediant ,
  toString ,
  toMixedString ,
  parse ,
  sign ,
  lessThan ,
  greaterThan ,
  lessThanOrEqual ,
  greaterThanOrEqual ,
  min ,
  max ,
  isProperFraction ,
  oneHalf ,
  oneThird ,
  twoThirds ,
  oneQuarter ,
  threeQuarters ,
}
/* No side effect */
