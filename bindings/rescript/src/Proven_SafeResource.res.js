// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function isValidHandle(h) {
  return h.index >= 0;
}

function createResourcePool(capacity) {
  var cap = 1 > capacity ? 1 : capacity;
  var slots = Belt_Array.makeBy(cap, (function (param) {
          return {
                  resource: undefined,
                  generation: 0,
                  isActive: false
                };
        }));
  var freeList = Belt_Array.makeBy(cap, (function (i) {
          return (cap - 1 | 0) - i | 0;
        }));
  return {
          slots: slots,
          freeList: freeList,
          freeCount: cap,
          activeCount: 0,
          capacity: cap
        };
}

function acquire(pool, resource) {
  if (pool.freeCount === 0) {
    return {
            TAG: "Error",
            _0: "ResourceLimitExceeded"
          };
  }
  pool.freeCount = pool.freeCount - 1 | 0;
  var index = pool.freeList[pool.freeCount];
  var slot = pool.slots[index];
  slot.resource = Caml_option.some(resource);
  slot.isActive = true;
  pool.activeCount = pool.activeCount + 1 | 0;
  return {
          TAG: "Ok",
          _0: {
            index: index,
            generation: slot.generation
          }
        };
}

function release(pool, h) {
  if (h.index < 0) {
    return {
            TAG: "Error",
            _0: "InvalidHandle"
          };
  }
  if (h.index >= pool.capacity) {
    return {
            TAG: "Error",
            _0: "InvalidHandle"
          };
  }
  var slot = pool.slots[h.index];
  if (!slot.isActive) {
    return {
            TAG: "Error",
            _0: "ResourceAlreadyReleased"
          };
  }
  if (slot.generation !== h.generation) {
    return {
            TAG: "Error",
            _0: "ResourceAlreadyReleased"
          };
  }
  var resource = slot.resource;
  if (resource !== undefined) {
    slot.resource = undefined;
    slot.isActive = false;
    slot.generation = slot.generation + 1 | 0;
    pool.freeList[pool.freeCount] = h.index;
    pool.freeCount = pool.freeCount + 1 | 0;
    pool.activeCount = pool.activeCount - 1 | 0;
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(resource)
          };
  } else {
    return {
            TAG: "Error",
            _0: "ResourceAlreadyReleased"
          };
  }
}

function get(pool, h) {
  if (h.index < 0) {
    return {
            TAG: "Error",
            _0: "InvalidHandle"
          };
  }
  if (h.index >= pool.capacity) {
    return {
            TAG: "Error",
            _0: "InvalidHandle"
          };
  }
  var slot = pool.slots[h.index];
  if (!slot.isActive) {
    return {
            TAG: "Error",
            _0: "ResourceAlreadyReleased"
          };
  }
  if (slot.generation !== h.generation) {
    return {
            TAG: "Error",
            _0: "ResourceAlreadyReleased"
          };
  }
  var resource = slot.resource;
  if (resource !== undefined) {
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(resource)
          };
  } else {
    return {
            TAG: "Error",
            _0: "ResourceAlreadyReleased"
          };
  }
}

function isActive(pool, h) {
  if (h.index < 0) {
    return false;
  }
  if (h.index >= pool.capacity) {
    return false;
  }
  var slot = pool.slots[h.index];
  if (slot.isActive) {
    return slot.generation === h.generation;
  } else {
    return false;
  }
}

function activeCount(pool) {
  return pool.activeCount;
}

function remainingCapacity(pool) {
  return pool.freeCount;
}

function clear(pool) {
  for(var i = 0 ,i_finish = pool.capacity; i < i_finish; ++i){
    var slot = pool.slots[i];
    if (slot.isActive) {
      slot.resource = undefined;
      slot.isActive = false;
      slot.generation = slot.generation + 1 | 0;
    }
    pool.freeList[i] = (pool.capacity - 1 | 0) - i | 0;
  }
  pool.freeCount = pool.capacity;
  pool.activeCount = 0;
}

function createRefCounted(value) {
  return {
          value: value,
          refCount: 1
        };
}

function retain(rc) {
  rc.refCount = rc.refCount + 1 | 0;
}

function releaseRef(rc) {
  if (rc.refCount === 0) {
    return true;
  } else {
    rc.refCount = rc.refCount - 1 | 0;
    return rc.refCount === 0;
  }
}

function refCount(rc) {
  return rc.refCount;
}

function isUnique(rc) {
  return rc.refCount === 1;
}

function createUnique(value) {
  return {
          value: Caml_option.some(value)
        };
}

function createUniqueEmpty() {
  return {
          value: undefined
        };
}

function hasValue(unique) {
  return Belt_Option.isSome(unique.value);
}

function getValue(unique) {
  var v = unique.value;
  if (v !== undefined) {
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(v)
          };
  } else {
    return {
            TAG: "Error",
            _0: "ResourceAlreadyReleased"
          };
  }
}

function take(unique) {
  var v = unique.value;
  if (v !== undefined) {
    unique.value = undefined;
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(v)
          };
  } else {
    return {
            TAG: "Error",
            _0: "ResourceAlreadyReleased"
          };
  }
}

function replace(unique, newValue) {
  var old = unique.value;
  unique.value = Caml_option.some(newValue);
  return old;
}

function clearUnique(unique) {
  unique.value = undefined;
}

function createLeased(value, currentTime, duration) {
  return {
          value: value,
          leaseStart: currentTime,
          leaseDuration: duration
        };
}

function isExpired(leased, currentTime) {
  return currentTime >= leased.leaseStart + leased.leaseDuration;
}

function remainingTime(leased, currentTime) {
  var expiry = leased.leaseStart + leased.leaseDuration;
  if (currentTime >= expiry) {
    return 0.0;
  } else {
    return expiry - currentTime;
  }
}

function renew(leased, currentTime, newDuration) {
  return {
          value: leased.value,
          leaseStart: currentTime,
          leaseDuration: newDuration
        };
}

function getLeasedValue(leased, currentTime) {
  if (isExpired(leased, currentTime)) {
    return {
            TAG: "Error",
            _0: "ResourceAlreadyReleased"
          };
  } else {
    return {
            TAG: "Ok",
            _0: leased.value
          };
  }
}

function withResource(pool, resource, f) {
  var e = acquire(pool, resource);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var h = e._0;
  var e$1 = get(pool, h);
  if (e$1.TAG === "Ok") {
    var result = f(e$1._0);
    release(pool, h);
    return {
            TAG: "Ok",
            _0: result
          };
  }
  release(pool, h);
  return {
          TAG: "Error",
          _0: e$1._0
        };
}

function mapResource(pool, h, f) {
  var e = get(pool, h);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: f(e._0)
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

var invalidHandle = {
  index: -1,
  generation: 0
};

export {
  invalidHandle ,
  isValidHandle ,
  createResourcePool ,
  acquire ,
  release ,
  get ,
  isActive ,
  activeCount ,
  remainingCapacity ,
  clear ,
  createRefCounted ,
  retain ,
  releaseRef ,
  refCount ,
  isUnique ,
  createUnique ,
  createUniqueEmpty ,
  hasValue ,
  getValue ,
  take ,
  replace ,
  clearUnique ,
  createLeased ,
  isExpired ,
  remainingTime ,
  renew ,
  getLeasedValue ,
  withResource ,
  mapResource ,
}
/* No side effect */
