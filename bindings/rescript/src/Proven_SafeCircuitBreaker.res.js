// Generated by ReScript, PLEASE EDIT WITH CARE


function timeUntilRetry(cb, currentTime) {
  var match = cb.state;
  switch (match) {
    case "Open" :
        var elapsed = currentTime - cb.lastFailureTime;
        var remaining = cb.config.timeout - elapsed;
        if (remaining > 0.0) {
          return remaining;
        } else {
          return 0.0;
        }
    case "Closed" :
    case "HalfOpen" :
        return 0.0;
    
  }
}

var defaultConfig = {
  failureThreshold: 5,
  successThreshold: 2,
  timeout: 30000.0,
  halfOpenMaxCalls: 3
};

function make(config) {
  if (config.failureThreshold <= 0) {
    return {
            TAG: "Error",
            _0: "Failure threshold must be positive"
          };
  } else if (config.successThreshold <= 0) {
    return {
            TAG: "Error",
            _0: "Success threshold must be positive"
          };
  } else if (config.timeout <= 0.0) {
    return {
            TAG: "Error",
            _0: "Timeout must be positive"
          };
  } else if (config.halfOpenMaxCalls <= 0) {
    return {
            TAG: "Error",
            _0: "Half-open max calls must be positive"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              config: config,
              state: "Closed",
              failures: 0,
              successes: 0,
              lastFailureTime: 0.0,
              halfOpenCalls: 0
            }
          };
  }
}

function makeDefault() {
  return {
          config: defaultConfig,
          state: "Closed",
          failures: 0,
          successes: 0,
          lastFailureTime: 0.0,
          halfOpenCalls: 0
        };
}

function shouldTransitionToHalfOpen(cb, currentTime) {
  if (cb.state === "Open") {
    return currentTime >= cb.lastFailureTime + cb.config.timeout;
  } else {
    return false;
  }
}

function updateState(cb, currentTime) {
  if (shouldTransitionToHalfOpen(cb, currentTime)) {
    cb.state = "HalfOpen";
    cb.successes = 0;
    cb.halfOpenCalls = 0;
    return ;
  }
  
}

function canExecute(cb, currentTime) {
  updateState(cb, currentTime);
  var match = cb.state;
  switch (match) {
    case "Closed" :
        return true;
    case "Open" :
        return false;
    case "HalfOpen" :
        return cb.halfOpenCalls < cb.config.halfOpenMaxCalls;
    
  }
}

function recordSuccess(cb) {
  var match = cb.state;
  switch (match) {
    case "Closed" :
        cb.failures = 0;
        return ;
    case "Open" :
        return ;
    case "HalfOpen" :
        cb.successes = cb.successes + 1 | 0;
        if (cb.successes >= cb.config.successThreshold) {
          cb.state = "Closed";
          cb.failures = 0;
          cb.successes = 0;
          return ;
        } else {
          return ;
        }
    
  }
}

function recordFailure(cb, currentTime) {
  cb.lastFailureTime = currentTime;
  var match = cb.state;
  switch (match) {
    case "Closed" :
        cb.failures = cb.failures + 1 | 0;
        if (cb.failures >= cb.config.failureThreshold) {
          cb.state = "Open";
          return ;
        } else {
          return ;
        }
    case "Open" :
        cb.failures = cb.failures + 1 | 0;
        return ;
    case "HalfOpen" :
        cb.state = "Open";
        cb.failures = cb.failures + 1 | 0;
        return ;
    
  }
}

function recordAttempt(cb) {
  if (cb.state === "HalfOpen") {
    cb.halfOpenCalls = cb.halfOpenCalls + 1 | 0;
    return ;
  }
  
}

function execute(cb, currentTime, success) {
  updateState(cb, currentTime);
  if (canExecute(cb, currentTime)) {
    recordAttempt(cb);
    if (success) {
      recordSuccess(cb);
    } else {
      recordFailure(cb, currentTime);
    }
    return {
            TAG: "Executed",
            success: success
          };
  }
  var retryAfter = timeUntilRetry(cb, currentTime);
  return {
          TAG: "Rejected",
          reason: "Circuit is open",
          retryAfter: retryAfter
        };
}

function tryExecute(cb, currentTime, operation) {
  updateState(cb, currentTime);
  if (canExecute(cb, currentTime)) {
    recordAttempt(cb);
    try {
      var success = operation();
      if (success) {
        recordSuccess(cb);
      } else {
        recordFailure(cb, currentTime);
      }
      return {
              TAG: "Executed",
              success: success
            };
    }
    catch (exn){
      recordFailure(cb, currentTime);
      return {
              TAG: "Executed",
              success: false
            };
    }
  } else {
    var retryAfter = timeUntilRetry(cb, currentTime);
    return {
            TAG: "Rejected",
            reason: "Circuit is open",
            retryAfter: retryAfter
          };
  }
}

function isHealthy(cb) {
  return cb.state === "Closed";
}

function timeUntilRetry$1(cb, currentTime) {
  if (cb.state !== "Open") {
    return 0.0;
  }
  var retryTime = cb.lastFailureTime + cb.config.timeout;
  if (currentTime >= retryTime) {
    return 0.0;
  } else {
    return retryTime - currentTime;
  }
}

function reset(cb) {
  cb.state = "Closed";
  cb.failures = 0;
  cb.successes = 0;
  cb.halfOpenCalls = 0;
}

function forceOpen(cb, currentTime) {
  cb.state = "Open";
  cb.lastFailureTime = currentTime;
}

function forceClosed(cb) {
  cb.state = "Closed";
  cb.failures = 0;
  cb.successes = 0;
  cb.halfOpenCalls = 0;
}

function getState(cb) {
  return cb.state;
}

function getFailureCount(cb) {
  return cb.failures;
}

function getSuccessCount(cb) {
  return cb.successes;
}

function getHalfOpenCalls(cb) {
  return cb.halfOpenCalls;
}

function stateToString(state) {
  switch (state) {
    case "Closed" :
        return "closed";
    case "Open" :
        return "open";
    case "HalfOpen" :
        return "half-open";
    
  }
}

function wasExecuted(result) {
  if (result.TAG === "Executed") {
    return true;
  } else {
    return false;
  }
}

function wasRejected(result) {
  if (result.TAG === "Executed") {
    return false;
  } else {
    return true;
  }
}

function getExecutionRetryAfter(result) {
  if (result.TAG === "Executed") {
    return ;
  } else {
    return result.retryAfter;
  }
}

export {
  defaultConfig ,
  make ,
  makeDefault ,
  shouldTransitionToHalfOpen ,
  updateState ,
  canExecute ,
  recordSuccess ,
  recordFailure ,
  recordAttempt ,
  execute ,
  tryExecute ,
  isHealthy ,
  timeUntilRetry$1 as timeUntilRetry,
  reset ,
  forceOpen ,
  forceClosed ,
  getState ,
  getFailureCount ,
  getSuccessCount ,
  getHalfOpenCalls ,
  stateToString ,
  wasExecuted ,
  wasRejected ,
  getExecutionRetryAfter ,
}
/* No side effect */
