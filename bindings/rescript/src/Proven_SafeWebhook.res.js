// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Crypto from "crypto";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function getSignatureHeader(provider) {
  switch (provider) {
    case "GitHub" :
        return "X-Hub-Signature-256";
    case "Stripe" :
        return "Stripe-Signature";
    case "Slack" :
        return "X-Slack-Signature";
    case "Twilio" :
        return "X-Twilio-Signature";
    case "Shopify" :
        return "X-Shopify-Hmac-SHA256";
    case "Custom" :
        return "X-Signature";
    
  }
}

function getDefaultAlgorithm(provider) {
  if (provider === "Twilio") {
    return "HmacSha1";
  } else {
    return "HmacSha256";
  }
}

function isSecure(url) {
  return url.scheme === "https";
}

function effectivePort(url) {
  var p = url.port;
  if (p !== undefined) {
    return p;
  } else if (url.scheme === "https" || url.scheme !== "http") {
    return 443;
  } else {
    return 80;
  }
}

function urlToString(url) {
  var p = url.port;
  var portStr = p !== undefined ? ":" + String(p) : "";
  var q = url.query;
  var queryStr = q !== undefined ? "?" + q : "";
  return url.scheme + "://" + url.host + portStr + url.path + queryStr;
}

function parseUrl(input, allowHttpOpt, allowedHosts, param) {
  var allowHttp = allowHttpOpt !== undefined ? allowHttpOpt : false;
  if (input.length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidUrl"
          };
  }
  var schemeEnd = input.indexOf("://");
  if (schemeEnd === -1) {
    return {
            TAG: "Error",
            _0: "InvalidUrl"
          };
  }
  var scheme = input.slice(0, schemeEnd);
  var isHttps = scheme === "https";
  var isHttp = scheme === "http";
  if (!isHttps && !isHttp) {
    return {
            TAG: "Error",
            _0: "InvalidUrl"
          };
  }
  if (!isHttps && !allowHttp) {
    return {
            TAG: "Error",
            _0: "InsecureScheme"
          };
  }
  var remaining = input.slice(schemeEnd + 3 | 0);
  var idx = remaining.indexOf("/");
  var pathStart = idx !== -1 ? idx : remaining.length;
  var authority = remaining.slice(0, pathStart);
  var pathAndQuery = pathStart < remaining.length ? remaining.slice(pathStart) : "/";
  var colonPos = authority.lastIndexOf(":");
  var match;
  if (colonPos !== -1) {
    var hostPart = authority.slice(0, colonPos);
    var portStr = authority.slice(colonPos + 1 | 0);
    var p = Belt_Int.fromString(portStr);
    match = p !== undefined ? [
        hostPart,
        p
      ] : [
        authority,
        undefined
      ];
  } else {
    match = [
      authority,
      undefined
    ];
  }
  var host = match[0];
  if (host.length === 0) {
    return {
            TAG: "Error",
            _0: "InvalidUrl"
          };
  }
  var hostAllowed = allowedHosts !== undefined ? allowedHosts.includes(host) : true;
  if (!hostAllowed) {
    return {
            TAG: "Error",
            _0: "InvalidUrl"
          };
  }
  var queryPos = pathAndQuery.indexOf("?");
  var match$1 = queryPos !== -1 ? [
      pathAndQuery.slice(0, queryPos),
      pathAndQuery.slice(queryPos + 1 | 0)
    ] : [
      pathAndQuery,
      undefined
    ];
  return {
          TAG: "Ok",
          _0: {
            scheme: scheme,
            host: host,
            port: match[1],
            path: match$1[0],
            query: match$1[1]
          }
        };
}

function isValidWebhookUrl(input) {
  var match = parseUrl(input, undefined, undefined, undefined);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function computeHmacSha256(payload, secret) {
  return $$Crypto.createHmac("sha256", secret).update(payload).digest("hex");
}

function computeHmacSha1(payload, secret) {
  return $$Crypto.createHmac("sha1", secret).update(payload).digest("hex");
}

function computeHmacSha512(payload, secret) {
  return $$Crypto.createHmac("sha512", secret).update(payload).digest("hex");
}

function constantTimeCompare(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  var encoder = new TextEncoder();
  try {
    return $$Crypto.timingSafeEqual(encoder.encode(a), encoder.encode(b));
  }
  catch (exn){
    return false;
  }
}

function stripSignaturePrefix(signature) {
  if (signature.startsWith("sha256=")) {
    return signature.slice(7);
  } else if (signature.startsWith("sha1=")) {
    return signature.slice(5);
  } else if (signature.startsWith("v0=")) {
    return signature.slice(3);
  } else {
    return signature;
  }
}

function verifyHmacSha256(payload, secret, signature) {
  var computed = computeHmacSha256(payload, secret);
  var provided = stripSignaturePrefix(signature);
  if (provided.length !== 64) {
    return {
            TAG: "Error",
            _0: "InvalidSignature"
          };
  } else {
    return {
            TAG: "Ok",
            _0: constantTimeCompare(computed, provided)
          };
  }
}

function verifyGitHub(payload, secret, signatureHeader) {
  return verifyHmacSha256(payload, secret, signatureHeader);
}

function parseStripeSignature(header) {
  var timestamp = {
    contents: undefined
  };
  var signature = {
    contents: undefined
  };
  header.split(",").forEach(function (part) {
        if (part.startsWith("t=")) {
          timestamp.contents = part.slice(2);
          return ;
        } else if (part.startsWith("v1=")) {
          signature.contents = part.slice(3);
          return ;
        } else {
          return ;
        }
      });
  var match = timestamp.contents;
  var match$1 = signature.contents;
  if (match !== undefined && match$1 !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              timestamp: match,
              signature: match$1
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: "MissingParameter"
          };
  }
}

function verifyStripe(payload, secret, signatureHeader, toleranceSeconds) {
  var e = parseStripeSignature(signatureHeader);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var match = e._0;
  var signature = match.signature;
  var timestamp = match.timestamp;
  var ts = Belt_Int.fromString(timestamp);
  if (ts === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidPayload"
          };
  }
  var currentTime = Date.now() / 1000.0 | 0;
  var diff = PervasivesU.abs(currentTime - ts | 0);
  if (diff > toleranceSeconds) {
    return {
            TAG: "Error",
            _0: "TimestampOutOfRange"
          };
  }
  var signedPayload = timestamp + "." + payload;
  var computed = computeHmacSha256(signedPayload, secret);
  if (signature.length !== 64) {
    return {
            TAG: "Error",
            _0: "InvalidSignature"
          };
  } else {
    return {
            TAG: "Ok",
            _0: constantTimeCompare(computed, signature)
          };
  }
}

function verifySlack(payload, secret, signatureHeader, timestampHeader, toleranceSeconds) {
  var ts = Belt_Int.fromString(timestampHeader);
  if (ts === undefined) {
    return {
            TAG: "Error",
            _0: "InvalidPayload"
          };
  }
  var currentTime = Date.now() / 1000.0 | 0;
  var diff = PervasivesU.abs(currentTime - ts | 0);
  if (diff > toleranceSeconds) {
    return {
            TAG: "Error",
            _0: "TimestampOutOfRange"
          };
  }
  var signedPayload = "v0:" + timestampHeader + ":" + payload;
  return verifyHmacSha256(signedPayload, secret, signatureHeader);
}

function generateSignature(payload, secret, algorithm) {
  switch (algorithm) {
    case "HmacSha256" :
        return computeHmacSha256(payload, secret);
    case "HmacSha1" :
        return computeHmacSha1(payload, secret);
    case "HmacSha512" :
        return computeHmacSha512(payload, secret);
    
  }
}

function generateGitHubSignature(payload, secret) {
  return "sha256=" + computeHmacSha256(payload, secret);
}

function generateStripeSignature(payload, secret) {
  var timestamp = Date.now() / 1000.0 | 0;
  var signedPayload = String(timestamp) + "." + payload;
  var signature = computeHmacSha256(signedPayload, secret);
  return "t=" + String(timestamp) + ",v1=" + signature;
}

function generateSlackSignature(payload, secret) {
  var timestamp = String(Date.now() / 1000.0 | 0);
  var signedPayload = "v0:" + timestamp + ":" + payload;
  var signature = "v0=" + computeHmacSha256(signedPayload, secret);
  return {
          slackSignature: signature,
          slackTimestamp: timestamp
        };
}

var defaultToleranceSeconds = 300;

export {
  getSignatureHeader ,
  getDefaultAlgorithm ,
  isSecure ,
  effectivePort ,
  urlToString ,
  parseUrl ,
  isValidWebhookUrl ,
  computeHmacSha256 ,
  computeHmacSha1 ,
  computeHmacSha512 ,
  constantTimeCompare ,
  stripSignaturePrefix ,
  verifyHmacSha256 ,
  verifyGitHub ,
  parseStripeSignature ,
  verifyStripe ,
  verifySlack ,
  generateSignature ,
  generateGitHubSignature ,
  generateStripeSignature ,
  generateSlackSignature ,
  defaultToleranceSeconds ,
}
/* crypto Not a pure module */
