// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function closed(lower, upper) {
  if (lower > upper) {
    return {
            TAG: "Error",
            _0: "InvalidBounds"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              lower: lower,
              upper: upper,
              lowerBound: "Closed",
              upperBound: "Closed"
            }
          };
  }
}

function open_(lower, upper) {
  if (lower >= upper) {
    return {
            TAG: "Error",
            _0: "InvalidBounds"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              lower: lower,
              upper: upper,
              lowerBound: "Open",
              upperBound: "Open"
            }
          };
  }
}

function closedOpen(lower, upper) {
  if (lower >= upper) {
    return {
            TAG: "Error",
            _0: "InvalidBounds"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              lower: lower,
              upper: upper,
              lowerBound: "Closed",
              upperBound: "Open"
            }
          };
  }
}

function openClosed(lower, upper) {
  if (lower >= upper) {
    return {
            TAG: "Error",
            _0: "InvalidBounds"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              lower: lower,
              upper: upper,
              lowerBound: "Open",
              upperBound: "Closed"
            }
          };
  }
}

function atLeast(lower) {
  return {
          lower: lower,
          upper: undefined,
          lowerBound: "Closed",
          upperBound: "Unbounded"
        };
}

function greaterThan(lower) {
  return {
          lower: lower,
          upper: undefined,
          lowerBound: "Open",
          upperBound: "Unbounded"
        };
}

function atMost(upper) {
  return {
          lower: undefined,
          upper: upper,
          lowerBound: "Unbounded",
          upperBound: "Closed"
        };
}

function lessThan(upper) {
  return {
          lower: undefined,
          upper: upper,
          lowerBound: "Unbounded",
          upperBound: "Open"
        };
}

function singleton(value) {
  return {
          lower: value,
          upper: value,
          lowerBound: "Closed",
          upperBound: "Closed"
        };
}

function isEmpty(i) {
  var match = i.lower;
  var match$1 = i.upper;
  if (match !== undefined && match$1 !== undefined) {
    if (match > match$1) {
      return true;
    } else if (match === match$1) {
      if (i.lowerBound === "Open") {
        return true;
      } else {
        return i.upperBound === "Open";
      }
    } else {
      return false;
    }
  } else {
    return false;
  }
}

function contains(i, value) {
  var l = i.lower;
  var passesLower;
  if (l !== undefined) {
    var match = i.lowerBound;
    switch (match) {
      case "Closed" :
          passesLower = value >= l;
          break;
      case "Open" :
          passesLower = value > l;
          break;
      case "Unbounded" :
          passesLower = true;
          break;
      
    }
  } else {
    passesLower = true;
  }
  var u = i.upper;
  var passesUpper;
  if (u !== undefined) {
    var match$1 = i.upperBound;
    switch (match$1) {
      case "Closed" :
          passesUpper = value <= u;
          break;
      case "Open" :
          passesUpper = value < u;
          break;
      case "Unbounded" :
          passesUpper = true;
          break;
      
    }
  } else {
    passesUpper = true;
  }
  if (passesLower) {
    return passesUpper;
  } else {
    return false;
  }
}

function containsInterval(outer, inner) {
  var outerL = outer.lower;
  var passesLower;
  if (outerL !== undefined) {
    var innerL = inner.lower;
    passesLower = innerL !== undefined && innerL >= outerL ? (
        innerL === outerL ? !(outer.lowerBound === "Open" && inner.lowerBound === "Closed") : true
      ) : false;
  } else {
    passesLower = true;
  }
  var outerU = outer.upper;
  var passesUpper;
  if (outerU !== undefined) {
    var innerU = inner.upper;
    passesUpper = innerU !== undefined && innerU <= outerU ? (
        innerU === outerU ? !(outer.upperBound === "Open" && inner.upperBound === "Closed") : true
      ) : false;
  } else {
    passesUpper = true;
  }
  if (passesLower) {
    return passesUpper;
  } else {
    return false;
  }
}

function overlaps(a, b) {
  var match = a.upper;
  var match$1 = b.lower;
  var aBeforeB = match !== undefined && match$1 !== undefined ? (
      match < match$1 ? true : (
          match === match$1 ? a.upperBound === "Open" || b.lowerBound === "Open" : false
        )
    ) : false;
  var match$2 = b.upper;
  var match$3 = a.lower;
  var bBeforeA = match$2 !== undefined && match$3 !== undefined ? (
      match$2 < match$3 ? true : (
          match$2 === match$3 ? b.upperBound === "Open" || a.lowerBound === "Open" : false
        )
    ) : false;
  if (aBeforeB) {
    return false;
  } else {
    return !bBeforeA;
  }
}

function intersection(a, b) {
  if (!overlaps(a, b)) {
    return ;
  }
  var match = a.lower;
  var match$1 = b.lower;
  var match$2;
  if (match !== undefined) {
    if (match$1 !== undefined && match <= match$1) {
      if (match$1 > match) {
        match$2 = [
          match$1,
          b.lowerBound
        ];
      } else {
        var bound = a.lowerBound === "Open" || b.lowerBound === "Open" ? "Open" : "Closed";
        match$2 = [
          match,
          bound
        ];
      }
    } else {
      match$2 = [
        match,
        a.lowerBound
      ];
    }
  } else {
    match$2 = match$1 !== undefined ? [
        match$1,
        b.lowerBound
      ] : [
        undefined,
        "Unbounded"
      ];
  }
  var match$3 = a.upper;
  var match$4 = b.upper;
  var match$5;
  if (match$3 !== undefined) {
    if (match$4 !== undefined && match$3 >= match$4) {
      if (match$4 < match$3) {
        match$5 = [
          match$4,
          b.upperBound
        ];
      } else {
        var bound$1 = a.upperBound === "Open" || b.upperBound === "Open" ? "Open" : "Closed";
        match$5 = [
          match$3,
          bound$1
        ];
      }
    } else {
      match$5 = [
        match$3,
        a.upperBound
      ];
    }
  } else {
    match$5 = match$4 !== undefined ? [
        match$4,
        b.upperBound
      ] : [
        undefined,
        "Unbounded"
      ];
  }
  var result_lower = match$2[0];
  var result_upper = match$5[0];
  var result_lowerBound = match$2[1];
  var result_upperBound = match$5[1];
  var result = {
    lower: result_lower,
    upper: result_upper,
    lowerBound: result_lowerBound,
    upperBound: result_upperBound
  };
  if (isEmpty(result)) {
    return ;
  } else {
    return result;
  }
}

function span(a, b) {
  var match;
  if (a.lowerBound === "Unbounded" || b.lowerBound === "Unbounded") {
    match = [
      undefined,
      "Unbounded"
    ];
  } else {
    var match$1 = a.lower;
    var match$2 = b.lower;
    if (match$1 !== undefined) {
      if (match$2 !== undefined && match$1 >= match$2) {
        if (match$2 < match$1) {
          match = [
            match$2,
            b.lowerBound
          ];
        } else {
          var bound = a.lowerBound === "Closed" || b.lowerBound === "Closed" ? "Closed" : "Open";
          match = [
            match$1,
            bound
          ];
        }
      } else {
        match = [
          match$1,
          a.lowerBound
        ];
      }
    } else {
      match = match$2 !== undefined ? [
          match$2,
          b.lowerBound
        ] : [
          undefined,
          "Unbounded"
        ];
    }
  }
  var match$3;
  if (a.upperBound === "Unbounded" || b.upperBound === "Unbounded") {
    match$3 = [
      undefined,
      "Unbounded"
    ];
  } else {
    var match$4 = a.upper;
    var match$5 = b.upper;
    if (match$4 !== undefined) {
      if (match$5 !== undefined && match$4 <= match$5) {
        if (match$5 > match$4) {
          match$3 = [
            match$5,
            b.upperBound
          ];
        } else {
          var bound$1 = a.upperBound === "Closed" || b.upperBound === "Closed" ? "Closed" : "Open";
          match$3 = [
            match$4,
            bound$1
          ];
        }
      } else {
        match$3 = [
          match$4,
          a.upperBound
        ];
      }
    } else {
      match$3 = match$5 !== undefined ? [
          match$5,
          b.upperBound
        ] : [
          undefined,
          "Unbounded"
        ];
    }
  }
  return {
          lower: match[0],
          upper: match$3[0],
          lowerBound: match[1],
          upperBound: match$3[1]
        };
}

function length(i) {
  var match = i.lower;
  var match$1 = i.upper;
  if (match !== undefined && match$1 !== undefined) {
    return match$1 - match;
  }
  
}

function midpoint(i) {
  var match = i.lower;
  var match$1 = i.upper;
  if (match !== undefined && match$1 !== undefined) {
    return match + (match$1 - match) / 2.0;
  }
  
}

function clamp(i, value) {
  var result = value;
  var l = i.lower;
  if (l !== undefined) {
    var match = i.lowerBound;
    switch (match) {
      case "Closed" :
          if (result < l) {
            result = l;
          }
          break;
      case "Open" :
          if (result <= l) {
            result = l + 1.0e-10;
          }
          break;
      case "Unbounded" :
          break;
      
    }
  }
  var u = i.upper;
  if (u !== undefined) {
    var match$1 = i.upperBound;
    switch (match$1) {
      case "Closed" :
          if (result > u) {
            result = u;
          }
          break;
      case "Open" :
          if (result >= u) {
            result = u - 1.0e-10;
          }
          break;
      case "Unbounded" :
          break;
      
    }
  }
  return result;
}

function equal(a, b) {
  if (a.lowerBound === b.lowerBound && a.upperBound === b.upperBound && Caml_obj.equal(a.lower, b.lower)) {
    return Caml_obj.equal(a.upper, b.upper);
  } else {
    return false;
  }
}

function isProperSubsetOf(inner, outer) {
  if (containsInterval(outer, inner)) {
    return !equal(inner, outer);
  } else {
    return false;
  }
}

function toString(i) {
  var match = i.lowerBound;
  var leftBracket;
  switch (match) {
    case "Closed" :
        leftBracket = "[";
        break;
    case "Open" :
    case "Unbounded" :
        leftBracket = "(";
        break;
    
  }
  var l = i.lower;
  var lowerStr = l !== undefined ? String(l) : "-inf";
  var u = i.upper;
  var upperStr = u !== undefined ? String(u) : "+inf";
  var match$1 = i.upperBound;
  var rightBracket;
  switch (match$1) {
    case "Closed" :
        rightBracket = "]";
        break;
    case "Open" :
    case "Unbounded" :
        rightBracket = ")";
        break;
    
  }
  return leftBracket + lowerStr + ", " + upperStr + rightBracket;
}

function closedInt(lower, upper) {
  return closed(lower, upper);
}

function openInt(lower, upper) {
  return open_(lower, upper);
}

function inRange(value, lower, upper) {
  if (value >= lower) {
    return value <= upper;
  } else {
    return false;
  }
}

function inOpenRange(value, lower, upper) {
  if (value > lower) {
    return value < upper;
  } else {
    return false;
  }
}

function clampToRange(value, lower, upper) {
  if (value < lower) {
    return lower;
  } else if (value > upper) {
    return upper;
  } else {
    return value;
  }
}

function inRangeInt(value, lower, upper) {
  if (value >= lower) {
    return value <= upper;
  } else {
    return false;
  }
}

function clampToRangeInt(value, lower, upper) {
  if (value < lower) {
    return lower;
  } else if (value > upper) {
    return upper;
  } else {
    return value;
  }
}

function normalize(value, fromLower, fromUpper, toLower, toUpper) {
  var fromRange = fromUpper - fromLower;
  if (fromRange === 0.0) {
    return toLower;
  }
  var normalized = (value - fromLower) / fromRange;
  return toLower + normalized * (toUpper - toLower);
}

function lerp(i, t) {
  var match = i.lower;
  var match$1 = i.upper;
  if (match !== undefined && match$1 !== undefined) {
    return match + t * (match$1 - match);
  }
  
}

function inverseLerp(i, value) {
  var match = i.lower;
  var match$1 = i.upper;
  if (match === undefined) {
    return ;
  }
  if (match$1 === undefined) {
    return ;
  }
  var range = match$1 - match;
  if (range === 0.0) {
    return 0.0;
  } else {
    return (value - match) / range;
  }
}

function expand(i, delta) {
  return {
          lower: Belt_Option.map(i.lower, (function (l) {
                  return l - delta;
                })),
          upper: Belt_Option.map(i.upper, (function (u) {
                  return u + delta;
                })),
          lowerBound: i.lowerBound,
          upperBound: i.upperBound
        };
}

function contract(i, delta) {
  var newLower = Belt_Option.map(i.lower, (function (l) {
          return l + delta;
        }));
  var newUpper = Belt_Option.map(i.upper, (function (u) {
          return u - delta;
        }));
  if (newLower !== undefined && newUpper !== undefined) {
    if (newLower > newUpper) {
      return ;
    } else {
      return {
              lower: newLower,
              upper: newUpper,
              lowerBound: i.lowerBound,
              upperBound: i.upperBound
            };
    }
  }
  return {
          lower: newLower,
          upper: newUpper,
          lowerBound: i.lowerBound,
          upperBound: i.upperBound
        };
}

function isBounded(i) {
  if (Belt_Option.isSome(i.lower)) {
    return Belt_Option.isSome(i.upper);
  } else {
    return false;
  }
}

function isLowerUnbounded(i) {
  if (i.lowerBound === "Unbounded") {
    return true;
  } else {
    return Belt_Option.isNone(i.lower);
  }
}

function isUpperUnbounded(i) {
  if (i.upperBound === "Unbounded") {
    return true;
  } else {
    return Belt_Option.isNone(i.upper);
  }
}

var all = {
  lower: undefined,
  upper: undefined,
  lowerBound: "Unbounded",
  upperBound: "Unbounded"
};

export {
  closed ,
  open_ ,
  closedOpen ,
  openClosed ,
  atLeast ,
  greaterThan ,
  atMost ,
  lessThan ,
  all ,
  singleton ,
  isEmpty ,
  contains ,
  containsInterval ,
  overlaps ,
  intersection ,
  span ,
  length ,
  midpoint ,
  clamp ,
  equal ,
  isProperSubsetOf ,
  toString ,
  closedInt ,
  openInt ,
  inRange ,
  inOpenRange ,
  clampToRange ,
  inRangeInt ,
  clampToRangeInt ,
  normalize ,
  lerp ,
  inverseLerp ,
  expand ,
  contract ,
  isBounded ,
  isLowerUnbounded ,
  isUpperUnbounded ,
}
/* No side effect */
