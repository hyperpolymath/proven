// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_SortArray from "rescript/lib/es6/belt_SortArray.js";

function make(maxElements) {
  return {
          parent: [],
          rank: [],
          elementCount: 0,
          setCount: 0,
          maxElements: maxElements
        };
}

function makeWithElements(maxElements, initialCount) {
  if (initialCount > maxElements) {
    return {
            TAG: "Error",
            _0: "MaxCapacityReached"
          };
  }
  var parent = Belt_Array.makeBy(initialCount, (function (i) {
          return i;
        }));
  var rank = Belt_Array.make(initialCount, 0);
  return {
          TAG: "Ok",
          _0: {
            parent: parent,
            rank: rank,
            elementCount: initialCount,
            setCount: initialCount,
            maxElements: maxElements
          }
        };
}

function makeSet(uf) {
  if (uf.elementCount >= uf.maxElements) {
    return {
            TAG: "Error",
            _0: "MaxCapacityReached"
          };
  }
  var newElementIndex = uf.elementCount;
  uf.parent = Belt_Array.concat(uf.parent, [newElementIndex]);
  uf.rank = Belt_Array.concat(uf.rank, [0]);
  uf.elementCount = uf.elementCount + 1 | 0;
  uf.setCount = uf.setCount + 1 | 0;
  return {
          TAG: "Ok",
          _0: newElementIndex
        };
}

function find(uf, elementIndex) {
  if (elementIndex < 0 || elementIndex >= uf.elementCount) {
    return {
            TAG: "Error",
            _0: "ElementOutOfBounds"
          };
  }
  var current = elementIndex;
  while(true) {
    var parentIdx = Belt_Array.get(uf.parent, current);
    if (parentIdx !== undefined) {
      current = parentIdx;
      if (parentIdx === current) {
        current = -1;
      }
      
    } else {
      current = -1;
    }
    if (current === -1) {
      current = elementIndex;
      current = -2;
    }
    
  };
  var root = elementIndex;
  var continue1 = true;
  while(continue1) {
    var parentIdx$1 = Belt_Array.get(uf.parent, root);
    if (parentIdx$1 !== undefined && parentIdx$1 !== root) {
      root = parentIdx$1;
    } else {
      continue1 = false;
    }
  };
  var current2 = elementIndex;
  var continue2 = true;
  while(continue2) {
    var parentIdx$2 = Belt_Array.get(uf.parent, current2);
    if (parentIdx$2 !== undefined && !(parentIdx$2 === root || current2 === root)) {
      uf.parent[current2] = root;
      current2 = parentIdx$2;
    } else {
      continue2 = false;
    }
  };
  return {
          TAG: "Ok",
          _0: root
        };
}

function findConst(uf, elementIndex) {
  if (elementIndex < 0 || elementIndex >= uf.elementCount) {
    return {
            TAG: "Error",
            _0: "ElementOutOfBounds"
          };
  }
  var current = elementIndex;
  var continue1 = true;
  while(continue1) {
    var parentIdx = Belt_Array.get(uf.parent, current);
    if (parentIdx !== undefined && parentIdx !== current) {
      current = parentIdx;
    } else {
      continue1 = false;
    }
  };
  return {
          TAG: "Ok",
          _0: current
        };
}

function unite(uf, elementX, elementY) {
  var match = find(uf, elementX);
  var match$1 = find(uf, elementY);
  if (match.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
  var rootX = match._0;
  if (match$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match$1._0
          };
  }
  var rootY = match$1._0;
  if (rootX === rootY) {
    return {
            TAG: "Ok",
            _0: false
          };
  }
  var rankX = Belt_Option.getWithDefault(Belt_Array.get(uf.rank, rootX), 0);
  var rankY = Belt_Option.getWithDefault(Belt_Array.get(uf.rank, rootY), 0);
  if (rankX < rankY) {
    uf.parent[rootX] = rootY;
  } else if (rankX > rankY) {
    uf.parent[rootY] = rootX;
  } else {
    uf.parent[rootY] = rootX;
    uf.rank[rootX] = rankX + 1 | 0;
  }
  uf.setCount = uf.setCount - 1 | 0;
  return {
          TAG: "Ok",
          _0: true
        };
}

function connected(uf, elementX, elementY) {
  var match = find(uf, elementX);
  var match$1 = find(uf, elementY);
  if (match.TAG === "Ok") {
    if (match$1.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: match._0 === match$1._0
            };
    } else {
      return {
              TAG: "Error",
              _0: match$1._0
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
}

function connectedConst(uf, elementX, elementY) {
  var match = findConst(uf, elementX);
  var match$1 = findConst(uf, elementY);
  if (match.TAG === "Ok") {
    if (match$1.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: match._0 === match$1._0
            };
    } else {
      return {
              TAG: "Error",
              _0: match$1._0
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
}

function setSize(uf, elementIndex) {
  var root = find(uf, elementIndex);
  if (root.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: root._0
          };
  }
  var root$1 = root._0;
  var sizeCount = 0;
  for(var i = 0 ,i_finish = uf.elementCount; i < i_finish; ++i){
    var r = findConst(uf, i);
    if (r.TAG === "Ok" && r._0 === root$1) {
      sizeCount = sizeCount + 1 | 0;
    }
    
  }
  return {
          TAG: "Ok",
          _0: sizeCount
        };
}

function getSetMembers(uf, elementIndex) {
  var root = find(uf, elementIndex);
  if (root.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: root._0
          };
  }
  var root$1 = root._0;
  var members = [];
  for(var i = 0 ,i_finish = uf.elementCount; i < i_finish; ++i){
    var r = findConst(uf, i);
    if (r.TAG === "Ok" && r._0 === root$1) {
      members = Belt_Array.concat(members, [i]);
    }
    
  }
  return {
          TAG: "Ok",
          _0: members
        };
}

function getRoots(uf) {
  var roots = [];
  for(var i = 0 ,i_finish = uf.elementCount; i < i_finish; ++i){
    var parentIdx = Belt_Array.get(uf.parent, i);
    if (parentIdx !== undefined && parentIdx === i) {
      roots = Belt_Array.concat(roots, [i]);
    }
    
  }
  return roots;
}

function countSets(uf) {
  return uf.setCount;
}

function count(uf) {
  return uf.elementCount;
}

function isEmpty(uf) {
  return uf.elementCount === 0;
}

function clear(uf) {
  uf.parent = [];
  uf.rank = [];
  uf.elementCount = 0;
  uf.setCount = 0;
}

function getAllSets(uf) {
  var roots = getRoots(uf);
  return Belt_Array.map(roots, (function (root) {
                var members = getSetMembers(uf, root);
                if (members.TAG === "Ok") {
                  return members._0;
                } else {
                  return [];
                }
              }));
}

function isFullyConnected(uf) {
  return uf.setCount === 1;
}

function clone(uf) {
  return {
          parent: uf.parent.slice(0),
          rank: uf.rank.slice(0),
          elementCount: uf.elementCount,
          setCount: uf.setCount,
          maxElements: uf.maxElements
        };
}

function make$1(maxElements) {
  return {
          parent: [],
          rank: [],
          weight: [],
          elementCount: 0,
          setCount: 0,
          maxElements: maxElements
        };
}

function makeSet$1(wuf) {
  if (wuf.elementCount >= wuf.maxElements) {
    return {
            TAG: "Error",
            _0: "MaxCapacityReached"
          };
  }
  var newElementIndex = wuf.elementCount;
  wuf.parent = Belt_Array.concat(wuf.parent, [newElementIndex]);
  wuf.rank = Belt_Array.concat(wuf.rank, [0]);
  wuf.weight = Belt_Array.concat(wuf.weight, [0]);
  wuf.elementCount = wuf.elementCount + 1 | 0;
  wuf.setCount = wuf.setCount + 1 | 0;
  return {
          TAG: "Ok",
          _0: newElementIndex
        };
}

function findWithWeight(wuf, elementIndex) {
  if (elementIndex < 0 || elementIndex >= wuf.elementCount) {
    return {
            TAG: "Error",
            _0: "ElementOutOfBounds"
          };
  }
  var totalWeight = {
    contents: 0
  };
  var current = elementIndex;
  var path = [];
  var continue1 = true;
  while(continue1) {
    path = Belt_Array.concat(path, [current]);
    var parentIdx = Belt_Array.get(wuf.parent, current);
    if (parentIdx !== undefined && parentIdx !== current) {
      var w = Belt_Array.get(wuf.weight, current);
      if (w !== undefined) {
        totalWeight.contents = totalWeight.contents + w | 0;
      }
      current = parentIdx;
    } else {
      continue1 = false;
    }
  };
  var root = current;
  var accWeight = {
    contents: 0
  };
  Belt_Array.forEach(path, (function (node) {
          if (node === root) {
            return ;
          }
          var w = Belt_Array.get(wuf.weight, node);
          if (w === undefined) {
            return ;
          }
          var newWeight = totalWeight.contents - accWeight.contents | 0;
          accWeight.contents = accWeight.contents + w | 0;
          wuf.parent[node] = root;
          wuf.weight[node] = newWeight;
        }));
  var finalWeight = 0;
  var curr = elementIndex;
  var continue2 = true;
  while(continue2) {
    if (curr === root) {
      continue2 = false;
    } else {
      var w$1 = Belt_Array.get(wuf.weight, curr);
      if (w$1 !== undefined) {
        finalWeight = finalWeight + w$1 | 0;
        var p = Belt_Array.get(wuf.parent, curr);
        if (p !== undefined) {
          curr = p;
        } else {
          continue2 = false;
        }
      } else {
        continue2 = false;
      }
    }
  };
  return {
          TAG: "Ok",
          _0: {
            root: root,
            weight: finalWeight
          }
        };
}

function uniteWithWeight(wuf, elementX, elementY, weightValue) {
  var match = findWithWeight(wuf, elementX);
  var match$1 = findWithWeight(wuf, elementY);
  if (match.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
  var resultX = match._0;
  if (match$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match$1._0
          };
  }
  var resultY = match$1._0;
  if (resultX.root === resultY.root) {
    return {
            TAG: "Ok",
            _0: false
          };
  }
  var newWeight = (resultX.weight + weightValue | 0) - resultY.weight | 0;
  var rankX = Belt_Option.getWithDefault(Belt_Array.get(wuf.rank, resultX.root), 0);
  var rankY = Belt_Option.getWithDefault(Belt_Array.get(wuf.rank, resultY.root), 0);
  if (rankX < rankY) {
    wuf.parent[resultX.root] = resultY.root;
    wuf.weight[resultX.root] = -newWeight | 0;
  } else if (rankX > rankY) {
    wuf.parent[resultY.root] = resultX.root;
    wuf.weight[resultY.root] = newWeight;
  } else {
    wuf.parent[resultY.root] = resultX.root;
    wuf.weight[resultY.root] = newWeight;
    wuf.rank[resultX.root] = rankX + 1 | 0;
  }
  wuf.setCount = wuf.setCount - 1 | 0;
  return {
          TAG: "Ok",
          _0: true
        };
}

function getDifference(wuf, elementX, elementY) {
  var match = findWithWeight(wuf, elementX);
  var match$1 = findWithWeight(wuf, elementY);
  if (match.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match._0
          };
  }
  var resultX = match._0;
  if (match$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: match$1._0
          };
  }
  var resultY = match$1._0;
  if (resultX.root !== resultY.root) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Ok",
            _0: resultY.weight - resultX.weight | 0
          };
  }
}

function countSets$1(wuf) {
  return wuf.setCount;
}

function count$1(wuf) {
  return wuf.elementCount;
}

function isEmpty$1(wuf) {
  return wuf.elementCount === 0;
}

function clear$1(wuf) {
  wuf.parent = [];
  wuf.rank = [];
  wuf.weight = [];
  wuf.elementCount = 0;
  wuf.setCount = 0;
}

var Weighted = {
  make: make$1,
  makeSet: makeSet$1,
  findWithWeight: findWithWeight,
  uniteWithWeight: uniteWithWeight,
  getDifference: getDifference,
  countSets: countSets$1,
  count: count$1,
  isEmpty: isEmpty$1,
  clear: clear$1
};

function hasCycle(numVertices, edges) {
  var uf = makeWithElements(numVertices, numVertices);
  if (uf.TAG !== "Ok") {
    return false;
  }
  var uf$1 = uf._0;
  var hasCycleFound = {
    contents: false
  };
  Belt_Array.forEach(edges, (function (param) {
          if (hasCycleFound.contents) {
            return ;
          }
          var v = param[1];
          var u = param[0];
          var match = connected(uf$1, u, v);
          if (match.TAG === "Ok") {
            if (match._0) {
              hasCycleFound.contents = true;
            } else {
              unite(uf$1, u, v);
            }
            return ;
          }
          
        }));
  return hasCycleFound.contents;
}

function countComponents(numVertices, edges) {
  var uf = makeWithElements(numVertices, numVertices);
  if (uf.TAG !== "Ok") {
    return 0;
  }
  var uf$1 = uf._0;
  Belt_Array.forEach(edges, (function (param) {
          unite(uf$1, param[0], param[1]);
        }));
  return uf$1.setCount;
}

function getComponents(numVertices, edges) {
  var uf = makeWithElements(numVertices, numVertices);
  if (uf.TAG !== "Ok") {
    return [];
  }
  var uf$1 = uf._0;
  Belt_Array.forEach(edges, (function (param) {
          unite(uf$1, param[0], param[1]);
        }));
  return getAllSets(uf$1);
}

function areConnected(numVertices, edges, u, v) {
  var uf = makeWithElements(numVertices, numVertices);
  if (uf.TAG !== "Ok") {
    return false;
  }
  var uf$1 = uf._0;
  Belt_Array.forEach(edges, (function (param) {
          unite(uf$1, param[0], param[1]);
        }));
  var result = connected(uf$1, u, v);
  if (result.TAG === "Ok") {
    return result._0;
  } else {
    return false;
  }
}

function kruskalMST(numVertices, edges) {
  var uf = makeWithElements(numVertices, numVertices);
  if (uf.TAG !== "Ok") {
    return [];
  }
  var uf$1 = uf._0;
  var indexedEdges = Belt_Array.mapWithIndex(edges, (function (i, edge) {
          return [
                  i,
                  edge
                ];
        }));
  var sortedEdges = Belt_SortArray.stableSortBy(indexedEdges, (function (param, param$1) {
          return param[1][2] - param$1[1][2] | 0;
        }));
  var mstEdges = {
    contents: []
  };
  Belt_Array.forEach(sortedEdges, (function (param) {
          var match = param[1];
          var v = match[1];
          var u = match[0];
          var match$1 = connected(uf$1, u, v);
          if (match$1.TAG === "Ok" && !match$1._0) {
            unite(uf$1, u, v);
            mstEdges.contents = Belt_Array.concat(mstEdges.contents, [param[0]]);
            return ;
          }
          
        }));
  return mstEdges.contents;
}

var Applications = {
  hasCycle: hasCycle,
  countComponents: countComponents,
  getComponents: getComponents,
  areConnected: areConnected,
  kruskalMST: kruskalMST
};

export {
  make ,
  makeWithElements ,
  makeSet ,
  find ,
  findConst ,
  unite ,
  connected ,
  connectedConst ,
  setSize ,
  getSetMembers ,
  getRoots ,
  countSets ,
  count ,
  isEmpty ,
  clear ,
  getAllSets ,
  isFullyConnected ,
  clone ,
  Weighted ,
  Applications ,
}
/* No side effect */
