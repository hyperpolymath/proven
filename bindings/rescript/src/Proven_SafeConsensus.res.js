// Generated by ReScript, PLEASE EDIT WITH CARE


function errorToString(err) {
  switch (err) {
    case "InvalidClusterSize" :
        return "Cluster size must be at least 1";
    case "ExcessiveFaultTolerance" :
        return "Byzantine tolerance exceeds maximum possible for cluster size";
    case "Overflow" :
        return "Arithmetic overflow in calculation";
    case "InvalidVoteCount" :
        return "Vote count exceeds cluster size";
    case "UnachievableQuorum" :
        return "Required votes not achievable";
    
  }
}

function simpleMajority(clusterSize) {
  if (clusterSize <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidClusterSize"
          };
  }
  var half = clusterSize / 2 | 0;
  var quorum = half + 1 | 0;
  if (quorum < half) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: quorum
          };
  }
}

function checkSimpleMajority(clusterSize, voteCount) {
  if (clusterSize <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidClusterSize"
          };
  }
  if (voteCount > clusterSize) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  }
  if (voteCount < 0) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  }
  var err = simpleMajority(clusterSize);
  if (err.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: err._0
          };
  }
  var requiredVotes = err._0;
  var achieved = voteCount >= requiredVotes;
  var votesNeeded = achieved ? 0 : requiredVotes - voteCount | 0;
  return {
          TAG: "Ok",
          _0: {
            achieved: achieved,
            requiredVotes: requiredVotes,
            currentVotes: voteCount,
            votesNeeded: votesNeeded
          }
        };
}

function raftQuorum(clusterSize) {
  return simpleMajority(clusterSize);
}

function checkRaftQuorum(clusterSize, voteCount) {
  return checkSimpleMajority(clusterSize, voteCount);
}

function maxByzantineFaults(clusterSize) {
  if (clusterSize <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidClusterSize"
          };
  } else {
    return {
            TAG: "Ok",
            _0: (clusterSize - 1 | 0) / 3 | 0
          };
  }
}

function byzantineQuorum(clusterSize, maxFaultyNodes) {
  if (clusterSize <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidClusterSize"
          };
  }
  if (maxFaultyNodes < 0) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  }
  var minRequired = Math.imul(maxFaultyNodes, 3) + 1 | 0;
  if (clusterSize < minRequired) {
    return {
            TAG: "Error",
            _0: "ExcessiveFaultTolerance"
          };
  }
  var quorum = (maxFaultyNodes << 1) + 1 | 0;
  return {
          TAG: "Ok",
          _0: quorum
        };
}

function checkByzantineQuorum(clusterSize, maxFaultyNodes, voteCount) {
  if (clusterSize <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidClusterSize"
          };
  }
  if (voteCount > clusterSize) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  }
  if (voteCount < 0) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  }
  var err = byzantineQuorum(clusterSize, maxFaultyNodes);
  if (err.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: err._0
          };
  }
  var requiredVotes = err._0;
  var achieved = voteCount >= requiredVotes;
  var votesNeeded = achieved ? 0 : requiredVotes - voteCount | 0;
  return {
          TAG: "Ok",
          _0: {
            achieved: achieved,
            requiredVotes: requiredVotes,
            currentVotes: voteCount,
            votesNeeded: votesNeeded
          }
        };
}

function isValidBftConfig(config) {
  if (config.clusterSize <= 0 || config.faultyNodes < 0) {
    return false;
  }
  var minNodes = Math.imul(config.faultyNodes, 3) + 1 | 0;
  return config.clusterSize >= minNodes;
}

function weightedQuorum(totalWeight) {
  if (totalWeight <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidClusterSize"
          };
  }
  var half = totalWeight / 2 | 0;
  var quorum = half + 1 | 0;
  if (quorum < half) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: quorum
          };
  }
}

function checkWeightedQuorum(totalWeight, weightedVotes) {
  if (totalWeight <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidClusterSize"
          };
  }
  if (weightedVotes > totalWeight) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  }
  if (weightedVotes < 0) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  }
  var err = weightedQuorum(totalWeight);
  if (err.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: err._0
          };
  }
  var requiredVotes = err._0;
  var achieved = weightedVotes >= requiredVotes;
  var votesNeeded = achieved ? 0 : requiredVotes - weightedVotes | 0;
  return {
          TAG: "Ok",
          _0: {
            achieved: achieved,
            requiredVotes: requiredVotes,
            currentVotes: weightedVotes,
            votesNeeded: votesNeeded
          }
        };
}

function superMajority(clusterSize) {
  if (clusterSize <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidClusterSize"
          };
  }
  var doubled = (clusterSize << 1);
  if (doubled < clusterSize) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  }
  var twoThirds = doubled / 3 | 0;
  var quorum = twoThirds + 1 | 0;
  if (quorum < twoThirds) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: quorum
          };
  }
}

function checkSuperMajority(clusterSize, voteCount) {
  if (clusterSize <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidClusterSize"
          };
  }
  if (voteCount > clusterSize) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  }
  if (voteCount < 0) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  }
  var err = superMajority(clusterSize);
  if (err.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: err._0
          };
  }
  var requiredVotes = err._0;
  var achieved = voteCount >= requiredVotes;
  var votesNeeded = achieved ? 0 : requiredVotes - voteCount | 0;
  return {
          TAG: "Ok",
          _0: {
            achieved: achieved,
            requiredVotes: requiredVotes,
            currentVotes: voteCount,
            votesNeeded: votesNeeded
          }
        };
}

function optimalClusterSize(desiredFaultTolerance) {
  if (desiredFaultTolerance < 0) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  }
  var triple = Math.imul(desiredFaultTolerance, 3);
  if ((triple / 3 | 0) !== desiredFaultTolerance) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  }
  var size = triple + 1 | 0;
  if (size < triple) {
    return {
            TAG: "Error",
            _0: "Overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: size
          };
  }
}

function isQuorumAchievable(clusterSize, responsiveNodes, requiredQuorum) {
  if (clusterSize <= 0) {
    return {
            TAG: "Error",
            _0: "InvalidClusterSize"
          };
  } else if (responsiveNodes > clusterSize || responsiveNodes < 0) {
    return {
            TAG: "Error",
            _0: "InvalidVoteCount"
          };
  } else if (requiredQuorum > clusterSize) {
    return {
            TAG: "Error",
            _0: "UnachievableQuorum"
          };
  } else {
    return {
            TAG: "Ok",
            _0: responsiveNodes >= requiredQuorum
          };
  }
}

function paxosPrepareQuorum(clusterSize) {
  return simpleMajority(clusterSize);
}

function paxosAcceptQuorum(clusterSize) {
  return simpleMajority(clusterSize);
}

function makeQuorumResult(achieved, requiredVotes, currentVotes) {
  return {
          achieved: achieved,
          requiredVotes: requiredVotes,
          currentVotes: currentVotes,
          votesNeeded: achieved ? 0 : requiredVotes - currentVotes | 0
        };
}

function quorumProgress(result) {
  if (result.requiredVotes === 0) {
    return 1.0;
  }
  var progress = result.currentVotes / result.requiredVotes;
  return Math.min(1.0, progress);
}

function quorumProgressPercent(result) {
  return quorumProgress(result) * 100.0 | 0;
}

function quorumResultToString(result) {
  var status = result.achieved ? "achieved" : "not achieved";
  return "Quorum " + status + ": " + String(result.currentVotes) + "/" + String(result.requiredVotes) + " votes (" + String(result.votesNeeded) + " needed)";
}

export {
  errorToString ,
  simpleMajority ,
  checkSimpleMajority ,
  raftQuorum ,
  checkRaftQuorum ,
  maxByzantineFaults ,
  byzantineQuorum ,
  checkByzantineQuorum ,
  isValidBftConfig ,
  weightedQuorum ,
  checkWeightedQuorum ,
  superMajority ,
  checkSuperMajority ,
  optimalClusterSize ,
  isQuorumAchievable ,
  paxosPrepareQuorum ,
  paxosAcceptQuorum ,
  makeQuorumResult ,
  quorumProgress ,
  quorumProgressPercent ,
  quorumResultToString ,
}
/* No side effect */
