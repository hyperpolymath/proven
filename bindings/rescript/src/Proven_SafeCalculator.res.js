// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_Float from "rescript/lib/es6/belt_Float.js";

function makeEnvironment() {
  var vars = {};
  vars["pi"] = Math.PI;
  vars["e"] = Math.E;
  vars["tau"] = 2.0 * Math.PI;
  vars["phi"] = 1.618033988749895;
  return {
          variables: vars
        };
}

function setVariable(env, name, value) {
  env.variables[name] = value;
}

function getVariable(env, name) {
  return Js_dict.get(env.variables, name);
}

function isDigit(c) {
  var code = c.charCodeAt(0) | 0;
  if (code >= 48) {
    return code <= 57;
  } else {
    return false;
  }
}

function isAlpha(c) {
  var code = c.charCodeAt(0) | 0;
  if (code >= 65 && code <= 90) {
    return true;
  } else if (code >= 97) {
    return code <= 122;
  } else {
    return false;
  }
}

function isAlphaNumeric(c) {
  if (isAlpha(c) || isDigit(c)) {
    return true;
  } else {
    return c === "_";
  }
}

function makeTokenizer(input) {
  return {
          input: input,
          pos: 0
        };
}

function skipWhitespace(t) {
  var loop = function () {
    while(true) {
      if (t.pos >= t.input.length) {
        return ;
      }
      var c = t.input.charAt(t.pos);
      if (!(c === " " || c === "\t")) {
        return ;
      }
      t.pos = t.pos + 1 | 0;
      continue ;
    };
  };
  loop();
}

function getNextToken(t) {
  while(true) {
    skipWhitespace(t);
    if (t.pos >= t.input.length) {
      return {
              tokenType: "TEof",
              text: "",
              number: 0.0
            };
    }
    var c = t.input.charAt(t.pos);
    var singleCharToken;
    switch (c) {
      case "%" :
          singleCharToken = "TPercent";
          break;
      case "(" :
          singleCharToken = "TLParen";
          break;
      case ")" :
          singleCharToken = "TRParen";
          break;
      case "*" :
          singleCharToken = "TStar";
          break;
      case "+" :
          singleCharToken = "TPlus";
          break;
      case "," :
          singleCharToken = "TComma";
          break;
      case "-" :
          singleCharToken = "TMinus";
          break;
      case "/" :
          singleCharToken = "TSlash";
          break;
      case "^" :
          singleCharToken = "TCaret";
          break;
      default:
        singleCharToken = undefined;
    }
    if (singleCharToken !== undefined) {
      t.pos = t.pos + 1 | 0;
      return {
              tokenType: singleCharToken,
              text: c,
              number: 0.0
            };
    }
    if (isDigit(c) || c === ".") {
      var start = t.pos;
      while((function () {
              var tmp = false;
              if (t.pos < t.input.length) {
                var ch = t.input.charAt(t.pos);
                tmp = isDigit(ch) || ch === ".";
              }
              return tmp;
            })()) {
        t.pos = t.pos + 1 | 0;
      };
      var text = t.input.substring(start, t.pos);
      var n = Belt_Float.fromString(text);
      var num = n !== undefined ? n : 0.0;
      return {
              tokenType: "TNumber",
              text: text,
              number: num
            };
    }
    if (isAlpha(c) || c === "_") {
      var start$1 = t.pos;
      while(t.pos < t.input.length && isAlphaNumeric(t.input.charAt(t.pos))) {
        t.pos = t.pos + 1 | 0;
      };
      var text$1 = t.input.substring(start$1, t.pos);
      return {
              tokenType: "TIdentifier",
              text: text$1,
              number: 0.0
            };
    }
    t.pos = t.pos + 1 | 0;
    continue ;
  };
}

function evalFunction(name, arg) {
  switch (name) {
    case "abs" :
        return {
                TAG: "Ok",
                _0: Math.abs(arg)
              };
    case "ceil" :
        return {
                TAG: "Ok",
                _0: Math.ceil(arg)
              };
    case "cos" :
        return {
                TAG: "Ok",
                _0: Math.cos(arg)
              };
    case "exp" :
        return {
                TAG: "Ok",
                _0: Math.exp(arg)
              };
    case "floor" :
        return {
                TAG: "Ok",
                _0: Math.floor(arg)
              };
    case "ln" :
    case "log" :
        break;
    case "log10" :
        if (arg <= 0.0) {
          return {
                  TAG: "Error",
                  _0: "LogOfNonPositive"
                };
        } else {
          return {
                  TAG: "Ok",
                  _0: Math.log10(arg)
                };
        }
    case "round" :
        return {
                TAG: "Ok",
                _0: Math.round(arg)
              };
    case "sin" :
        return {
                TAG: "Ok",
                _0: Math.sin(arg)
              };
    case "sqrt" :
        if (arg < 0.0) {
          return {
                  TAG: "Error",
                  _0: "NegativeSqrt"
                };
        } else {
          return {
                  TAG: "Ok",
                  _0: Math.sqrt(arg)
                };
        }
    case "tan" :
        return {
                TAG: "Ok",
                _0: Math.tan(arg)
              };
    default:
      return {
              TAG: "Error",
              _0: {
                TAG: "UnknownFunction",
                _0: name
              }
            };
  }
  if (arg <= 0.0) {
    return {
            TAG: "Error",
            _0: "LogOfNonPositive"
          };
  } else {
    return {
            TAG: "Ok",
            _0: Math.log(arg)
          };
  }
}

function makeParser(input, env) {
  var t = {
    input: input,
    pos: 0
  };
  var current = getNextToken(t);
  return {
          tokenizer: t,
          current: current,
          env: env
        };
}

function advance(p) {
  p.current = getNextToken(p.tokenizer);
}

function parseAddSub(p) {
  var e = parseMulDiv(p);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = e._0;
  var error;
  while(error === undefined && (p.current.tokenType === "TPlus" || p.current.tokenType === "TMinus")) {
    var op = p.current.tokenType;
    advance(p);
    var e$1 = parseMulDiv(p);
    if (e$1.TAG === "Ok") {
      var right = e$1._0;
      result = op === "TPlus" ? result + right : result - right;
    } else {
      error = e$1._0;
    }
  };
  var e$2 = error;
  if (e$2 !== undefined) {
    return {
            TAG: "Error",
            _0: e$2
          };
  } else {
    return {
            TAG: "Ok",
            _0: result
          };
  }
}

function parseMulDiv(p) {
  var e = parsePower(p);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var result = e._0;
  var error;
  while(error === undefined && (p.current.tokenType === "TStar" || p.current.tokenType === "TSlash" || p.current.tokenType === "TPercent")) {
    var op = p.current.tokenType;
    advance(p);
    var e$1 = parsePower(p);
    if (e$1.TAG === "Ok") {
      var right = e$1._0;
      if (op === "TStar") {
        result = result * right;
      } else if (op === "TSlash") {
        if (right === 0.0) {
          error = "DivisionByZero";
        } else {
          result = result / right;
        }
      } else if (right === 0.0) {
        error = "ModuloByZero";
      } else {
        result = result % right;
      }
    } else {
      error = e$1._0;
    }
  };
  var e$2 = error;
  if (e$2 !== undefined) {
    return {
            TAG: "Error",
            _0: e$2
          };
  } else {
    return {
            TAG: "Ok",
            _0: result
          };
  }
}

function parsePower(p) {
  var e = parseUnary(p);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
  var base = e._0;
  if (p.current.tokenType !== "TCaret") {
    return {
            TAG: "Ok",
            _0: base
          };
  }
  advance(p);
  var e$1 = parsePower(p);
  if (e$1.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: Math.pow(base, e$1._0)
          };
  } else {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
}

function parseUnary(p) {
  while(true) {
    if (p.current.tokenType === "TMinus") {
      advance(p);
      var e = parseUnary(p);
      if (e.TAG === "Ok") {
        return {
                TAG: "Ok",
                _0: - e._0
              };
      } else {
        return {
                TAG: "Error",
                _0: e._0
              };
      }
    }
    if (p.current.tokenType !== "TPlus") {
      return parsePrimary(p);
    }
    advance(p);
    continue ;
  };
}

function parsePrimary(p) {
  if (p.current.tokenType === "TNumber") {
    var val_ = p.current.number;
    advance(p);
    return {
            TAG: "Ok",
            _0: val_
          };
  }
  if (p.current.tokenType === "TIdentifier") {
    var name = p.current.text;
    advance(p);
    if (p.current.tokenType === "TLParen") {
      advance(p);
      var e = parseAddSub(p);
      if (e.TAG === "Ok") {
        if (p.current.tokenType !== "TRParen") {
          return {
                  TAG: "Error",
                  _0: "ParenthesisMismatch"
                };
        } else {
          advance(p);
          return evalFunction(name, e._0);
        }
      } else {
        return {
                TAG: "Error",
                _0: e._0
              };
      }
    }
    var val_$1 = Js_dict.get(p.env.variables, name);
    if (val_$1 !== undefined) {
      return {
              TAG: "Ok",
              _0: val_$1
            };
    } else {
      return {
              TAG: "Error",
              _0: {
                TAG: "UndefinedVariable",
                _0: name
              }
            };
    }
  }
  if (p.current.tokenType !== "TLParen") {
    return {
            TAG: "Error",
            _0: "InvalidExpression"
          };
  }
  advance(p);
  var e$1 = parseAddSub(p);
  if (e$1.TAG === "Ok") {
    if (p.current.tokenType !== "TRParen") {
      return {
              TAG: "Error",
              _0: "ParenthesisMismatch"
            };
    } else {
      advance(p);
      return {
              TAG: "Ok",
              _0: e$1._0
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
}

function calculate(input) {
  var env = makeEnvironment();
  var p = makeParser(input, env);
  return parseAddSub(p);
}

function calculateWith(input, env) {
  var p = makeParser(input, env);
  return parseAddSub(p);
}

function div(a, b) {
  if (b === 0.0) {
    return {
            TAG: "Error",
            _0: "DivisionByZero"
          };
  } else {
    return {
            TAG: "Ok",
            _0: a / b
          };
  }
}

function safeMod(a, b) {
  if (b === 0.0) {
    return {
            TAG: "Error",
            _0: "ModuloByZero"
          };
  } else {
    return {
            TAG: "Ok",
            _0: a % b
          };
  }
}

function sqrt(x) {
  if (x < 0.0) {
    return {
            TAG: "Error",
            _0: "NegativeSqrt"
          };
  } else {
    return {
            TAG: "Ok",
            _0: Math.sqrt(x)
          };
  }
}

function ln(x) {
  if (x <= 0.0) {
    return {
            TAG: "Error",
            _0: "LogOfNonPositive"
          };
  } else {
    return {
            TAG: "Ok",
            _0: Math.log(x)
          };
  }
}

function log10(x) {
  if (x <= 0.0) {
    return {
            TAG: "Error",
            _0: "LogOfNonPositive"
          };
  } else {
    return {
            TAG: "Ok",
            _0: Math.log10(x)
          };
  }
}

function pow(base, exp) {
  return Math.pow(base, exp);
}

function errorToString(error) {
  if (typeof error === "object") {
    if (error.TAG === "UndefinedVariable") {
      return "Undefined variable: " + error._0;
    } else {
      return "Unknown function: " + error._0;
    }
  }
  switch (error) {
    case "InvalidExpression" :
        return "Invalid expression";
    case "DivisionByZero" :
        return "Division by zero";
    case "ModuloByZero" :
        return "Modulo by zero";
    case "NegativeSqrt" :
        return "Square root of negative number";
    case "LogOfNonPositive" :
        return "Logarithm of non-positive number";
    case "ParenthesisMismatch" :
        return "Parenthesis mismatch";
    case "Overflow" :
        return "Arithmetic overflow";
    
  }
}

export {
  makeEnvironment ,
  setVariable ,
  getVariable ,
  isDigit ,
  isAlpha ,
  isAlphaNumeric ,
  makeTokenizer ,
  skipWhitespace ,
  getNextToken ,
  evalFunction ,
  makeParser ,
  advance ,
  parseAddSub ,
  parseMulDiv ,
  parsePower ,
  parseUnary ,
  parsePrimary ,
  calculate ,
  calculateWith ,
  div ,
  safeMod ,
  sqrt ,
  ln ,
  log10 ,
  pow ,
  errorToString ,
}
/* No side effect */
