// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

function make(value) {
  if (value < 0.0 || value > 1.0) {
    return {
            TAG: "Error",
            _0: "OutOfRange"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              value: value
            }
          };
  }
}

function makeClamped(value) {
  return {
          value: Math.max(0.0, Math.min(1.0, value))
        };
}

function makeUnsafe(value) {
  return {
          value: value
        };
}

function getValue(p) {
  return p.value;
}

function complement(p) {
  return {
          value: 1.0 - p.value
        };
}

function toPercent(p) {
  return p.value * 100.0;
}

function fromPercent(percent) {
  return make(percent / 100.0);
}

function fromPercentClamped(percent) {
  return makeClamped(percent / 100.0);
}

function toOdds(p) {
  if (p.value >= 1.0) {
    return ;
  } else {
    return p.value / (1.0 - p.value);
  }
}

function fromOdds(odds) {
  if (odds < 0.0) {
    return {
            TAG: "Error",
            _0: "InvalidOdds"
          };
  } else {
    return make(odds / (1.0 + odds));
  }
}

function and_(p1, p2) {
  return {
          value: p1.value * p2.value
        };
}

function andAll(probs) {
  var result = Belt_Array.reduce(probs, 1.0, (function (acc, p) {
          return acc * p.value;
        }));
  return {
          value: result
        };
}

function or_(p1, p2) {
  return {
          value: p1.value + p2.value - p1.value * p2.value
        };
}

function orAll(probs) {
  var complementProduct = Belt_Array.reduce(probs, 1.0, (function (acc, p) {
          return acc * (1.0 - p.value);
        }));
  return {
          value: 1.0 - complementProduct
        };
}

function conditional(pAandB, pB) {
  if (pB.value === 0.0) {
    return {
            TAG: "Error",
            _0: "DivisionByZero"
          };
  }
  var result = pAandB.value / pB.value;
  if (result > 1.0) {
    return {
            TAG: "Error",
            _0: "InvalidProbabilities"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              value: result
            }
          };
  }
}

function bayes(prior, likelihood, evidence) {
  if (evidence.value === 0.0) {
    return {
            TAG: "Error",
            _0: "DivisionByZero"
          };
  }
  var posterior = likelihood.value * prior.value / evidence.value;
  if (posterior > 1.0) {
    return {
            TAG: "Error",
            _0: "InvalidProbabilities"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              value: posterior
            }
          };
  }
}

function binomialCoefficient(n, k) {
  if (k > n || k < 0) {
    return 0.0;
  }
  if (k === 0 || k === n) {
    return 1.0;
  }
  var kToUse = k > (n - k | 0) ? n - k | 0 : k;
  var result = 1.0;
  for(var i = 0; i < kToUse; ++i){
    result = result * (n - i | 0) / (i + 1 | 0);
  }
  return result;
}

function binomial(n, k, p) {
  if (k > n || k < 0) {
    return 0.0;
  }
  var coeff = binomialCoefficient(n, k);
  var success = Math.pow(p.value, k);
  var failure = Math.pow(1.0 - p.value, n - k | 0);
  return coeff * success * failure;
}

function binomialCumulative(n, k, p) {
  var sum = 0.0;
  for(var i = 0; i <= k; ++i){
    sum = sum + binomial(n, i, p);
  }
  return sum;
}

function expectedValue(outcomes, probabilities) {
  var numOutcomes = outcomes.length;
  var numProbs = probabilities.length;
  if (numOutcomes !== numProbs || numOutcomes === 0) {
    return ;
  }
  var sum = 0.0;
  var probSum = 0.0;
  for(var i = 0; i < numOutcomes; ++i){
    var outcome = outcomes[i];
    var prob = probabilities[i];
    sum = sum + outcome * prob.value;
    probSum = probSum + prob.value;
  }
  if (probSum < 0.99 || probSum > 1.01) {
    return ;
  } else {
    return sum;
  }
}

function variance(outcomes, probabilities, expectedVal) {
  var numOutcomes = outcomes.length;
  var numProbs = probabilities.length;
  if (numOutcomes !== numProbs || numOutcomes === 0) {
    return ;
  }
  var sum = 0.0;
  for(var i = 0; i < numOutcomes; ++i){
    var outcome = outcomes[i];
    var prob = probabilities[i];
    var diff = outcome - expectedVal;
    sum = sum + diff * diff * prob.value;
  }
  return sum;
}

function standardDeviation(outcomes, probabilities) {
  var ev = expectedValue(outcomes, probabilities);
  if (ev === undefined) {
    return ;
  }
  var v = variance(outcomes, probabilities, ev);
  if (v !== undefined) {
    return Math.sqrt(v);
  }
  
}

function isCertain(p) {
  return p.value >= 1.0;
}

function isImpossible(p) {
  return p.value <= 0.0;
}

function isLikely(p) {
  return p.value > 0.5;
}

function isUnlikely(p) {
  return p.value < 0.5;
}

function compare(p1, p2) {
  if (p1.value < p2.value) {
    return -1;
  } else if (p1.value > p2.value) {
    return 1;
  } else {
    return 0;
  }
}

function equal(p1, p2, epsilonOpt) {
  var epsilon = epsilonOpt !== undefined ? epsilonOpt : 0.0001;
  return Math.abs(p1.value - p2.value) < epsilon;
}

function normalizeWeights(weights) {
  var total = Belt_Array.reduce(weights, 0.0, (function (acc, w) {
          return acc + w;
        }));
  if (total <= 0.0) {
    return ;
  } else {
    return Belt_Array.map(weights, (function (w) {
                  return {
                          value: w / total
                        };
                }));
  }
}

function toString(p) {
  return String(p.value);
}

function toPercentString(p, decimalsOpt) {
  var decimals = decimalsOpt !== undefined ? decimalsOpt : 2;
  var percent = p.value * 100.0;
  var factor = Math.pow(10.0, decimals);
  var rounded = Math.round(percent * factor) / factor;
  return String(rounded) + "%";
}

function errorToString(error) {
  switch (error) {
    case "OutOfRange" :
        return "Probability must be between 0 and 1";
    case "InvalidOdds" :
        return "Odds must be non-negative";
    case "InvalidProbabilities" :
        return "Invalid probability combination";
    case "DivisionByZero" :
        return "Division by zero";
    
  }
}

var zero = {
  value: 0.0
};

var one = {
  value: 1.0
};

var half = {
  value: 0.5
};

export {
  make ,
  makeClamped ,
  makeUnsafe ,
  getValue ,
  zero ,
  one ,
  half ,
  complement ,
  toPercent ,
  fromPercent ,
  fromPercentClamped ,
  toOdds ,
  fromOdds ,
  and_ ,
  andAll ,
  or_ ,
  orAll ,
  conditional ,
  bayes ,
  binomialCoefficient ,
  binomial ,
  binomialCumulative ,
  expectedValue ,
  variance ,
  standardDeviation ,
  isCertain ,
  isImpossible ,
  isLikely ,
  isUnlikely ,
  compare ,
  equal ,
  normalizeWeights ,
  toString ,
  toPercentString ,
  errorToString ,
}
/* No side effect */
