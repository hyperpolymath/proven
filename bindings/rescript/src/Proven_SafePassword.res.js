// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

var defaultPolicy = {
  minLength: 8,
  maxLength: 128,
  requireUppercase: true,
  requireLowercase: true,
  requireDigit: true,
  requireSpecial: false,
  maxRepeating: 3,
  checkCommon: true
};

var strongPolicy = {
  minLength: 12,
  maxLength: 128,
  requireUppercase: true,
  requireLowercase: true,
  requireDigit: true,
  requireSpecial: true,
  maxRepeating: 2,
  checkCommon: true
};

var specialChars = "!@#$%^&*()_+-=[]{}|;':\",./<>?`~";

var commonPasswords = [
  "password",
  "123456",
  "12345678",
  "qwerty",
  "abc123",
  "monkey",
  "1234567",
  "letmein",
  "trustno1",
  "dragon",
  "baseball",
  "iloveyou",
  "master",
  "sunshine",
  "ashley",
  "bailey",
  "shadow",
  "123123",
  "654321",
  "superman",
  "qazwsx",
  "michael",
  "football",
  "password1",
  "password123",
  "admin"
];

function hasUppercase(password) {
  return /[A-Z]/.test(password);
}

function hasLowercase(password) {
  return /[a-z]/.test(password);
}

function hasDigit(password) {
  return /[0-9]/.test(password);
}

function hasSpecial(password) {
  var length = password.length;
  var found = false;
  for(var i = 0; i < length; ++i){
    if (!found) {
      var $$char = password.charAt(i);
      if (specialChars.indexOf($$char) >= 0) {
        found = true;
      }
      
    }
    
  }
  return found;
}

function hasRepeatingChars(password, maxRepeating) {
  var length = password.length;
  if (length < (maxRepeating + 1 | 0)) {
    return false;
  }
  var found = false;
  var count = 1;
  var prev = password.charAt(0);
  for(var i = 1; i < length; ++i){
    if (!found) {
      var $$char = password.charAt(i);
      if ($$char === prev) {
        count = count + 1 | 0;
        if (count > maxRepeating) {
          found = true;
        }
        
      } else {
        count = 1;
        prev = $$char;
      }
    }
    
  }
  return found;
}

function hasSequentialChars(password, sequenceLength) {
  var length = password.length;
  if (length < sequenceLength) {
    return false;
  }
  var found = false;
  var ascending = 1;
  var descending = 1;
  for(var i = 1; i < length; ++i){
    if (!found) {
      var prevCode = password.charCodeAt(i - 1 | 0) | 0;
      var currCode = password.charCodeAt(i) | 0;
      if (currCode === (prevCode + 1 | 0)) {
        ascending = ascending + 1 | 0;
        if (ascending >= sequenceLength) {
          found = true;
        }
        
      } else {
        ascending = 1;
      }
      if ((currCode + 1 | 0) === prevCode) {
        descending = descending + 1 | 0;
        if (descending >= sequenceLength) {
          found = true;
        }
        
      } else {
        descending = 1;
      }
    }
    
  }
  return found;
}

function isCommon(password) {
  var lowerPassword = password.toLowerCase();
  var found = {
    contents: false
  };
  Belt_Array.forEach(commonPasswords, (function (common) {
          if (found.contents) {
            return ;
          }
          var commonLen = common.length;
          if (lowerPassword.length < commonLen) {
            return ;
          }
          var prefix = lowerPassword.slice(0, commonLen);
          if (prefix === common) {
            found.contents = true;
            return ;
          }
          
        }));
  return found.contents;
}

function validate(password, policy) {
  var length = password.length;
  if (length < policy.minLength) {
    return {
            TAG: "Error",
            _0: "TooShort"
          };
  } else if (length > policy.maxLength) {
    return {
            TAG: "Error",
            _0: "TooLong"
          };
  } else if (policy.requireUppercase && !hasUppercase(password)) {
    return {
            TAG: "Error",
            _0: "NoUppercase"
          };
  } else if (policy.requireLowercase && !hasLowercase(password)) {
    return {
            TAG: "Error",
            _0: "NoLowercase"
          };
  } else if (policy.requireDigit && !hasDigit(password)) {
    return {
            TAG: "Error",
            _0: "NoDigit"
          };
  } else if (policy.requireSpecial && !hasSpecial(password)) {
    return {
            TAG: "Error",
            _0: "NoSpecial"
          };
  } else if (hasRepeatingChars(password, policy.maxRepeating)) {
    return {
            TAG: "Error",
            _0: "RepeatingChars"
          };
  } else if (policy.checkCommon && isCommon(password)) {
    return {
            TAG: "Error",
            _0: "CommonPassword"
          };
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

function isValid(password) {
  var match = validate(password, defaultPolicy);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function isValidStrong(password) {
  var match = validate(password, strongPolicy);
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function strengthScore(password) {
  var score = 0;
  var length = password.length;
  if (length >= 8) {
    score = score + 1 | 0;
  }
  if (length >= 12) {
    score = score + 1 | 0;
  }
  if (length >= 16) {
    score = score + 1 | 0;
  }
  if (hasUppercase(password)) {
    score = score + 1 | 0;
  }
  if (hasLowercase(password)) {
    score = score + 1 | 0;
  }
  if (hasDigit(password)) {
    score = score + 1 | 0;
  }
  if (hasSpecial(password)) {
    score = score + 2 | 0;
  }
  if (hasRepeatingChars(password, 2)) {
    score = Caml.int_max(0, score - 1 | 0);
  }
  if (hasSequentialChars(password, 3)) {
    score = Caml.int_max(0, score - 1 | 0);
  }
  if (isCommon(password)) {
    score = Caml.int_max(0, score - 3 | 0);
  }
  return score;
}

function strength(password) {
  var score = strengthScore(password);
  if (score <= 2) {
    return "VeryWeak";
  } else if (score <= 4) {
    return "Weak";
  } else if (score <= 6) {
    return "Fair";
  } else if (score <= 8) {
    return "Strong";
  } else {
    return "VeryStrong";
  }
}

function strengthToScore(s) {
  switch (s) {
    case "VeryWeak" :
        return 0;
    case "Weak" :
        return 1;
    case "Fair" :
        return 2;
    case "Strong" :
        return 3;
    case "VeryStrong" :
        return 4;
    
  }
}

function strengthToString(s) {
  switch (s) {
    case "VeryWeak" :
        return "Very Weak";
    case "Weak" :
        return "Weak";
    case "Fair" :
        return "Fair";
    case "Strong" :
        return "Strong";
    case "VeryStrong" :
        return "Very Strong";
    
  }
}

function entropy(password) {
  var length = password.length;
  if (length === 0) {
    return 0.0;
  }
  var charsetSize = 0.0;
  if (hasLowercase(password)) {
    charsetSize = charsetSize + 26.0;
  }
  if (hasUppercase(password)) {
    charsetSize = charsetSize + 26.0;
  }
  if (hasDigit(password)) {
    charsetSize = charsetSize + 10.0;
  }
  if (hasSpecial(password)) {
    charsetSize = charsetSize + 32.0;
  }
  if (charsetSize === 0.0) {
    return 0.0;
  } else {
    return length * (Math.log(charsetSize) / Math.log(2.0));
  }
}

function errorToString(err) {
  switch (err) {
    case "TooShort" :
        return "Password is too short";
    case "TooLong" :
        return "Password is too long";
    case "NoUppercase" :
        return "Password must contain at least one uppercase letter";
    case "NoLowercase" :
        return "Password must contain at least one lowercase letter";
    case "NoDigit" :
        return "Password must contain at least one digit";
    case "NoSpecial" :
        return "Password must contain at least one special character";
    case "CommonPassword" :
        return "Password is too common";
    case "RepeatingChars" :
        return "Password contains too many repeating characters";
    case "SequentialChars" :
        return "Password contains sequential characters";
    
  }
}

function validateAll(password, policy) {
  var errors = [];
  var length = password.length;
  if (length < policy.minLength) {
    errors = Belt_Array.concat(errors, ["TooShort"]);
  }
  if (length > policy.maxLength) {
    errors = Belt_Array.concat(errors, ["TooLong"]);
  }
  if (policy.requireUppercase && !hasUppercase(password)) {
    errors = Belt_Array.concat(errors, ["NoUppercase"]);
  }
  if (policy.requireLowercase && !hasLowercase(password)) {
    errors = Belt_Array.concat(errors, ["NoLowercase"]);
  }
  if (policy.requireDigit && !hasDigit(password)) {
    errors = Belt_Array.concat(errors, ["NoDigit"]);
  }
  if (policy.requireSpecial && !hasSpecial(password)) {
    errors = Belt_Array.concat(errors, ["NoSpecial"]);
  }
  if (hasRepeatingChars(password, policy.maxRepeating)) {
    errors = Belt_Array.concat(errors, ["RepeatingChars"]);
  }
  if (policy.checkCommon && isCommon(password)) {
    errors = Belt_Array.concat(errors, ["CommonPassword"]);
  }
  return errors;
}

function makePolicy(minLengthOpt, maxLengthOpt, requireUppercaseOpt, requireLowercaseOpt, requireDigitOpt, requireSpecialOpt, maxRepeatingOpt, checkCommonOpt, param) {
  var minLength = minLengthOpt !== undefined ? minLengthOpt : 8;
  var maxLength = maxLengthOpt !== undefined ? maxLengthOpt : 128;
  var requireUppercase = requireUppercaseOpt !== undefined ? requireUppercaseOpt : true;
  var requireLowercase = requireLowercaseOpt !== undefined ? requireLowercaseOpt : true;
  var requireDigit = requireDigitOpt !== undefined ? requireDigitOpt : true;
  var requireSpecial = requireSpecialOpt !== undefined ? requireSpecialOpt : false;
  var maxRepeating = maxRepeatingOpt !== undefined ? maxRepeatingOpt : 3;
  var checkCommon = checkCommonOpt !== undefined ? checkCommonOpt : true;
  return {
          minLength: minLength,
          maxLength: maxLength,
          requireUppercase: requireUppercase,
          requireLowercase: requireLowercase,
          requireDigit: requireDigit,
          requireSpecial: requireSpecial,
          maxRepeating: maxRepeating,
          checkCommon: checkCommon
        };
}

export {
  defaultPolicy ,
  strongPolicy ,
  specialChars ,
  commonPasswords ,
  hasUppercase ,
  hasLowercase ,
  hasDigit ,
  hasSpecial ,
  hasRepeatingChars ,
  hasSequentialChars ,
  isCommon ,
  validate ,
  isValid ,
  isValidStrong ,
  strengthScore ,
  strength ,
  strengthToScore ,
  strengthToString ,
  entropy ,
  errorToString ,
  validateAll ,
  makePolicy ,
}
/* No side effect */
