// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

function vectorZeros(size) {
  if (size < 0) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              data: Belt_Array.make(size, 0.0)
            }
          };
  }
}

function vectorOnes(size) {
  if (size < 0) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              data: Belt_Array.make(size, 1.0)
            }
          };
  }
}

function vectorFromArray(arr) {
  return {
          data: arr.slice(0)
        };
}

function vectorLen(v) {
  return v.data.length;
}

function vectorGet(v, index) {
  if (index < 0 || index >= v.data.length) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var value = Belt_Array.get(v.data, index);
  if (value !== undefined) {
    return {
            TAG: "Ok",
            _0: value
          };
  } else {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
}

function vectorSet(v, index, value) {
  if (index < 0 || index >= v.data.length) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var newData = v.data.slice(0);
  newData[index] = value;
  return {
          TAG: "Ok",
          _0: {
            data: newData
          }
        };
}

function vectorDot(a, b) {
  if (a.data.length !== b.data.length) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var sum = 0.0;
  for(var i = 0 ,i_finish = a.data.length; i < i_finish; ++i){
    var va = a.data[i];
    var vb = b.data[i];
    sum = sum + va * vb;
  }
  return {
          TAG: "Ok",
          _0: sum
        };
}

function vectorAdd(a, b) {
  if (a.data.length !== b.data.length) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var result = Belt_Array.make(a.data.length, 0.0);
  for(var i = 0 ,i_finish = a.data.length; i < i_finish; ++i){
    var va = a.data[i];
    var vb = b.data[i];
    result[i] = va + vb;
  }
  return {
          TAG: "Ok",
          _0: {
            data: result
          }
        };
}

function vectorSub(a, b) {
  if (a.data.length !== b.data.length) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var result = Belt_Array.make(a.data.length, 0.0);
  for(var i = 0 ,i_finish = a.data.length; i < i_finish; ++i){
    var va = a.data[i];
    var vb = b.data[i];
    result[i] = va - vb;
  }
  return {
          TAG: "Ok",
          _0: {
            data: result
          }
        };
}

function vectorScale(v, scalar) {
  var result = Belt_Array.map(v.data, (function (x) {
          return x * scalar;
        }));
  return {
          data: result
        };
}

function vectorNorm(v) {
  var sumSq = {
    contents: 0.0
  };
  Belt_Array.forEach(v.data, (function (x) {
          sumSq.contents = sumSq.contents + x * x;
        }));
  return Math.sqrt(sumSq.contents);
}

function vectorNormL1(v) {
  var sum = {
    contents: 0.0
  };
  Belt_Array.forEach(v.data, (function (x) {
          sum.contents = sum.contents + Math.abs(x);
        }));
  return sum.contents;
}

function vectorNormalize(v) {
  var norm = vectorNorm(v);
  if (norm === 0.0) {
    return {
            TAG: "Error",
            _0: "InvalidOperation"
          };
  } else {
    return {
            TAG: "Ok",
            _0: vectorScale(v, 1.0 / norm)
          };
  }
}

function vectorRange(start, size) {
  if (size < 0) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  }
  var data = Belt_Array.makeByU(size, (function (i) {
          return start + i;
        }));
  return {
          TAG: "Ok",
          _0: {
            data: data
          }
        };
}

function matrixZeros(rows, cols) {
  if (rows < 0 || cols < 0) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              data: Belt_Array.make(Math.imul(rows, cols), 0.0),
              rows: rows,
              cols: cols
            }
          };
  }
}

function matrixIdentity(size) {
  if (size < 0) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  }
  var data = Belt_Array.make(Math.imul(size, size), 0.0);
  for(var i = 0; i < size; ++i){
    data[Math.imul(i, size) + i | 0] = 1.0;
  }
  return {
          TAG: "Ok",
          _0: {
            data: data,
            rows: size,
            cols: size
          }
        };
}

function matrixFromArray2D(arr) {
  var rows = arr.length;
  if (rows === 0) {
    return {
            TAG: "Ok",
            _0: {
              data: [],
              rows: 0,
              cols: 0
            }
          };
  }
  var row = Belt_Array.get(arr, 0);
  var cols = row !== undefined ? row.length : 0;
  var valid = {
    contents: true
  };
  Belt_Array.forEach(arr, (function (row) {
          if (row.length !== cols) {
            valid.contents = false;
            return ;
          }
          
        }));
  if (!valid.contents) {
    return {
            TAG: "Error",
            _0: "InvalidShape"
          };
  }
  var data = Belt_Array.make(Math.imul(rows, cols), 0.0);
  for(var i = 0; i < rows; ++i){
    var row$1 = arr[i];
    for(var j = 0; j < cols; ++j){
      var value = row$1[j];
      data[Math.imul(i, cols) + j | 0] = value;
    }
  }
  return {
          TAG: "Ok",
          _0: {
            data: data,
            rows: rows,
            cols: cols
          }
        };
}

function matrixShape(m) {
  return [
          m.rows,
          m.cols
        ];
}

function matrixGet(m, row, col) {
  if (row < 0 || row >= m.rows || col < 0 || col >= m.cols) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var index = Math.imul(row, m.cols) + col | 0;
  var value = Belt_Array.get(m.data, index);
  if (value !== undefined) {
    return {
            TAG: "Ok",
            _0: value
          };
  } else {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
}

function matrixSet(m, row, col, value) {
  if (row < 0 || row >= m.rows || col < 0 || col >= m.cols) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var newData = m.data.slice(0);
  var index = Math.imul(row, m.cols) + col | 0;
  newData[index] = value;
  return {
          TAG: "Ok",
          _0: {
            data: newData,
            rows: m.rows,
            cols: m.cols
          }
        };
}

function matrixAdd(a, b) {
  if (a.rows !== b.rows || a.cols !== b.cols) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var result = Belt_Array.make(Math.imul(a.rows, a.cols), 0.0);
  for(var i = 0 ,i_finish = a.data.length; i < i_finish; ++i){
    var va = a.data[i];
    var vb = b.data[i];
    result[i] = va + vb;
  }
  return {
          TAG: "Ok",
          _0: {
            data: result,
            rows: a.rows,
            cols: a.cols
          }
        };
}

function matrixSub(a, b) {
  if (a.rows !== b.rows || a.cols !== b.cols) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var result = Belt_Array.make(Math.imul(a.rows, a.cols), 0.0);
  for(var i = 0 ,i_finish = a.data.length; i < i_finish; ++i){
    var va = a.data[i];
    var vb = b.data[i];
    result[i] = va - vb;
  }
  return {
          TAG: "Ok",
          _0: {
            data: result,
            rows: a.rows,
            cols: a.cols
          }
        };
}

function matrixMul(a, b) {
  if (a.cols !== b.rows) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var result = Belt_Array.make(Math.imul(a.rows, b.cols), 0.0);
  for(var i = 0 ,i_finish = a.rows; i < i_finish; ++i){
    for(var j = 0 ,j_finish = b.cols; j < j_finish; ++j){
      var sum = 0.0;
      for(var k = 0 ,k_finish = a.cols; k < k_finish; ++k){
        var va = a.data[Math.imul(i, a.cols) + k | 0];
        var vb = b.data[Math.imul(k, b.cols) + j | 0];
        sum = sum + va * vb;
      }
      result[Math.imul(i, b.cols) + j | 0] = sum;
    }
  }
  return {
          TAG: "Ok",
          _0: {
            data: result,
            rows: a.rows,
            cols: b.cols
          }
        };
}

function matrixTranspose(m) {
  var result = Belt_Array.make(Math.imul(m.rows, m.cols), 0.0);
  for(var i = 0 ,i_finish = m.rows; i < i_finish; ++i){
    for(var j = 0 ,j_finish = m.cols; j < j_finish; ++j){
      var value = m.data[Math.imul(i, m.cols) + j | 0];
      result[Math.imul(j, m.rows) + i | 0] = value;
    }
  }
  return {
          data: result,
          rows: m.cols,
          cols: m.rows
        };
}

function matrixScale(m, scalar) {
  var result = Belt_Array.map(m.data, (function (x) {
          return x * scalar;
        }));
  return {
          data: result,
          rows: m.rows,
          cols: m.cols
        };
}

function matrixTrace(m) {
  if (m.rows !== m.cols) {
    return {
            TAG: "Error",
            _0: "InvalidOperation"
          };
  }
  var sum = 0.0;
  for(var i = 0 ,i_finish = m.rows; i < i_finish; ++i){
    var value = m.data[Math.imul(i, m.cols) + i | 0];
    sum = sum + value;
  }
  return {
          TAG: "Ok",
          _0: sum
        };
}

function matrixFrobeniusNormSq(m) {
  var sum = {
    contents: 0.0
  };
  Belt_Array.forEach(m.data, (function (x) {
          sum.contents = sum.contents + x * x;
        }));
  return sum.contents;
}

function matrixFrobeniusNorm(m) {
  return Math.sqrt(matrixFrobeniusNormSq(m));
}

function matrixGetRow(m, row) {
  if (row < 0 || row >= m.rows) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var data = Belt_Array.make(m.cols, 0.0);
  for(var j = 0 ,j_finish = m.cols; j < j_finish; ++j){
    var value = m.data[Math.imul(row, m.cols) + j | 0];
    data[j] = value;
  }
  return {
          TAG: "Ok",
          _0: {
            data: data
          }
        };
}

function matrixGetCol(m, col) {
  if (col < 0 || col >= m.cols) {
    return {
            TAG: "Error",
            _0: "IndexOutOfBounds"
          };
  }
  var data = Belt_Array.make(m.rows, 0.0);
  for(var i = 0 ,i_finish = m.rows; i < i_finish; ++i){
    var value = m.data[Math.imul(i, m.cols) + col | 0];
    data[i] = value;
  }
  return {
          TAG: "Ok",
          _0: {
            data: data
          }
        };
}

function matrixVectorMul(m, v) {
  if (m.cols !== v.data.length) {
    return {
            TAG: "Error",
            _0: "DimensionMismatch"
          };
  }
  var result = Belt_Array.make(m.rows, 0.0);
  for(var i = 0 ,i_finish = m.rows; i < i_finish; ++i){
    var sum = 0.0;
    for(var j = 0 ,j_finish = m.cols; j < j_finish; ++j){
      var mVal = m.data[Math.imul(i, m.cols) + j | 0];
      var vVal = v.data[j];
      sum = sum + mVal * vVal;
    }
    result[i] = sum;
  }
  return {
          TAG: "Ok",
          _0: {
            data: result
          }
        };
}

function errorToString(err) {
  switch (err) {
    case "DimensionMismatch" :
        return "Dimension mismatch";
    case "InvalidShape" :
        return "Invalid shape";
    case "IndexOutOfBounds" :
        return "Index out of bounds";
    case "InvalidOperation" :
        return "Invalid operation";
    
  }
}

export {
  vectorZeros ,
  vectorOnes ,
  vectorFromArray ,
  vectorLen ,
  vectorGet ,
  vectorSet ,
  vectorDot ,
  vectorAdd ,
  vectorSub ,
  vectorScale ,
  vectorNorm ,
  vectorNormL1 ,
  vectorNormalize ,
  vectorRange ,
  matrixZeros ,
  matrixIdentity ,
  matrixFromArray2D ,
  matrixShape ,
  matrixGet ,
  matrixSet ,
  matrixAdd ,
  matrixSub ,
  matrixMul ,
  matrixTranspose ,
  matrixScale ,
  matrixTrace ,
  matrixFrobeniusNormSq ,
  matrixFrobeniusNorm ,
  matrixGetRow ,
  matrixGetCol ,
  matrixVectorMul ,
  errorToString ,
}
/* No side effect */
