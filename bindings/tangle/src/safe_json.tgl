## SPDX-License-Identifier: PMPL-1.0-or-later
## Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

#{ SafeJson - JSON validation and type detection via libproven FFI.

   Tangle's graph-oriented metaphors make JSON validation expressive: the
   strand<T, E> return type precisely captures whether the JSON connection
   holds (valid) or severs (parse failure). Root type detection is typed.

   All computation is performed in Idris 2 via the Zig FFI layer.
   NO JSON logic is reimplemented in Tangle.
}#

module Proven.SafeJson

import Proven.FFI
import Proven (ProvenError, strand, Severed, Connected, bool_result_to_strand, float_result_to_strand)

## ============================================================================
## JSON types matching the C ABI enum
## ============================================================================

## JSON value types as returned by the Idris 2 JSON parser.
node type JsonType =
  | JsonNull
  | JsonBool
  | JsonNumber
  | JsonString
  | JsonArray
  | JsonObject
  | JsonInvalid

## Convert a raw C ABI type code to a JsonType.
weave fn int_to_json_type(code : Int32) -> JsonType =
  match code with
  | 0  => JsonNull
  | 1  => JsonBool
  | 2  => JsonNumber
  | 3  => JsonString
  | 4  => JsonArray
  | 5  => JsonObject
  | _  => JsonInvalid

## ============================================================================
## JSON validation
## ============================================================================

## Check if a string is valid JSON.
## Returns Connected(true) if valid, Connected(false) if not.
## Delegates to proven_json_is_valid in libproven.
weave fn is_valid_json(input : String) -> strand<Bool, ProvenError> =
  let bytes = string_to_utf8(input)
  bool_result_to_strand(
    FFI.proven_json_is_valid(bytes.ptr, bytes.len)
  )

## Get the JSON value type at the root level.
## Returns JsonInvalid if the string is not valid JSON.
## Delegates to proven_json_get_type in libproven.
weave fn json_type(input : String) -> JsonType =
  let bytes = string_to_utf8(input)
  int_to_json_type(FFI.proven_json_get_type(bytes.ptr, bytes.len))

## Validate JSON and return the type in one step.
## Returns Severed(ParseFailure) if the input is not valid JSON.
## Combines proven_json_is_valid and proven_json_get_type from libproven.
weave fn validate_json(input : String) -> strand<JsonType, ProvenError> =
  match is_valid_json(input) with
  | Connected(true)  => Connected(json_type(input))
  | Connected(false) => Severed(ParseFailure)
  | Severed(e)       => Severed(e)

## ============================================================================
## Safe expression evaluation
## ============================================================================

## Safely evaluate an arithmetic expression string.
## Supports +, -, *, /, parentheses, negative and decimal numbers.
## Returns Severed(ParseFailure) for invalid expressions.
## Returns Severed(DivByZero) for division by zero.
## Delegates to proven_calculator_eval in libproven.
weave fn eval_expression(expr : String) -> strand<Float64, ProvenError> =
  let bytes = string_to_utf8(expr)
  float_result_to_strand(
    FFI.proven_calculator_eval(bytes.ptr, bytes.len)
  )

## ============================================================================
## Tangle specific: typed JSON validation
## ============================================================================

## A validated JSON string type. Can only be constructed through the
## validate function, ensuring the JSON has been parsed by the Idris 2
## verified JSON validator.
node type ValidatedJson = private ValidatedJson(String, JsonType)

## Get the original JSON string.
weave fn validated_json_string(json : ValidatedJson) -> String =
  match json with
  | ValidatedJson(s, _) => s

## Get the root type of the validated JSON.
weave fn validated_json_type(json : ValidatedJson) -> JsonType =
  match json with
  | ValidatedJson(_, t) => t

## Create a ValidatedJson value, returning an error if validation fails.
weave fn make_validated_json(input : String) -> strand<ValidatedJson, ProvenError> =
  match validate_json(input) with
  | Connected(t) => Connected(ValidatedJson(input, t))
  | Severed(e)   => Severed(e)
