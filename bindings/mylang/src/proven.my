// SPDX-License-Identifier: PMPL-1.0-or-later
// Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

// | Proven - FFI bindings to libproven (Idris 2 verified safety library)
// for MyLang.
//
// MyLang is a personal/customizable programming language with Rust-like FFI
// syntax. This module provides the core error types and result wrappers that
// all Proven modules build upon.
//
// All computation is performed in Idris 2 via the Zig FFI layer.
// NO safety logic is reimplemented in MyLang.
//
// Architecture:
//   MyLang (.my)
//     |  extern "C" fn ...
//     v
//   libproven.so (Zig FFI layer)
//     |  Zig -> Idris2 RefC calls
//     v
//   Idris 2 (dependent types, totality checking)

module Proven

import Proven.FFI
import Proven.SafeMath
import Proven.SafeString
import Proven.SafeEmail
import Proven.SafeUrl
import Proven.SafeCrypto
import Proven.SafeJson

// ============================================================================
// Core error type for Proven operations
// ============================================================================

// | ProvenError enumerates all possible failure modes from the libproven C ABI.
// Each variant carries the semantic meaning of the failure, enabling exhaustive
// pattern matching in error handlers.
type ProvenError = enum {
  Overflow,            // Arithmetic overflow (status -3)
  Underflow,           // Arithmetic underflow (status -4)
  DivByZero,           // Division by zero (status -5)
  NullPointer,         // Null pointer passed (status -1)
  InvalidArgument,     // Invalid argument (status -2)
  ParseFailure,        // Parse failure (status -6)
  ValidationFailed,    // Validation failed (status -7)
  OutOfBounds,         // Index out of bounds (status -8)
  EncodingError,       // Encoding error (status -9)
  AllocationFailed,    // Memory allocation failed (status -10)
  NotImplemented,      // Feature not implemented (status -99)
  UnknownError(i32),   // Unrecognized status code
}

// | Convert a raw C ABI status code to a ProvenError.
// This function is total: every possible i32 maps to exactly one error.
fn status_to_error(code : i32) -> ProvenError =
  match code {
    -1  => ProvenError::NullPointer,
    -2  => ProvenError::InvalidArgument,
    -3  => ProvenError::Overflow,
    -4  => ProvenError::Underflow,
    -5  => ProvenError::DivByZero,
    -6  => ProvenError::ParseFailure,
    -7  => ProvenError::ValidationFailed,
    -8  => ProvenError::OutOfBounds,
    -9  => ProvenError::EncodingError,
    -10 => ProvenError::AllocationFailed,
    -99 => ProvenError::NotImplemented,
    n   => ProvenError::UnknownError(n),
  }

// ============================================================================
// Result<T, E> type
// ============================================================================

// | The core result type for all Proven operations.
// Result<T, ProvenError> is the canonical return type.
type Result<T, E> = enum {
  Ok(T),
  Err(E),
}

// | Convert an FFI IntResult into a Result<i64, ProvenError>.
fn int_result_to_proven(ir : FFI.IntResult) -> Result<i64, ProvenError> =
  match ir.status {
    0 => Result::Ok(ir.value),
    s => Result::Err(status_to_error(s)),
  }

// | Convert an FFI BoolResult into a Result<bool, ProvenError>.
fn bool_result_to_proven(br : FFI.BoolResult) -> Result<bool, ProvenError> =
  match br.status {
    0 => Result::Ok(br.value != 0),
    s => Result::Err(status_to_error(s)),
  }

// | Convert an FFI FloatResult into a Result<f64, ProvenError>.
fn float_result_to_proven(fr : FFI.FloatResult) -> Result<f64, ProvenError> =
  match fr.status {
    0 => Result::Ok(fr.value),
    s => Result::Err(status_to_error(s)),
  }

// | Convert an FFI StringResult into a Result<String, ProvenError>,
// freeing the C-allocated string after copying.
fn string_result_to_proven(sr : FFI.StringResult) -> Result<String, ProvenError> =
  match sr.status {
    0 => {
      let result = string_from_ptr(sr.ptr, sr.len)
      FFI.proven_free_string(sr.ptr)
      Result::Ok(result)
    },
    s => Result::Err(status_to_error(s)),
  }

// ============================================================================
// Lifecycle management
// ============================================================================

// | Initialize the Proven runtime. Must be called before any other function.
// Returns Ok(()) on success.
fn init() -> Result<(), ProvenError> =
  let status = FFI.proven_init()
  match status {
    0 => Result::Ok(()),
    s => Result::Err(status_to_error(s)),
  }

// | Deinitialize the Proven runtime. Call when done.
fn deinit() -> void =
  FFI.proven_deinit()

// | Check if the Proven runtime is initialized.
fn is_initialized() -> bool =
  FFI.proven_is_initialized()

// | Get the library version as a tuple (major, minor, patch).
fn version() -> (u32, u32, u32) =
  (FFI.proven_version_major(), FFI.proven_version_minor(), FFI.proven_version_patch())

// | Get the FFI ABI version for compatibility checking.
fn abi_version() -> u32 =
  FFI.proven_ffi_abi_version()

// | Get the total module count in libproven.
fn module_count() -> u32 =
  FFI.proven_module_count()

// ============================================================================
// Re-exports
// ============================================================================

export Proven.SafeMath.*
export Proven.SafeString.*
export Proven.SafeEmail.*
export Proven.SafeUrl.*
export Proven.SafeCrypto.*
export Proven.SafeJson.*
