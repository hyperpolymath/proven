// SPDX-License-Identifier: PMPL-1.0-or-later
// Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

// | SafeUrl - URL parsing and validation via libproven FFI.
//
// MyLang's Result type captures parse failures, null pointer errors,
// and validation failures in the return type. All URL parsing is
// performed by the Idris 2 verified core.
//
// All computation is performed in Idris 2 via the Zig FFI layer.
// NO URL logic is reimplemented in MyLang.

module Proven.SafeUrl

import Proven.FFI
import Proven (ProvenError, Result)

// ============================================================================
// URL components
// ============================================================================

// | Parsed URL components returned by the Idris 2 URL parser.
type UrlComponents = struct {
  scheme   : String,
  host     : String,
  port     : Option<u16>,
  path     : String,
  query    : Option<String>,
  fragment : Option<String>,
}

// ============================================================================
// URL parsing
// ============================================================================

// | Parse a URL string into its components.
// Returns Err(ParseFailure) if the URL is malformed.
// Returns Err(NullPointer) if the input is null.
// Memory allocated by libproven is freed after copying components.
// Delegates to proven_url_parse and proven_url_free in libproven.
fn parse_url(url : String) -> Result<UrlComponents, ProvenError> =
  let bytes = string_to_utf8(url)
  let raw_result = FFI.proven_url_parse(bytes.ptr, bytes.len)
  match raw_result {
    null => Result::Err(ProvenError::ParseFailure),
    ptr  => {
      let components = read_url_components(ptr)
      FFI.proven_url_free(ptr)
      Result::Ok(components)
    },
  }

// | Validate that a string is a well-formed URL without returning components.
// Returns Ok(true) if parseable, Ok(false) if not.
// Delegates to proven_url_parse in libproven.
fn is_valid_url(url : String) -> Result<bool, ProvenError> =
  let bytes = string_to_utf8(url)
  let raw_result = FFI.proven_url_parse(bytes.ptr, bytes.len)
  match raw_result {
    null => Result::Ok(false),
    ptr  => {
      FFI.proven_url_free(ptr)
      Result::Ok(true)
    },
  }

// ============================================================================
// MyLang specific: validated URL type
// ============================================================================

// | A validated URL type. Can only be constructed through the parse function,
// ensuring the URL has been validated by the Idris 2 verified parser.
type ValidatedUrl = struct private {
  raw        : String,
  components : UrlComponents,
}

// | Get the original URL string.
fn validated_url_string(url : ValidatedUrl) -> String =
  url.raw

// | Get the parsed components.
fn validated_url_components(url : ValidatedUrl) -> UrlComponents =
  url.components

// | Create a ValidatedUrl, returning an error if parsing fails.
// Uses the Idris 2 verified URL parser via FFI.
fn make_validated_url(url : String) -> Result<ValidatedUrl, ProvenError> =
  match parse_url(url) {
    Result::Ok(components) => Result::Ok(ValidatedUrl { raw: url, components: components }),
    Result::Err(e)         => Result::Err(e),
  }
