// SPDX-License-Identifier: PMPL-1.0-or-later
// Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

/// SafeUrl -- Affine wrappers around libproven URL parsing FFI.
///
/// All operations delegate to the formally verified Idris 2 implementation
/// via the Zig FFI layer. Results are affine (consumed at most once).
/// Prevents malformed URL crashes.

module Proven.SafeUrl

import Proven.FFI
import Proven (ProvenError, status_to_error)

// ---------------------------------------------------------------------------
// Public types
// ---------------------------------------------------------------------------

/// Parsed URL components. Affine -- consumed at most once.
type ParsedUrl = own {
  scheme: String,
  host: String,
  port: Option[Int],
  path: String,
  query: Option[String],
  fragment: Option[String]
}

// ---------------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------------

/// Convert an FFI BoolResult into a Result[Bool, ProvenError].
fn bool_result_to_result(result: BoolResult) -> Result[Bool, own ProvenError] / Pure {
  if result.status == STATUS_OK {
    Ok(result.value != 0)
  } else {
    Err(status_to_error(result.status))
  }
}

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/// Parse a URL string into its components.
/// Delegates to proven_url_parse via FFI.
///
/// Returns an affine ParsedUrl on success that must be consumed at most once.
fn parse(url: ref String) -> Option[own ParsedUrl] / Pure {
  let (ptr, len) = string_to_raw(url);
  let result = extern_proven_url_parse(ptr, len);
  if result.status == STATUS_OK {
    // The FFI returns a struct with component pointers; marshal here.
    Some(marshal_url_components(result))
  } else {
    None
  }
}

/// Check if a URL is valid (can be parsed without error).
/// Delegates to proven_url_parse via FFI.
fn is_valid(url: ref String) -> Bool / Pure {
  match parse(url) {
    None => false,
    Some(_) => true
  }
}

/// Extract the host from a URL.
fn get_host(url: ref String) -> Option[String] / Pure {
  match parse(url) {
    None => None,
    Some(parsed) => Some(parsed.host)
  }
}

/// Extract the scheme from a URL.
fn get_scheme(url: ref String) -> Option[String] / Pure {
  match parse(url) {
    None => None,
    Some(parsed) => Some(parsed.scheme)
  }
}

/// Check if a URL uses HTTPS.
fn is_https(url: ref String) -> Bool / Pure {
  match get_scheme(url) {
    None => false,
    Some(scheme) => string_eq_ignore_case(scheme, "https")
  }
}

/// Validate a URL and return it if valid.
fn validate(url: ref String) -> Result[String, own ProvenError] / Pure {
  if is_valid(url) {
    Ok(string_clone(url))
  } else {
    Err(ProvenError {
      code: -6,
      message: "invalid URL"
    })
  }
}
