// SPDX-License-Identifier: PMPL-1.0
// SPDX-FileCopyrightText: 2025 Hyperpolymath
//
// integration_test.zig - Tests proven FFI with real Idris 2 RefC output
//
// This test links against the C code generated by Idris 2's RefC backend
// and verifies that the FFI bridge works correctly.

const std = @import("std");
const ffi = @import("idris2_zig_ffi");

// Import the main proven FFI
const proven = @import("../src/main.zig");

// External C functions from Idris 2 RefC output
// These would be generated by: idris2 --codegen refc -o testsafe TestSafe.idr
extern fn idris2_main() void;

test "FFI initialization" {
    // Test that we can initialize the runtime
    const result = proven.proven_init();
    try std.testing.expectEqual(@as(c_int, 0), result);

    // Verify initialized state
    try std.testing.expect(proven.proven_is_initialized());

    // Cleanup
    proven.proven_deinit();
    try std.testing.expect(!proven.proven_is_initialized());
}

test "ABI version" {
    const abi_version = proven.proven_ffi_abi_version();
    try std.testing.expect(abi_version >= 1);
}

test "safe math operations" {
    // Test division
    const div_ok = proven.proven_math_div(10, 2);
    try std.testing.expectEqual(proven.ProvenStatus.ok, div_ok.status);
    try std.testing.expectEqual(@as(i64, 5), div_ok.value);

    const div_zero = proven.proven_math_div(10, 0);
    try std.testing.expectEqual(proven.ProvenStatus.err_division_by_zero, div_zero.status);

    // Test checked addition
    const add_ok = proven.proven_math_add_checked(5, 3);
    try std.testing.expectEqual(proven.ProvenStatus.ok, add_ok.status);
    try std.testing.expectEqual(@as(i64, 8), add_ok.value);

    // Test overflow detection
    const max = std.math.maxInt(i64);
    const add_overflow = proven.proven_math_add_checked(max, 1);
    try std.testing.expectEqual(proven.ProvenStatus.err_overflow, add_overflow.status);
}

test "string validation" {
    // Test UTF-8 validation
    const valid_utf8 = "Hello, World!";
    const utf8_result = proven.proven_string_is_valid_utf8(valid_utf8.ptr, valid_utf8.len);
    try std.testing.expectEqual(proven.ProvenStatus.ok, utf8_result.status);
    try std.testing.expect(utf8_result.value);

    // Test with invalid UTF-8
    const invalid_utf8 = [_]u8{ 0xFF, 0xFE };
    const invalid_result = proven.proven_string_is_valid_utf8(&invalid_utf8, invalid_utf8.len);
    try std.testing.expectEqual(proven.ProvenStatus.ok, invalid_result.status);
    try std.testing.expect(!invalid_result.value);
}

test "path traversal detection" {
    // Safe path
    const safe_path = "path/to/file.txt";
    const safe_result = proven.proven_path_has_traversal(safe_path.ptr, safe_path.len);
    try std.testing.expect(!safe_result.value);

    // Unsafe path
    const unsafe_path = "../../../etc/passwd";
    const unsafe_result = proven.proven_path_has_traversal(unsafe_path.ptr, unsafe_path.len);
    try std.testing.expect(unsafe_result.value);
}

test "email validation" {
    // Valid email
    const valid_email = "user@example.com";
    const valid_result = proven.proven_email_is_valid(valid_email.ptr, valid_email.len);
    try std.testing.expect(valid_result.value);

    // Invalid email
    const invalid_email = "not-an-email";
    const invalid_result = proven.proven_email_is_valid(invalid_email.ptr, invalid_email.len);
    try std.testing.expect(!invalid_result.value);
}

test "string escaping" {
    // SQL escaping
    const sql_input = "O'Reilly";
    const sql_result = proven.proven_string_escape_sql(sql_input.ptr, sql_input.len);
    defer proven.proven_free_string(sql_result.value);

    try std.testing.expectEqual(proven.ProvenStatus.ok, sql_result.status);
    try std.testing.expectEqualStrings("O''Reilly", sql_result.value.?[0..sql_result.length]);

    // HTML escaping
    const html_input = "<script>alert('xss')</script>";
    const html_result = proven.proven_string_escape_html(html_input.ptr, html_input.len);
    defer proven.proven_free_string(html_result.value);

    try std.testing.expectEqual(proven.ProvenStatus.ok, html_result.status);
}

test "IPv4 parsing" {
    // Valid IPv4
    const ipv4 = "192.168.1.1";
    const result = proven.proven_network_parse_ipv4(ipv4.ptr, ipv4.len);

    try std.testing.expectEqual(proven.ProvenStatus.ok, result.status);
    try std.testing.expectEqual(@as(u8, 192), result.address.octets[0]);
    try std.testing.expectEqual(@as(u8, 168), result.address.octets[1]);
    try std.testing.expectEqual(@as(u8, 1), result.address.octets[2]);
    try std.testing.expectEqual(@as(u8, 1), result.address.octets[3]);

    // Check private IP detection
    try std.testing.expect(proven.proven_network_ipv4_is_private(result.address));
}

test "URL parsing" {
    const url = "https://example.com:8080/path?query=value#fragment";
    var result = proven.proven_url_parse(url.ptr, url.len);
    defer proven.proven_url_free(&result.components);

    try std.testing.expectEqual(proven.ProvenStatus.ok, result.status);
    try std.testing.expectEqualStrings("https", result.components.scheme.?[0..result.components.scheme_len]);
    try std.testing.expectEqualStrings("example.com", result.components.host.?[0..result.components.host_len]);
    try std.testing.expect(result.components.has_port);
    try std.testing.expectEqual(@as(u16, 8080), result.components.port);
}

test "cryptographic operations" {
    // Test random bytes generation
    var buf1: [32]u8 = undefined;
    var buf2: [32]u8 = undefined;

    const status1 = proven.proven_crypto_random_bytes(&buf1, buf1.len);
    const status2 = proven.proven_crypto_random_bytes(&buf2, buf2.len);

    try std.testing.expectEqual(proven.ProvenStatus.ok, status1);
    try std.testing.expectEqual(proven.ProvenStatus.ok, status2);

    // Very unlikely to be equal
    try std.testing.expect(!std.mem.eql(u8, &buf1, &buf2));

    // Test constant-time comparison
    const a = "secret_password";
    const b = "secret_password";
    const c = "different_value";

    const eq_result = proven.proven_crypto_constant_time_eq(a.ptr, a.len, b.ptr, b.len);
    try std.testing.expect(eq_result.value);

    const neq_result = proven.proven_crypto_constant_time_eq(a.ptr, a.len, c.ptr, c.len);
    try std.testing.expect(!neq_result.value);
}

test "type conversion bridge" {
    // Test Proven -> C ABI type conversion
    const ok_result = proven.IntResult{ .status = .ok, .value = 42 };
    const c_result = proven.intResultToCResult(ok_result);

    try std.testing.expect(c_result.success);
    try std.testing.expectEqual(@as(i64, 42), c_result.value.int);

    // Test error conversion
    const err_result = proven.IntResult{ .status = .err_division_by_zero, .value = 0 };
    const c_err = proven.intResultToCResult(err_result);

    try std.testing.expect(!c_err.success);
    try std.testing.expectEqual(proven.c_abi.ErrorCode.DIVISION_BY_ZERO, c_err.error_code);
}
